---
# Documentation: https://sourcethemes.com/academic/docs/managing-content/

title: "Go语言中文网面试题 31-60"
subtitle: ""
summary: "Go语言中文网面试题"
authors: []
tags: ["Go"]
categories: ["interview"]
date: 2020-07-27T22:07:56+08:00
lastmod: 2020-07-27T22:07:56+08:00
featured: false
draft: false
toc: true

# Featured image
# To use, add an image named `featured.jpg/png` to your page's folder.
# Focal points: Smart, Center, TopLeft, Top, TopRight, Left, Right, BottomLeft, Bottom, BottomRight.
image:
  caption: ""
  focal_point: ""
  preview_only: false

# Projects (optional).
#   Associate this post with one or more of your projects.
#   Simply enter your project's folder or file name without extension.
#   E.g. `projects = ["internal-project"]` references `content/project/deep-learning/index.md`.
#   Otherwise, set `projects = []`.
projects: []
---

## Day 31. 可变函数、append()

1.下面这段代码输出什么？

```go
func change(s ...int) {
    s = append(s,3)
}

func main() {
    slice := make([]int,5,5)
    slice[0] = 1
    slice[1] = 2
    change(slice...)
    fmt.Println(slice)
    change(slice[0:2]...)
    fmt.Println(slice)
}
```

参考答案及解析：

```go
[1 2 0 0 0]
[1 2 3 0 0]
```

知识点：可变函数、append()操作。

Go 提供的语法糖`...`，可以将 slice 传进可变函数，不会创建新的切片。

第一次调用 change() 时，append() 操作使切片底层数组发生了扩容，原 slice 的底层数组不会改变；

第二次调用change() 函数时，使用了操作符`[i,j]`获得一个新的切片，假定为 slice1，它的底层数组和原切片底层数组是重合的，不过 slice1 的长度、容量分别是 2、5，所以在 change() 函数中对 slice1 底层数组的修改会影响到原切片。

![](./31-1.png)

[可变函数](http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&mid=2648466706&idx=3&sn=003c213739e51088ad4947e473429775&chksm=f247437dc530ca6bafebe0a5a4090343cbf1eb992e36b6199cf213be6156273179465ed41348&scene=21#wechat_redirect)

[非懂不可的Slice（一）](http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&mid=2648466739&idx=3&sn=9a1c9599172a532297ef41238450f9af&chksm=f247435cc530ca4ac6d92bd22011b52ae34d25d6e0eddf5b2ba85a15d3846b6674aa8bcf1d07&scene=21#wechat_redirect)

[非懂不可的Slice（二）](http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&mid=2648466739&idx=4&sn=9de0eba9bdb36aa3b67d8a3903c53584&chksm=f247435cc530ca4a98abd9c1b2d58a63c7716e64236076c1296ed2964cd4fb68f7c8a6d44f85&scene=21#wechat_redirect)

<br/>

2.下面这段代码输出什么？

```go
func main() {
    var a = []int{1, 2, 3, 4, 5}
    var r [5]int

    for i, v := range a {
        if i == 0 {
            a[1] = 12
            a[2] = 13
        }
        r[i] = v
    }
    fmt.Println("r = ", r)
    fmt.Println("a = ", a)
}
```

参考答案及解析：

```go
r =  [1 12 13 4 5]
a =  [1 12 13 4 5]
```

这道题是 [第30天](http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&mid=2648467013&idx=1&sn=e9856544b4ef7e02deb62e5839550786&chksm=f247402ac530c93c879f433e88cdd4ab55fcc6b336d342f3a8c1ece6cecb6b131f5acc486264&scene=21#wechat_redirect) 的第二题的一个解决办法，这的 a 是一个切片，那切片是怎么实现的呢？切片在 go 的内部结构有一个指向底层数组的指针，当 range 表达式发生复制时，副本的指针依旧指向原底层数组，所以对切片的修改都会反应到底层数组上，所以通过 v 可以获得修改后的数组元素。

引自：https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/

<br/>



## Day 32. for range ,map

1.下面这段代码输出结果正确吗？

```go
type Foo struct {
    bar string
}
func main() {
    s1 := []Foo{
        {"A"},
        {"B"},
        {"C"},
    }
    s2 := make([]*Foo, len(s1))
    for i, value := range s1 {
        s2[i] = &value
    }
    fmt.Println(s1[0], s1[1], s1[2])
    fmt.Println(s2[0], s2[1], s2[2])
}
输出：
{A} {B} {C}
&{A} &{B} &{C}
```

参考答案及解析：s2 的输出结果错误。s2 的输出是 `&{C} &{C} &{C}`，在 [第 30 天](http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&mid=2648467013&idx=1&sn=e9856544b4ef7e02deb62e5839550786&chksm=f247402ac530c93c879f433e88cdd4ab55fcc6b336d342f3a8c1ece6cecb6b131f5acc486264&scene=21#wechat_redirect) 的答案解析第二题，我们提到过，for range 使用短变量声明(:=)的形式迭代变量时，变量 i、value 在每次循环体中都会被重用，而不是重新声明。所以 s2 每次填充的都是临时变量 value 的地址，而在最后一次循环中，value 被赋值为{c}。因此，s2 输出的时候显示出了三个 &{c}。

可行的解决办法如下：

```go
for i := range s1 {
    s2[i] = &s1[i]
}
```

2.下面代码里的 counter 的输出值？

```go
func main() {

    var m = map[string]int{
        "A": 21,
        "B": 22,
        "C": 23,
    }
    counter := 0
    for k, v := range m {
        if counter == 0 {
            delete(m, "A")
        }
        counter++
        fmt.Println(k, v)
    }
    fmt.Println("counter is ", counter)
}
```

- A. 2
- B. 3
- C. 2 或 3

参考答案及解析：C。for range map 是无序的，如果第一次循环到 A，则输出 3；否则输出 2。

<br/>

## Day 33. 协程，循环语句，多重赋值

1.关于协程，下面说法正确是（）

- A. 协程和线程都可以实现程序的并发执行；
- B. 线程比协程更轻量级；
- C. 协程不存在死锁问题；
- D. 通过 channel 来进行协程间的通信；

参考答案及解析：AD。

<br/>

2.关于循环语句，下面说法正确的有（）

- A. 循环语句既支持 for 关键字，也支持 while 和 do-while；
- B. 关键字 for 的基本使用方法与 C/C++ 中没有任何差异；
- C. for 循环支持 continue 和 break 来控制循环，但是它提供了一个更高级的 break，可以选择中断哪一个循环；
- D. for 循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量；

参考答案及解析：CD。

<br/>

3.下面代码输出正确的是？

```go
func main() {
    i := 1
    s := []string{"A", "B", "C"}
    i, s[i-1] = 2, "Z"
    fmt.Printf("s: %v \n", s)
}
```

- A. s: [Z,B,C]
- B. s: [A,Z,C]

参考答案及解析：A。知识点：多重赋值。

多重赋值分为两个步骤，有先后顺序：

- 计算等号左边的索引表达式和取址表达式，接着计算等号右边的表达式；
- 赋值；

所以本例，会先计算 s[i-1]，等号右边是两个表达式是常量，所以赋值运算等同于 `i, s[0] = 2, "Z"`。

<br/>

## Day 34. 强制类型转化,类型断言、方法集

1.关于类型转化，下面选项正确的是？

```go
A.
type MyInt int
var i int = 1
var j MyInt = i

B.
type MyInt int
var i int = 1
var j MyInt = (MyInt)i

C.
type MyInt int
var i int = 1
var j MyInt = MyInt(i)

D.
type MyInt int
var i int = 1
var j MyInt = i.(MyInt)
```

参考答案及解析：C。知识点：强制类型转化。

<br/>

2.关于switch语句，下面说法正确的有?

- A. 条件表达式必须为常量或者整数；
- B. 单个case中，可以出现多个结果选项；
- C. 需要用break来明确退出一个case；
- D. 只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case；

参考答案及解析：BD。参考文章 [条件语句和循环语句](http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&mid=2648467036&idx=2&sn=79bb23c3d1d2eef7e989ecc2643b5f5a&chksm=f2474033c530c925d5accf3633888d783dd3e3137b71a3b963a397d198e2619cd8e32f0ddd4f&scene=21#wechat_redirect)

<br/>

3.如果 Add() 函数的调用代码为：

```go
func main() {
    var a Integer = 1
    var b Integer = 2
    var i interface{} = &a
    sum := i.(*Integer).Add(b)
    fmt.Println(sum)
}
```

则Add函数定义正确的是()

```go
A.
type Integer int
func (a Integer) Add(b Integer) Integer {
        return a + b
}

B.
type Integer int
func (a Integer) Add(b *Integer) Integer {
        return a + *b
}

C.
type Integer int
func (a *Integer) Add(b Integer) Integer {
        return *a + b
}

D.
type Integer int
func (a *Integer) Add(b *Integer) Integer {
        return *a + *b
}
```

参考答案及解析：AC。知识点：类型断言、方法集。

<br/>

## Day 35. bool, 自增和自减, 接口

1.关于 bool 变量 b 的赋值，下面错误的用法是？

- A. b = true
- B. b = 1
- C. b = bool(1)
- D. b = (1 == 2)

参考答案及解析：BC。

<br/>

2.关于变量的自增和自减操作，下面语句正确的是？

```go
A.
i := 1
i++

B.
i := 1
j = i++

C.
i := 1
++i

D.
i := 1
i--
```

参考答案及解析：AD。知识点：自增自减操作。i++ 和 i-- 在 Go 语言中是语句，不是表达式，因此不能赋值给另外的变量。此外没有 ++i 和 --i。

3.关于GetPodAction定义，下面赋值正确的是

```go
type Fragment interface {
        Exec(transInfo *TransInfo) error
}
type GetPodAction struct {
}
func (g GetPodAction) Exec(transInfo *TransInfo) error {
        ...
        return nil
}
```

- A. var fragment Fragment = new(GetPodAction)
- B. var fragment Fragment = GetPodAction
- C. var fragment Fragment = &GetPodAction{}
- D. var fragment Fragment = GetPodAction{}

参考答案及解析：ACD。

<br/>

## Day 36. select, 函数声明，切片初始化

1.关于函数声明，下面语法正确的是？

- A. func f(a, b int) (value int, err error)
- B. func f(a int, b int) (value int, err error)
- C. func f(a, b int) (value int, error)
- D. func f(a int, b int) (int, int, error)

参考答案及解析：ABD。参考文章《[函数](http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&mid=2648466706&idx=4&sn=b296779ff31a98ecc978d2e513328443&chksm=f247437dc530ca6bf646850a498e19e5c7f331e0ef3e38909297da8724223422075d04cd21bf&scene=21#wechat_redirect)》

<br/>

2.关于整型切片的初始化，下面正确的是？

- A. s := make([]int)
- B. s := make([]int, 0)
- C. s := make([]int, 5, 10)
- D. s := []int{1, 2, 3, 4, 5}

参考答案及解析：BCD。参考文章《[非懂不可的Slice（一）](http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&mid=2648466739&idx=3&sn=9a1c9599172a532297ef41238450f9af&chksm=f247435cc530ca4ac6d92bd22011b52ae34d25d6e0eddf5b2ba85a15d3846b6674aa8bcf1d07&scene=21#wechat_redirect)》

<br/>

3.下面代码会触发异常吗？请说明。

```go
func main() {
    runtime.GOMAXPROCS(1)
    int_chan := make(chan int, 1)
    string_chan := make(chan string, 1)
    int_chan <- 1
    string_chan <- "hello"
    select {
    case value := <-int_chan:
        fmt.Println(value)
    case value := <-string_chan:
        panic(value)
    }
}
```

参考答案及解析：`select` 会随机选择一个可用通道做收发操作，所以可能触发异常，也可能不会。具体详看《[Go 并发 -- Select](http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&mid=2648466739&idx=1&sn=bfff10a9eed52a13fb2adb63569b0bca&chksm=f247435cc530ca4ac2eaad9c3879331ec5507f6452e901eb046f7ec46e703a678541e1fa1840&scene=21#wechat_redirect)》



<br/>

## Day 37. 函数返回值类型, channel, 常量

1.关于channel的特性，下面说法正确的是？

- A. 给一个 nil channel 发送数据，造成永远阻塞
- B. 从一个 nil channel 接收数据，造成永远阻塞
- C. 给一个已经关闭的 channel 发送数据，引起 panic
- D. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值

参考答案及解析：ABCD。

<br/>



2.下面代码有什么问题？

```go
const i = 100
var j = 123

func main() {
    fmt.Println(&j, j)
    fmt.Println(&i, i)
}
```

参考答案及解析：编译报错`cannot take the address of i`。知识点：常量。常量不同于变量的在运行期分配内存，常量通常会被编译器在预处理阶段直接展开，作为指令数据使用，所以常量无法寻址。

<br/>

3.下面代码能否编译通过？如果通过，输出什么？

```go
func GetValue(m map[int]string, id int) (string, bool) {

    if _, exist := m[id]; exist {
        return "exist", true
    }
    return nil, false
}
func main() {
    intmap := map[int]string{
        1: "a",
        2: "b",
        3: "c",
    }

    v, err := GetValue(intmap, 3)
    fmt.Println(v, err)
}
```

参考答案及解析：不能通过编译。知识点：函数返回值类型。nil 可以用作 interface、function、pointer、map、slice 和 channel 的“空值”。但是如果不特别指定的话，Go 语言不能识别类型，所以会报错:`cannot use nil as type string in return argument`.

<br/>

## Day 38. 异常

1.关于异常的触发，下面说法正确的是？

- A. 空指针解析；
- B. 下标越界；
- C. 除数为0；
- D. 调用panic函数；

参考答案及解析：ABCD。

<br>

2.下面代码输出什么？

```go
func main() {
    x := []string{"a", "b", "c"}
    for v := range x {
        fmt.Print(v)
    }
}
```

参考答案及解析：012。注意区别下面代码段：

```go
func main() {
    x := []string{"a", "b", "c"}
    for _, v := range x {
        fmt.Print(v)     //输出 abc
    }
}
```

<br>

3.下面这段代码能否编译通过？如果通过，输出什么？

```go
 type User struct{}
 type User1 User
 type User2 = User
 
 func (i User1) m1() {
     fmt.Println("m1")
 }
 func (i User) m2() {
     fmt.Println("m2")
}

func main() {
    var i1 User1
    var i2 User2
    i1.m1()
    i2.m2()
}
```

参考答案及解析：能，输出`m1 m2`，第 2 行代码基于类型 User 创建了新类型 User1，第 3 行代码是创建了 User 的类型别名 User2，注意使用 = 定义类型别名。因为 User2 是别名，完全等价于 User，所以 User2 具有 User 所有的方法。但是 i1.m1() 是不能执行的，因为 User1 没有定义该方法。

<br>

## Day 39. channel, go, interface

1.关于无缓冲和有冲突的channel，下面说法正确的是？

- A. 无缓冲的channel是默认的缓冲为1的channel；
- B. 无缓冲的channel和有缓冲的channel都是同步的；
- C. 无缓冲的channel和有缓冲的channel都是非同步的；
- D. 无缓冲的channel是同步的，而有缓冲的channel是非同步的；

参考答案及解析：D。参考文章《[Go 并发 -- 信道](http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&mid=2648466711&idx=1&sn=32b636a8cf9d23a8ed6f0b7c3fbcfc72&chksm=f2474378c530ca6e03c60d793d58283ba3047c645ae55e47c9791e88d7deaac63e1976f4d710&scene=21#wechat_redirect)》

<br>

2.下面代码是否能编译通过？如果通过，输出什么？

```go
 func Foo(x interface{}) {
     if x == nil {
         fmt.Println("empty interface")
         return
    }
     fmt.Println("non-empty interface")
 }
func main() {
    var x *int = nil
    Foo(x)
}
```

参考答案及解析：`non-empty interface` 考点：interface 的内部结构，我们知道接口除了有静态类型，还有动态类型和动态值，当且仅当动态值和动态类型都为 nil 时，接口类型值才为 nil。这里的 x 的动态类型是 `*int`，所以 x 不为 nil。

<br>

3.下面代码输出什么？

```go
func main() {
    ch := make(chan int, 100)
    // A
    go func() {              
        for i := 0; i < 10; i++ {
            ch <- i
       }
    }()
    // B
    go func() {
        for {
            a, ok := <-ch
            if !ok {
               fmt.Println("close")
                return
            }
            fmt.Println("a: ", a)
        }
    }()
    close(ch)
    fmt.Println("ok")
    time.Sleep(time.Second * 10)
}
```

参考答案及解析：程序抛异常。先定义下，第一个协程为 A 协程，第二个协程为 B 协程；当 A 协程还没起时，主协程已经将 channel 关闭了，当 A 协程往关闭的 channel 发送数据时会 panic，`panic: send on closed channel`。

<br>

## Day 40. select, channel

1.关于select机制，下面说法正确的是?

- A. select机制用来处理异步IO问题；
- B. select机制最大的一条限制就是每个case语句里必须是一个IO操作；
- C. golang在语言级别支持select关键字；
- D. select关键字的用法与switch语句非常类似，后面要带判断条件；

参考答案及解析：ABC。参考文章《[Go 并发 -- Select](http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&mid=2648466739&idx=1&sn=bfff10a9eed52a13fb2adb63569b0bca&chksm=f247435cc530ca4ac2eaad9c3879331ec5507f6452e901eb046f7ec46e703a678541e1fa1840&scene=21#wechat_redirect)》

<br>

2.下面的代码有什么问题？

```go
func Stop(stop <-chan bool) {
    close(stop)
}
```

参考答案及解析：有方向的 channel 不可以被关闭。

<br>

3.下面这段代码存在什么问题？

```go
type Param map[string]interface{}

type Show struct {
    *Param

}
func main() {
    s := new(Show)
    s.Param["day"] = 2
}
```

参考答案及解析：存在两个问题：1.map 需要初始化才能使用；2.指针不支持索引。修复代码如下：

```go
func main() {
    s := new(Show)
    // 修复代码
    p := make(Param)
    p["day"] = 2
    s.Param = &p
    tmp := *s.Param
    fmt.Println(tmp["day"])
}
```