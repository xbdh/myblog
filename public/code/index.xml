<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Codes | 细胞的核</title>
    <link>/code/</link>
      <atom:link href="/code/index.xml" rel="self" type="application/rss+xml" />
    <description>Codes</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Tue, 15 Sep 2020 21:50:27 +0800</lastBuildDate>
    <image>
      <url>/img/icon-192.png</url>
      <title>Codes</title>
      <link>/code/</link>
    </image>
    
    <item>
      <title>Leetcode</title>
      <link>/code/leetcode/</link>
      <pubDate>Tue, 15 Sep 2020 21:50:27 +0800</pubDate>
      <guid>/code/leetcode/</guid>
      <description>

&lt;h2 id=&#34;一-数组-链表-跳表&#34;&gt;一. 数组、链表、跳表&lt;/h2&gt;

&lt;h3 id=&#34;11-盛最多水的容器&#34;&gt;11. 盛最多水的容器&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;给你 n 个非负整数 a1，a2，&amp;hellip;，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;

&lt;p&gt;说明：你不能倾斜容器，且 n 的值至少为 2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/container-with-most-water/&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/container-with-most-water/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;输入：[1,8,6,2,5,4,8,3,7]
输出：49
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int maxArea(vector&amp;lt;int&amp;gt; &amp;amp;height) {
    int start = 0;
    int end = height.size() - 1;
    int maxArea = INT_MIN;

    while (start &amp;lt; end) {
        int temp = (end - start) * min(height[end], height[start]);
        maxArea = max(maxArea, temp);
        if (height[start] &amp;lt; height[end]) {
            start++;
        } else {
            end--
        }
    }
    return maxArea;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;283-移动零&#34;&gt;283. 移动零&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/move-zeroes/&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/move-zeroes/&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void moveZeroes(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    // 最后的非零值的索引
    int lastNonZeroFoundAt = 0;
    for (int  cur = 0; cur &amp;lt; nums.size(); cur++) {
        if (nums[cur] != 0) {
            swap(nums[lastNonZeroFoundAt++], nums[cur]);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;70-爬楼梯&#34;&gt;70. 爬楼梯&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/climbing-stairs/&#34; target=&#34;_blank&#34;&gt;https://leetcode-cn.com/problems/climbing-stairs/&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;/p&gt;

&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;

&lt;p&gt;注意：给定 n 是一个正整数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;example&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。

1.  1 阶 + 1 阶
2.  2 阶
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。

1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int climbStairs(int n) {
    if (n &amp;lt;= 2) {
        return n;

    }
    int i1 = 1;
    int i2 = 2;
    for (int i = 2; i &amp;lt; n; i++) {
        int temp = i1 + i2;
        i1 = i2;
        i2 = temp;
    }

    return i2;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Dynamic Programming-6 Longest Common Substring</title>
      <link>/code/dynamic-progamming/6-longest-common-substring/</link>
      <pubDate>Wed, 01 Jul 2020 16:36:22 +0800</pubDate>
      <guid>/code/dynamic-progamming/6-longest-common-substring/</guid>
      <description>

&lt;h2 id=&#34;1-longest-common-substring&#34;&gt;1. longest common substring&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求最长公共子串的长度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	s1=&amp;quot;abdca&amp;quot;, s2=&amp;quot;cbda&amp;quot;
    
ouput:	2
   
explanation: &amp;quot;bd&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	s1=&amp;quot;passport&amp;quot;, s2=&amp;quot;ppsspt&amp;quot;
    
ouput:	3
   
explanation: &amp;quot;ssp&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;brute-force&#34;&gt;brute-force&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int LCSRecursive(string &amp;amp;s1, string &amp;amp;s2, int s1CurrentIndex, int s2CurrentIndex, int count) {
    if (s1CurrentIndex &amp;gt;= s1.length() || s2CurrentIndex &amp;gt;= s2.length()) {
        return count;
    }

    if (s1[s1CurrentIndex] == s2[s2CurrentIndex]) {
        count =  LCSRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex + 1, count+1);
    }
    //count清零
    int c1 = LCSRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex, 0);
    int c2 = LCSRecursive(s1, s2, s1CurrentIndex, s2CurrentIndex + 1, 0);

    return max(count, max(c1, c2));
}


int LCS(string s1, string s2) {

    return LCSRecursive(s1, s2, 0, 0, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;3^(M+N)&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N+M&lt;/em&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int LCS2(string s1, string s2) {

    int len1 = s1.length();
    int len2 = s2.length();
    int maxlen = 0;
    for (int i = 0; i &amp;lt; len1; i++) {
        for (int j = 0; j &amp;lt; len2; j++) {
            int len = 0;
            while (i + len &amp;lt; len1 &amp;amp;&amp;amp; j + len &amp;lt; len2 &amp;amp;&amp;amp; s1[i + len] == s2[j + len]) {
                len++;//暴力匹配
            }
            if (len &amp;gt; maxlen) {
                maxlen = len;
            }
        }
    }
    return maxlen;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bottom-up&#34;&gt;bottom-up&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int LCSLength(string s1, string s2) {

    int len1 = s1.length();
    int len2 = s2.length();
    int maxLength = 0;

    //使用 d[i][j] 表示以 X[0,i-1]长度为i 与Y[0,j-1] 长度为j 最长公共子串的长度
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(len1 + 1, vector&amp;lt;int&amp;gt;(len2 + 1));
    for (int i = 0; i &amp;lt;= len1; i++) {
       //可不要
        dp[0][i] = 0;
        dp[i][0] = 0;
    }
    for (int i = 1; i &amp;lt;= len1; i++) {
        for (int j = 1; j &amp;lt;= len2; j++) {
            if (s1[i - 1] == s2[j - 1]) {
                dp[i][j] = 1 + dp[i - 1][j - 1];
                maxLength = max(maxLength, dp[i][j]);
            }
        }
    }
    return maxLength;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;M * N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * M&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-longest-common-subsequence&#34;&gt;2. longest common subsequence&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求最长公共子序列&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	s1=&amp;quot;abdca&amp;quot;, s2=&amp;quot;cbda&amp;quot;
    
ouput:	3
   
explanation: &amp;quot;bda&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	s1=&amp;quot;passport&amp;quot;, s2=&amp;quot;ppsspt&amp;quot;
    
ouput:	3
   
explanation: &amp;quot;ssp&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;brute-force-1&#34;&gt;brute-force&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int LCSRecursive(string &amp;amp;s1, string &amp;amp;s2, int s1CurrentIndex, int s2CurrentIndex) {
    if (s1CurrentIndex &amp;gt;= s1.length() || s2CurrentIndex &amp;gt;= s2.length()) {
        return 0;
    }

    if (s1[s1CurrentIndex] == s2[s2CurrentIndex]) {
        return 1 + LCSRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex + 1);
    }
    //count清零
    int c1 = LCSRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex);
    int c2 = LCSRecursive(s1, s2, s1CurrentIndex, s2CurrentIndex + 1);

    return max(c1, c2);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;2^(M+N)&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N+M&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;top-down&#34;&gt;top-down&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int LCS(string s1, string s2) {

    return LCSRecursive(s1, s2, 0, 0);
}

int LCSRecursive2(string &amp;amp;s1, string &amp;amp;s2, int s1CurrentIndex, int s2CurrentIndex, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;dp) {
    if (s1CurrentIndex &amp;gt;= s1.length() || s2CurrentIndex &amp;gt;= s2.length()) {
        return 0;
    }

    if (dp[s1CurrentIndex][s2CurrentIndex] == -1) {
        if (s1[s1CurrentIndex] == s2[s2CurrentIndex]) {
            dp[s1CurrentIndex][s2CurrentIndex] = 1 + LCSRecursive2(s1, s2, s1CurrentIndex + 1, s2CurrentIndex + 1, dp);
        } else {
            int c1 = LCSRecursive2(s1, s2, s1CurrentIndex + 1, s2CurrentIndex, dp);
            int c2 = LCSRecursive2(s1, s2, s1CurrentIndex, s2CurrentIndex + 1, dp);

            dp[s1CurrentIndex][s2CurrentIndex] = max(c1, c2);
        }
    }
    return dp[s1CurrentIndex][s2CurrentIndex];
}

int LCS2(string s1, string s2) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(s1.length(), vector&amp;lt;int&amp;gt;(s2.length(), -1));
    return LCSRecursive2(s1, s2, 0, 0, dp);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;M * N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * M&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;bottom-up-1&#34;&gt;bottom-up&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int LCS3(string s1, string s2) {
    int len1 = s1.length();
    int len2 = s2.length();
    int maxLength = 0;

    //使用 d[i][j] 表示以 X[0,i-1]长度为i 与Y[0,j-1] 长度为j 最长公共子序列的长度
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(len1 + 1, vector&amp;lt;int&amp;gt;(len2 + 1));
    for (int i = 0; i &amp;lt;= len1; i++) {
        //可不要
        dp[0][i] = 0;
        dp[i][0] = 0;
    }
    for (int i = 1; i &amp;lt;= len1; i++) {
        for (int j = 1; j &amp;lt;= len2; j++) {
            if (s1[i - 1] == s2[j - 1]) {
                dp[i][j] = 1 + dp[i - 1][j - 1];
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
            maxLength = max(maxLength, dp[i][j]);
        }
    }
    return maxLength;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;M * N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * M&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-minimum-deletions-or-insertions-to-transform-a-string-into-another&#34;&gt;3. minimum deletions or insertions to transform a string into another&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定字符串S1,S2,通过删除插入字符使得S1变成S2，求最小的删除插入数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	s1=&amp;quot;abc&amp;quot;,s2=&amp;quot;fbc&amp;quot;
    
output:	1 deletions ,1 insertions
   
explanation: s1:delete(a),insert(f) -&amp;gt;s2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	s1=&amp;quot;abdca&amp;quot;,s2=&amp;quot;cbda&amp;quot;
    
output:	2 deletions ,1 insertions
   
explanation: s1:delete(a,c),insert(c) -&amp;gt;s2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bottom-up-2&#34;&gt;bottom-up&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int LCS3(string s1, string s2) {
    int len1 = s1.length();
    int len2 = s2.length();
    int maxLength = 0;

    //使用 d[i][j] 表示以 X[0,i-1]长度为i 与Y[0,j-1] 长度为j 最长公共子序列的长度
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(len1 + 1, vector&amp;lt;int&amp;gt;(len2 + 1));
    for (int i = 0; i &amp;lt;= len1; i++) {
        //可不要
        dp[0][i] = 0;
        dp[i][0] = 0;
    }
    for (int i = 1; i &amp;lt;= len1; i++) {
        for (int j = 1; j &amp;lt;= len2; j++) {
            if (s1[i - 1] == s2[j - 1]) {
                dp[i][j] = 1 + dp[i - 1][j - 1];
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
            maxLength = max(maxLength, dp[i][j]);
        }
    }
    return maxLength;
}

pair&amp;lt;int, int&amp;gt; minDeleteInsert(string s1, string s2) {
    int len1 = s1.length();
    int len2 = s2.length();
    int c = LCS3(s1, s2);
    return make_pair(len1 - c, len2 - c);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;M * N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * M&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;4-longest-increasing-subsequence&#34;&gt;4. longest increasing subsequence&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求最长递增子序列的长度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[4, 2, 3, 6, 10, 1, 12]

output:	5
    
explanation:[2, 3, 6, 10, 12]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-4, 10, 3, 7, 15]

output:	4
    
explanation:[-4, 3, 7, 15]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;brute-force-2&#34;&gt;brute-force&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int LISLengthRecursive(vector&amp;lt;int&amp;gt; &amp;amp;nums, int currentIndex, int previousIndex) {
    if (currentIndex &amp;gt;= nums.size()) {
        return 0;
    }
    int c1 = 0;

    //大于先前元素，包含在内
    if (previousIndex == -1 || nums[currentIndex] &amp;gt; nums[previousIndex]) {
        c1 = 1 + LISLengthRecursive(nums, currentIndex + 1, currentIndex);
    }

    //不包含
    int c2 = LISLengthRecursive(nums, currentIndex + 1, previousIndex);

    return max(c1, c2);
}

int LIS(vector&amp;lt;int&amp;gt; nums) {
    return LISLengthRecursive(nums, 0, -1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;2^N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;top-down-1&#34;&gt;top-down&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int LISLengthRecursive2(vector&amp;lt;int&amp;gt; &amp;amp;nums, int currentIndex, int previousIndex, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;dp) {
    if (currentIndex &amp;gt;= nums.size()) {
        return 0;
    }
    //previousIndex的取值范围为[-1,n-1]转变为[0,n]
    if (dp[currentIndex][previousIndex + 1] == -1) {
        int c1 = 0;

        //大于先前元素，包含在内
        if (previousIndex == -1 || nums[currentIndex] &amp;gt; nums[previousIndex]) {
            c1 = 1 + LISLengthRecursive2(nums, currentIndex + 1, currentIndex, dp);
        }
        //不包含
        int c2 = LISLengthRecursive2(nums, currentIndex + 1, previousIndex, dp);

        dp[currentIndex][previousIndex + 1] = max(c1, c2);
    }
    return dp[currentIndex][previousIndex + 1];
}

int LIS2(vector&amp;lt;int&amp;gt; nums) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums.size(), vector&amp;lt;int&amp;gt;(nums.size() + 1, -1));
    return LISLengthRecursive2(nums, 0, -1, dp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N^2&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N^2&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;bottom-up-3&#34;&gt;bottom-up&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;./4-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int LIS3(vector&amp;lt;int&amp;gt; nums) {
    vector&amp;lt;int&amp;gt; dp(nums.size());
    dp[0] = 1;
    int maxLength = 1;
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        dp[i] = 1;
        for (int j = 0; j &amp;lt; i; j++) {
            if (nums[i] &amp;gt; nums[j] &amp;amp;&amp;amp; dp[i] &amp;lt;= dp[j]) {
                dp[i] = dp[j] + 1;
                maxLength = max(maxLength, dp[i]);
            }
        }
    }
    return maxLength;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N^2&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./4-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./4-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./4-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./4-5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./4-6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./4-7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;5-max-sum-increasing-subsequence&#34;&gt;5. max sum increasing subsequence&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求 和最大的递增子序列&lt;/p&gt;

&lt;p&gt;不同于题4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[4, 1, 2, 6, 10, 1, 12]

output:	32
    
explanation:sum[4, 6, 10, 12]=32
    LIS：sum[1,2,6,10,12]=31,两者和不同
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-4, 10, 3, 7, 15]

output:	25
    
explanation:sum[10, 15]=sum[3,7,5]=25
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;brute-force-3&#34;&gt;brute-force&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int maxSumISRecursive(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int currentIndex, int previousIndex, int sum) {
    if (currentIndex &amp;gt;= nums.size()) {
        return sum;
    }
    int s1 = sum;

    if (previousIndex == -1 || nums[currentIndex] &amp;gt; nums[previousIndex]) {
        s1 = maxSumISRecursive(nums, currentIndex + 1, currentIndex, sum + nums[currentIndex]);
    }

    int s2 = maxSumISRecursive(nums, currentIndex + 1, previousIndex, sum);

    return max(s1, s2);
}

int maxSumIS(const vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    return maxSumISRecursive(nums, 0, -1, 0);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;2^N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;top-down-2&#34;&gt;top-down&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;三维表或哈希表&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;bottom-up-4&#34;&gt;bottom-up&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;./5-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;
int maxSumIS2(const vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    vector&amp;lt;int&amp;gt; dp(nums.size());
    dp[0] = nums[0];

    int maxSum = nums[0];
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        dp[i] = nums[i];
        for (int j = 0; j &amp;lt; i; j++) {
            if (nums[i] &amp;gt; nums[j] &amp;amp;&amp;amp; dp[i] &amp;lt; nums[j] + dp[j]) {
                dp[i] = dp[j] + nums[i];
                maxSum = max(maxSum, dp[i]);
            }
        }
    }
    return maxSum;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N^2&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./5-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./5-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./5-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./5-5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;6-shortest-common-super-sequence&#34;&gt;6. shortest common super-sequence&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定字符串S1,S2,求最短的公共超级序列的长度，使得S1和S2都是其子序列&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	s1=&amp;quot;abcf&amp;quot; ,s2=&amp;quot;bdcf&amp;quot;
    
output:	5
    
explanation: &amp;quot;abdcf&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	s1=&amp;quot;dynamic&amp;quot;, s2=&amp;quot;programming&amp;quot;
    
output: 15
    
explanation: &amp;quot;dynprogramming&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;brute-force-4&#34;&gt;brute-force&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int SCSLengthRecursive(const string &amp;amp;s1, const string &amp;amp;s2, int s1CurrentIndex, int s2CurrentIndex) {
    if (s1CurrentIndex &amp;gt;= s1.length()) {
        return s2.length() - s2CurrentIndex;
    }
    if (s2CurrentIndex &amp;gt;= s2.length()) {
        return s1.length() - s1CurrentIndex;
    }

    if (s1[s1CurrentIndex] == s2[s2CurrentIndex]) {
        return 1 + SCSLengthRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex + 1);

    }
    int length1 = 1 + SCSLengthRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex);
    int length2 = 1 + SCSLengthRecursive(s1, s2, s1CurrentIndex, s2CurrentIndex + 1);

    return min(length1, length2);
}

int SCSLength(const string &amp;amp;s1, const string &amp;amp;s2) {
    return SCSLengthRecursive(s1, s2, 0, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;2^(M+N)&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N+M&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;top-down-3&#34;&gt;top-down&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int SCSLengthRecursive2(const string &amp;amp;s1, const string &amp;amp;s2, int s1CurrentIndex, int s2CurrentIndex,
                        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;dp) {
    if (s1CurrentIndex &amp;gt;= s1.length()) {
        return s2.length() - s2CurrentIndex;
    }
    if (s2CurrentIndex &amp;gt;= s2.length()) {
        return s1.length() - s1CurrentIndex;
    }

    if (dp[s1CurrentIndex][s2CurrentIndex] == -1) {
        if (s1[s1CurrentIndex] == s2[s2CurrentIndex]) {
            dp[s1CurrentIndex][s2CurrentIndex] = 1 + SCSLengthRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex + 1);

        }
        int length1 = 1 + SCSLengthRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex);
        int length2 = 1 + SCSLengthRecursive(s1, s2, s1CurrentIndex, s2CurrentIndex + 1);

        dp[s1CurrentIndex][s2CurrentIndex] = min(length1, length2);
    }
    return dp[s1CurrentIndex][s2CurrentIndex];
}

int SCSLength2(const string &amp;amp;s1, const string &amp;amp;s2) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(s1.length(), vector&amp;lt;int&amp;gt;(s2.length(), -1));
    return SCSLengthRecursive2(s1, s2, 0, 0, dp);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;M * N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * M&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;bottom-up-5&#34;&gt;bottom-up&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;./6-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int SCSLength3(const string &amp;amp;s1, const string &amp;amp;s2) {
    //长度
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(s1.length() + 1, vector&amp;lt;int&amp;gt;(s2.length() + 1));

    for (int i = 0; i &amp;lt;= s1.length(); i++) {
        dp[i][0] = i;
    }

    for (int j = 1; j &amp;lt;= s2.length(); j++) {
        dp[0][j] = j;
    }

    for (int i = 1; i &amp;lt;= s1.length(); i++) {
        for (int j = 1; j &amp;lt;= s2.length(); j++) {
            //长度为i，索引为i-1
            if (s1[i - 1] == s2[j - 1]) {
                dp[i][j] = 1 + dp[i - 1][j - 1];
            } else {
                dp[i][j] = min(1 + dp[i - 1][j], 1 + dp[i][j - 1]);
            }
        }
    }
    return dp[s1.length()][s2.length()];

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;M * N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * M&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./6-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./6-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./6-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./6-5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./6-6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./6-7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;7-minimum-deletions-to-make-a-sequence-sorted&#34;&gt;7. minimum deletions to make a sequence sorted&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定数字序列，删除一些数，使得剩下的增序，求最小的删除数&lt;/p&gt;

&lt;p&gt;同题4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[4, 2, 3, 6, 10, 1, 12]

output: 2
    
explanation: delete [4,1]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-4, 10, 3, 7, 15]

output: 1
    
explanation: delete [10]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, 2, 1, 0]

output: 3
    
explanation: 只剩下一个即可
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;brute-force-5&#34;&gt;brute-force&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int LIS(vector&amp;lt;int&amp;gt; nums) {
    vector&amp;lt;int&amp;gt; dp(nums.size());
    dp[0] = 1;
    int maxLength = 1;
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        dp[i] = 1;
        for (int j = 0; j &amp;lt; i; j++) {
            if (nums[i] &amp;gt; nums[j] &amp;amp;&amp;amp; dp[i] &amp;lt;= dp[j]) {
                dp[i] = dp[j] + 1;
                maxLength = max(maxLength, dp[i]);
            }
        }
    }
    return maxLength;
}

int minDelete(vector&amp;lt;int&amp;gt; &amp;amp;nums){
    return nums.size() - LIS(nums);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N^2&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;8-longest-repeating-subsequence&#34;&gt;8. longest repeating subsequence&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求最长重复子序列，此子序列出现超过两次，索引位置不重复&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;tomorrow&amp;quot;

output:	2
    
explanation: or,or
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;aabdbcec&amp;quot;
    
output:	3
 
explanation: abc, abc
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: &amp;quot;fmff&amp;quot;
    
output: 2
    
explanation: ff,ff,索引不重复
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;brute-force-6&#34;&gt;brute-force&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;int LRSRecursive(const string &amp;amp;s, int i1, int i2) {
    if (i1 &amp;gt;= s.length() || i2 &amp;gt;= s.length()) {
        return 0;
    }
    if (i1 != i2 &amp;amp;&amp;amp; s[i1] == s[i2]) {
        return 1 + LRSRecursive(s, i1 + 1, i2 + 1);
    }

    int c1 = LRSRecursive(s, i1 + 1, i2);
    int c2 = LRSRecursive(s, i1, i2 + 1);

    return max(c1, c2);
}

int LRSLength(const string &amp;amp;s) {
    return LRSRecursive(s, 0, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;2^N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;top-down-4&#34;&gt;top-down&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int LRSRecursive2(const string &amp;amp;s, int i1, int i2, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;dp) {
    if (i1 &amp;gt;= s.length() || i2 &amp;gt;= s.length()) {
        return 0;
    }
    if (dp[i1][i2] == -1) {
        if (i1 != i2 &amp;amp;&amp;amp; s[i1] == s[i2]) {
            dp[i1][i2] = 1 + LRSRecursive2(s, i1 + 1, i2 + 1, dp);
        } else {
            int c1 = LRSRecursive2(s, i1 + 1, i2, dp);
            int c2 = LRSRecursive2(s, i1, i2 + 1, dp);
            dp[i1][i2] = max(c1, c2);
        }
    }

    return dp[i1][i2];

}

int LRSLength2(const string &amp;amp;s) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(s.length(), vector&amp;lt;int&amp;gt;(s.length(), -1));
    return LRSRecursive2(s, 0, 0, dp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N^2&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N^2&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;bottom-up-6&#34;&gt;bottom-up&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int LRSLength3(const string &amp;amp;s) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(s.length() + 1, vector&amp;lt;int&amp;gt;(s.length() + 1));

    for (int i = 0; i &amp;lt;= s.length(); i++) {
        dp[i][0] = 0;
        dp[0][i] = 0;
    }
    int maxLen = 0;
    for (int i1 = 1; i1 &amp;lt;= s.length(); i1++) {
        for (int i2 = 1; i2 &amp;lt;= s.length(); i2++) {
            //长度为i，索引为i-1
            if (i1 != i2 &amp;amp;&amp;amp; s[i1 - 1] == s[i2 - 1]) {
                dp[i1][i2] = 1 + dp[i1 - 1][i2 - 1];
            } else {
                dp[i1][i2] = max(dp[i1 - 1][i2], dp[i1][i2 - 1]);
            }
            //没必要maxlen，就是右下角
            maxLen = max(maxLen, dp[i1][i2]);
        }
    }
    //return  dp[i1][i2] 
    return maxLen;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N^2&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N^2&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;9-subsequence-pattern-matching&#34;&gt;9. subsequence pattern matching&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定字符串S1，模式串S2，求S1中出现S2(作为序列)的次数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	s=&amp;quot;baxmx&amp;quot; p=&amp;quot;ax&amp;quot;
    
output:	2
    
explanation: bAXmx, bAxmX
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: s=&amp;quot;tomorrow&amp;quot; ,p=&amp;quot;tor&amp;quot;
    
output:4
    
explanation: TOmoRrow ,TomORrow,TOmorRow ,TomOrRow,
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;brute-force-7&#34;&gt;brute-force&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int countPatternMatchRecursive(const string &amp;amp;s, const string &amp;amp;p, int sCurrentIndex, int pCurrentIndex) {
    //模式串比完
    if (pCurrentIndex &amp;gt;= p.length()) {
        return 1;
    }

    if (sCurrentIndex &amp;gt;= s.length()) {
        return 0;
    }

    int c1 = 0;
    if (s[sCurrentIndex] == p[pCurrentIndex]) {
        c1 = countPatternMatchRecursive(s, p, sCurrentIndex + 1, pCurrentIndex + 1);
    }
    //只有s索引增加
    int c2 = countPatternMatchRecursive(s, p, sCurrentIndex + 1, pCurrentIndex);

    return c1 + c2;
}

int patternMatch(const string &amp;amp;s, const string &amp;amp;p) {
    return countPatternMatchRecursive(s, p, 0, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;2^N&lt;/em&gt; ) ,N为S的长度&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;top-down-5&#34;&gt;top-down&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;
int countPatternMatchRecursive2(const string &amp;amp;s, const string &amp;amp;p, int sCurrentIndex, int pCurrentIndex,
                                vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;dp) {
    //模式串比完
    if (pCurrentIndex &amp;gt;= p.length()) {
        return 1;
    }

    if (sCurrentIndex &amp;gt;= s.length()) {
        return 0;
    }


    if (dp[sCurrentIndex][pCurrentIndex] == -1) {
        int c1 = 0;
        if (s[sCurrentIndex] == p[pCurrentIndex]) {
            c1 = countPatternMatchRecursive2(s, p, sCurrentIndex + 1, pCurrentIndex + 1, dp);
        }
        //只有s索引增加
        int c2 = countPatternMatchRecursive2(s, p, sCurrentIndex + 1, pCurrentIndex, dp);

        dp[sCurrentIndex][pCurrentIndex] = c1 + c2;
    }
    return dp[sCurrentIndex][pCurrentIndex];
}

int patternMatch2(const string &amp;amp;s, const string &amp;amp;p) {
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; dp(s.length(), vector&amp;lt;int&amp;gt;(p.length(), -1));
    return countPatternMatchRecursive2(s, p, 0, 0, dp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bottom-up-7&#34;&gt;bottom-up&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;./9-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int patternMatch3(const string &amp;amp;s, const string &amp;amp;p) {
    vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; dp(s.length() + 1, vector&amp;lt;int&amp;gt;(p.length() + 1));

    //模式串为0，有一个
    for (int i = 0; i &amp;lt;= s.length(); i++) {
        dp[i][0] = 1;
    }
    //第一行为0

    for (int i = 1; i &amp;lt;= s.length(); i++) {
        for (int j = 1; j &amp;lt;= p.length(); j++) {

            if (s[i - 1] == p[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[s.length()][p.length()];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;M * N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * M&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;10-longest-bitonic-subsequence&#34;&gt;10. longest bitonic subsequence&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求最长的双调子序列的长度&lt;/p&gt;

&lt;p&gt;双调：先单调递增，再单调递减&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [4, 2, 3, 6, 10, 1, 12]

output:	5
    
explanation: [2, 3, 6, 10, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [4, 2, 5, 9, 7, 6, 10, 3, 1]

output:	7
    
explanation: [4, 5, 9, 7, 6, 3, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;brute-force-8&#34;&gt;brute-force&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//从currentIndex到end最长递减序列
int LISLengthRecursive(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int currentIndex, int previousIndex) {
    if (currentIndex &amp;gt;= nums.size()) {
        return 0;
    }
    int c1 = 0;

    //大于先前元素，包含在内
    if (previousIndex == -1 || nums[currentIndex] &amp;lt; nums[previousIndex]) {
        c1 = 1 + LISLengthRecursive(nums, currentIndex + 1, currentIndex);
    }

    //不包含
    int c2 = LISLengthRecursive(nums, currentIndex + 1, previousIndex);

    return max(c1, c2);
}

//从currentIndex到start最长递减序列
int LISLengthRecursiveReverse(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int currentIndex, int previousIndex) {
    if (currentIndex &amp;lt; 0) {
        return 0;
    }
    int c1 = 0;

    //大于先前元素，包含在内
    if (previousIndex == -1 || nums[currentIndex] &amp;lt; nums[previousIndex]) {
        c1 = 1 + LISLengthRecursiveReverse(nums, currentIndex - 1, currentIndex);
    }

    //不包含
    int c2 = LISLengthRecursiveReverse(nums, currentIndex - 1, previousIndex);

    return max(c1, c2);
}

int LBSLength(const vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    int maxLen = 0;

    for (int i = 0; i &amp;lt; nums.size(); i++) {
        int length1 = LISLengthRecursive(nums, i, -1);
        int length2 = LISLengthRecursiveReverse(nums, i, -1);
        maxLen = max(maxLen, length1 + length2 - 1);
    }

    return maxLen;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;2^N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;bottom-up-8&#34;&gt;bottom-up&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;有误，待看
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N^2&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;11-longest-alternating-subsequence&#34;&gt;11. longest alternating subsequence&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求最长交替子序列的长度&lt;/p&gt;

&lt;p&gt;模式：a&amp;gt; b &lt;c  ,a&lt; b &gt;c&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 2 ,3 , 4]

output: 2
    
explanation: [1,2] [3,4],[1,3],[1,4]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [3, 2, 1, 4]

output: 3
    
explanation: [3, 2, 4] [2,1,4]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 3, 2, 4]

output: 4
    
explanation: [1, 3, 2, 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;待看&#34;&gt;待看&lt;/h3&gt;

&lt;h2 id=&#34;12-edit-distance&#34;&gt;12. edit distance&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定字符串S1,S2,通过删除,插入,替换字符使得S1变成S2，求最小的操作数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: s1=&amp;quot;bat&amp;quot;,s2=&amp;quot;but&amp;quot;
    
output: 1
    
explanation : replace a-&amp;gt;u
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: s1=&amp;quot;abdca&amp;quot;,s2=&amp;quot;cbda&amp;quot;
    
output: 2
    
explanation : replace a-&amp;gt;c,delete second c
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: s1=&amp;quot;passpot&amp;quot;,s2=&amp;quot;ppsspqrt&amp;quot;
    
output: 3
    
explanation : replace a-&amp;gt;p,o-&amp;gt;q,insert r
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;brute-force-9&#34;&gt;brute-force&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int minOperationRecursive(const string &amp;amp;s1, const string &amp;amp;s2, int s1CurrentIndex, int s2CurrentIndex) {
    if (s1CurrentIndex &amp;gt;= s1.length()) {
        return s2.length() - s2CurrentIndex;
    }
    if (s2CurrentIndex &amp;gt;= s2.length()) {
        return s1.length() - s1CurrentIndex;
    }

    if (s1[s1CurrentIndex] == s2[s2CurrentIndex]) {
        return minOperationRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex + 1);

    }

    //分别为删除，插入，取代
    int length1 = 1 + minOperationRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex);
    int length2 = 1 + minOperationRecursive(s1, s2, s1CurrentIndex, s2CurrentIndex + 1);
    int length3 = 1 + minOperationRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex + 1);
    return min(length1, min(length2, length3));
}

int minOperation(const string &amp;amp;s1, const string &amp;amp;s2) {
    return minOperationRecursive(s1, s2, 0, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;3^(N+M)&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N+M&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;top-down-6&#34;&gt;top-down&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;
int minOperationRecursive2(const string &amp;amp;s1, const string &amp;amp;s2, int s1CurrentIndex, int s2CurrentIndex,
                           vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp) {
    if (s1CurrentIndex &amp;gt;= s1.length()) {
        return s2.length() - s2CurrentIndex;
    }
    if (s2CurrentIndex &amp;gt;= s2.length()) {
        return s1.length() - s1CurrentIndex;
    }

    if (dp[s1CurrentIndex][s2CurrentIndex] == -1) {
        if (s1[s1CurrentIndex] == s2[s2CurrentIndex]) {
            dp[s1CurrentIndex][s2CurrentIndex] = minOperationRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex + 1);

        } else {
            int length1 = 1 + minOperationRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex);
            int length2 = 1 + minOperationRecursive(s1, s2, s1CurrentIndex, s2CurrentIndex + 1);
            int length3 = 1 + minOperationRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex + 1);
            dp[s1CurrentIndex][s2CurrentIndex] = min(length1, min(length2, length3));
        }

    }
    return dp[s1CurrentIndex][s2CurrentIndex];
}

int minOperation(const string &amp;amp;s1, const string &amp;amp;s2) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(s1.length(), vector&amp;lt;int&amp;gt;(s2.length(), -1));
    return minOperationRecursive2(s1, s2, 0, 0, dp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * M&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * M&lt;/em&gt; )&lt;/p&gt;

&lt;h3 id=&#34;bottom-up-9&#34;&gt;bottom-up&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;./12-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int minOperation(const string &amp;amp;s1, const string &amp;amp;s2) {
    //长度
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(s1.length() + 1, vector&amp;lt;int&amp;gt;(s2.length() + 1));

    for (int i = 0; i &amp;lt;= s1.length(); i++) {
        dp[i][0] = i;
    }

    for (int j = 1; j &amp;lt;= s2.length(); j++) {
        dp[0][j] = j;
    }

    for (int i = 1; i &amp;lt;= s1.length(); i++) {
        for (int j = 1; j &amp;lt;= s2.length(); j++) {
            //长度为i，索引为i-1
            if (s1[i - 1] == s2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = min(1 + dp[i - 1][j], min(1 + dp[i][j - 1], 1 + dp[i - 1][j - 1]));
            }
        }
    }
    return dp[s1.length()][s2.length()];

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * M&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * M&lt;/em&gt; )&lt;/p&gt;

&lt;h2 id=&#34;13-strings-interleaving&#34;&gt;13. strings interleaving&lt;/h2&gt;

&lt;h3 id=&#34;待看待看&#34;&gt;待看待看&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>Dynamic Programming-5 Palindromic Subsequence</title>
      <link>/code/dynamic-progamming/5-palindromic-subsequence/</link>
      <pubDate>Wed, 01 Jul 2020 16:35:47 +0800</pubDate>
      <guid>/code/dynamic-progamming/5-palindromic-subsequence/</guid>
      <description>

&lt;h2 id=&#34;1-longest-palindromic-subsequence&#34;&gt;1. longest Palindromic Subsequence&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求最长回文子序列(不连续)的长度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;bbbab&amp;quot;
    
output:	4
    
explanation: &amp;quot;bbbb&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;cbbd&amp;quot;
    
output:	2
    
explanation: &amp;quot;bb&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;brute-force&#34;&gt;Brute-force&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int longestPalindromicSubsequenceRecursive(const string &amp;amp;s, int startIndex, int endIndex) {
    if (startIndex &amp;gt; endIndex) {
        return 0;
    }
    //只有一个字符
    if (startIndex == endIndex) {
        return 1;
    }

    if (s[startIndex] == s[endIndex]) {
        return 2 + longestPalindromicSubsequenceRecursive(s, startIndex + 1, endIndex - 1);

    }
    //从头或尾跳过一个字符

    int c1 = longestPalindromicSubsequenceRecursive(s, startIndex + 1, endIndex);
    int c2 = longestPalindromicSubsequenceRecursive(s, startIndex, endIndex - 1);
    return max(c1, c2);
}

int LPS(string s) {
    return longestPalindromicSubsequenceRecursive(s, 0, s.size() - 1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;2^N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;top-down&#34;&gt;Top-down&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int LPSRecursive2(const string &amp;amp;s, int startIndex, int endIndex, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp) {
    if (startIndex &amp;gt; endIndex) {
        return 0;
    }
    //只有一个字符
    if (startIndex == endIndex) {
        return 1;
    }

    if (dp[startIndex][endIndex] == -1) {
        if (s[startIndex] == s[endIndex]) {
            dp[startIndex][endIndex] = 2 + LPSRecursive2(s, startIndex + 1, endIndex - 1, dp);
        } else {
            //从头或尾跳过一个字符
            int c1 = LPSRecursive2(s, startIndex + 1, endIndex, dp);
            int c2 = LPSRecursive2(s, startIndex, endIndex - 1, dp);
            dp[startIndex][endIndex] = max(c1, c2);
        }

    }

    return dp[startIndex][endIndex];
}

int LPS2(string s) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(s.length(), vector&amp;lt;int&amp;gt;(s.length(), -1));
    return LPSRecursive2(s, 0, s.size() - 1, dp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N ^ 2&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N ^ 2&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;bottom-up&#34;&gt;bottom-up&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int LPS3(string s) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(s.length(), vector&amp;lt;int&amp;gt;(s.length()));
    for (int i = 0; i &amp;lt; s.length(); i++) {
        dp[i][i] = 1;
    }
    //dp[i][j]表示[i,j]区间内的字符串的最长回文子序列,上三角有效
    //从下往上，从做往右处理。
    for (int startIndex = s.length() - 1; startIndex &amp;gt;= 0; startIndex--) {
        for (int endIndex = startIndex + 1; endIndex &amp;lt; s.length(); endIndex++) {
            if (s[startIndex] == s[endIndex]) {
                dp[startIndex][endIndex] = 2 + dp[startIndex + 1][endIndex - 1];
            } else {
                dp[startIndex][endIndex] = max(dp[startIndex + 1][endIndex], dp[startIndex][endIndex - 1]);
            }
        }
    }

    return dp[0][s.length() - 1];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N ^ 2&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N ^ 2&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;bottom-up-优化&#34;&gt;bottom-up 优化&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int lps(string s)
{
    int n = s.length();

    // dp[i] is going to store length of longest 
    // palindromic subsequence of substring s[0..i] 
    int dp[n];

    // Pick starting point 
    for (int i = n - 1; i &amp;gt;= 0; i--) {

        int back_up = 0;
        
        // Pick ending points and see if s[i] 
        // increases length of longest common 
        // subsequence ending with s[j]. 
        for (int j = i; j &amp;lt; n; j++) {

            // similar to 2D array L[i][j] == 1 
            // i.e., handling substrings of length 
            // one. 
            if (j == i)
                dp[j] = 1;

                // Similar to 2D array L[i][j] = L[i+1][j-1]+2 
                // i.e., handling case when corner characters 
                // are same.  
            else if (s[i] == s[j]){

                // value a[j] is depend upon previous  
                // unupdated value of a[j-1] but in  
                // previous loop value of a[j-1] is  
                // changed. To store the unupdated  
                // value of a[j-1] back_up variable  
                // is used. 
                int temp = dp[j];
                dp[j] = back_up + 2;
                back_up = temp;
            }else{
                // similar to 2D array L[i][j] = max(L[i][j-1], 
                // a[i+1][j]) 
                back_up = dp[j];
                dp[j] = max(dp[j - 1], dp[j]);
            }
        }
    }
    return dp[n - 1];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N ^ 2&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;2-longest-palindromic-substring&#34;&gt;2.  longest Palindromic Substring&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求最长回文串&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;abdbca&amp;quot;
    
output:	bdb
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;abbc&amp;quot;
    
output:	bb
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;abc&amp;quot;
    
output:	a
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;brute-force-1&#34;&gt;Brute-force&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;string LPS(string s) {
    int len = s.length();
    int maxLen = 1;//任意字符都是回文
    int startIndex = 0;

    for (int i = 0; i &amp;lt; len; i++) {
        for (int j = i + 1; j &amp;lt; len; j++) {
            int low = i;
            int high = j;

            while (low &amp;lt; high &amp;amp;&amp;amp; s[low] == s[high]) {
                low++;
                high--;
            }
            //&amp;quot;abbc&amp;quot;模式，跳出循环low&amp;gt;high
            //&amp;quot;abbtbbc&amp;quot;模式，跳出循环low=high
            //j - i + 1 &amp;gt; maxLen,判断长度是否大于1
            if (low &amp;gt;= high &amp;amp;&amp;amp; j - i + 1 &amp;gt; maxLen) {
                maxLen = j - i + 1;
                startIndex = i;
            }
        }
    }
    return s.substr(startIndex, maxLen);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N^3&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;1&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;bottom-up-1&#34;&gt;Bottom-up&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;./2-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;string LPS2(string s) {
    int len = s.length();
    int maxLen = 1;
    int startIndex = 0;
    //dp[i][j]代表[i,j]位置的字符串是否回文

    //当 i == j，dp[i][j] 是回文子串（单字符都是回文子串）；
    //当 j - i &amp;lt; 3，只要 S[i] == S[j]，则 dp[i][j] 是回文子串（如&amp;quot;aa&amp;quot;，“aba”），否则不是；
    //当 j - i &amp;gt;= 3，如果 S[i] == S[j] &amp;amp;&amp;amp; dp[i+1][j-1] ，则 dp[i][j] 是回文子串，否则不是 。
    vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; dp(len, vector&amp;lt;bool&amp;gt;(len, false));

	//for循环顺序变化，左侧列-&amp;gt;右侧列，每列从上到下
    //dp[i + 1][j - 1]在dp[i][j]的前一列，下一行，已经生成
    for (int j = 0; j &amp;lt; len; j++) {
        for (int i = 0; i &amp;lt;= j; i++) {
            //小于3也行
            if (j - i &amp;lt; 2) {
                dp[i][j] = (s[i] == s[j]);
            } else {
                dp[i][j] = (s[i] == s[j] &amp;amp;&amp;amp; dp[i + 1][j - 1]);
            }

            if (dp[i][j] &amp;amp;&amp;amp; j - i + 1 &amp;gt; maxLen) {
                maxLen = j - i + 1;
                startIndex = i;
            }
        }
    }
//    //另一种解法
//    for (int i = 0;i &amp;lt; len; i++) {
//    		dp[i][i] = true;
//    }
//    for (int i = len - 1; i &amp;gt;= 0; i--) {
//        //可以放在外面赋值
//        for (int j = i; j &amp;lt; len; j++) {
//            //小于3也行
//            if (j - i &amp;lt; 2) {
//                dp[i][j] = (s[i] == s[j]);
//            } else {
//                //要访问dp[i+1][j-1]，i从大到小，j从小到大
//                dp[i][j] = (s[i] == s[j] &amp;amp;&amp;amp; dp[i + 1][j - 1]);
//            }
//
//            if (dp[i][j] &amp;amp;&amp;amp; j - i + 1 &amp;gt; maxLen) {
//                maxLen = j - i + 1;
//                startIndex = i;
//            }
//        }
//    }
    return s.substr(startIndex, maxLen);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N^2&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N^2&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;3-count-of-palindromic-substring&#34;&gt;3. count of Palindromic Substring&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求最长回文串的个数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;abdbca&amp;quot;
    
output:	7
    
explanation :&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;, &amp;quot;d&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;bdb&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bottom-up-2&#34;&gt;Bottom-up&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int countLPS(string s) {
    int count = 0;
    int len = s.length();
    vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; dp(len, vector&amp;lt;bool&amp;gt;(len));
    for (int j = 0; j &amp;lt; len; j++) {
        for (int i = 0; i &amp;lt;= j; i++) {
            //小于3也行
            if (j - i &amp;lt; 3) {
                dp[i][j] = (s[i] == s[j]);
            } else {
                dp[i][j] = (s[i] == s[j] &amp;amp;&amp;amp; dp[i + 1][j - 1]);
            }

            if (dp[i][j]) {
                count++;
            }
        }
    }
    return count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N^2&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N^2&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;4-minimum-deletions-in-a-string-to-make-it-a-palindrome&#34;&gt;4. minimum deletions in a string to make it a palindrome&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;删除字符串的一些字符，使得其成为回文字符串，求最小的删除数&lt;/p&gt;

&lt;p&gt;=len(s) - len(longest Palindromic Subsequence),字符串长度减去最长回文序列长度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;abdbca&amp;quot;
    
output:	1
    
explanation: remove &amp;quot;c&amp;quot; -&amp;gt; &amp;quot;abdba&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;cddpd&amp;quot;
    
output:	2
    
explanation: remove &amp;quot;c&amp;quot;,&amp;quot;p&amp;quot; -&amp;gt; &amp;quot;ddd&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bottom-up-3&#34;&gt;Bottom-up&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int LPS3(string s) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(s.length(), vector&amp;lt;int&amp;gt;(s.length()));
    for (int i = 0; i &amp;lt; s.length(); i++) {
        dp[i][i] = 1;
    }
    //dp[i][j]表示[i,j]区间内的字符串的最长回文子序列,上三角有效
    //从下往上，从左往右处理。
    //startIndex从大变小，endIndex从小变大
    for (int startIndex = s.length() - 1; startIndex &amp;gt;= 0; startIndex--) {
        for (int endIndex = startIndex + 1; endIndex &amp;lt; s.length(); endIndex++) {
            if (s[startIndex] == s[endIndex]) {
                dp[startIndex][endIndex] = 2 + dp[startIndex + 1][endIndex - 1];
            } else {
                dp[startIndex][endIndex] = max(dp[startIndex + 1][endIndex], dp[startIndex][endIndex - 1]);
            }
        }
    }


    return dp[0][s.length() - 1];
}

int countRemove(string s) {
    return s.length() - LPS3(s);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N^2&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N^2&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;相似问题&#34;&gt;相似问题&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;插入一些字符，使得字符串成为回文字符串，求最小的插入数&lt;/p&gt;

&lt;p&gt;同上&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;5-palindromic-partitioning&#34;&gt;5. palindromic partitioning&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定字符串，分割成子串，使得子串都是回文字符串，求最小切割几刀&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;abdbca&amp;quot;
    
output:	3
    
explanation: &amp;quot;a&amp;quot;,&amp;quot;bdb&amp;quot;,&amp;quot;c&amp;quot;,&amp;quot;a&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;pqr&amp;quot;
    
output:	3
    
explanation: &amp;quot;p&amp;quot;,&amp;quot;q&amp;quot;,&amp;quot;r&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;pp&amp;quot;
    
output:	0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;brute-force-2&#34;&gt;Brute-force&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool isPalindrome(string s, int start, int end) {
    while (start &amp;lt; end) {
        if (s[start] == s[end]) {
            start++;
            end--;
        } else {
            return false;
        }
    }
    return true;
}

int minCutRecursive(string s, int startIndex, int endIndex) {
    if (startIndex &amp;gt;= endIndex || isPalindrome(s, startIndex, endIndex)) {
        return 0;
    }

    //[startIndex,endIndex],的最大切值
    int minCuts = endIndex - startIndex;

    for (int i = startIndex; i &amp;lt;= endIndex; i++) {
        if (isPalindrome(s, startIndex, i)) {
            minCuts = min(minCuts, 1 + minCutRecursive(s, i + 1, endIndex));
        }
    }
    return minCuts;
}

int minCutLPS(string s) {
    return minCutRecursive(s, 0, s.length() - 1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;2^N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;bottom-up-4&#34;&gt;Bottom-up&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;待看
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Dynamic Programming-4 Fibonacci Numbers</title>
      <link>/code/dynamic-progamming/4-fibonacci-numbers/</link>
      <pubDate>Wed, 01 Jul 2020 16:35:01 +0800</pubDate>
      <guid>/code/dynamic-progamming/4-fibonacci-numbers/</guid>
      <description>

&lt;h2 id=&#34;1-fibonacci-numbers&#34;&gt;1. fibonacci numbers&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;斐波那契数列&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;brute-force&#34;&gt;Brute-force&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int fib(int n) {
    if (n &amp;lt; 2) {
        return n;
    }

    return fib(n - 1) + fib(n - 2);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;2^N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;top-down&#34;&gt;Top-down&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;
int fibRecursive(vector&amp;lt;int&amp;gt; &amp;amp;memoize, int n) {
    if (n &amp;lt; 2) return n;

    if (memoize[n] == -1) {
        memoize[n] = fibRecursive(memoize, n - 1) + fibRecursive(memoize, n - 2);
        return memoize[n];
    }

    return memoize[n];
}

int fib2(int n) {
    vector&amp;lt;int&amp;gt; memoize(n + 1, -1);
    return fibRecursive(memoize, n );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;bottom-up&#34;&gt;Bottom-up&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int fib3(int n) {
    if (n == 0) return 0;
    vector&amp;lt;int&amp;gt; dp(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i &amp;lt;= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[n];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;2-staircase&#34;&gt;2. staircase&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;n阶台阶，每次只允许走1步、2步或3步，求有多少种方式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;intput:	n=3
    
output:	4
    
explanation:{1,1,1},{1,2},{2,1},{3}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;intput:	n=4
    
output:	7
    
explanation:{1,1,1,1},{1,2,1},{2,1,1},{1,1,2},{3,1},{1,3},{2,2}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;brute-force-1&#34;&gt;Brute-force&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int staircase(int n) {
    //可以往后推到n=3,结果：4
    if (n == 0) {
        return 1;
    }
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 2;
    }
    return staircase(n - 1) + staircase(n - 2) + staircase(n - 3);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;3^N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;top-down-1&#34;&gt;Top-down&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int staircaseRecursive2(vector&amp;lt;int&amp;gt; &amp;amp;dp, int n) {
    if (n == 0) {
        return 1;
    }
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 2;
    }
    if (dp[n] == -1) {
        dp[n] = staircaseRecursive2(dp, n - 1) + staircaseRecursive2(dp, n - 2) + staircaseRecursive2(dp, n - 3);;
        return dp[n];
    }

    return dp[n];
}

int staircase2(int n) {
    vector&amp;lt;int&amp;gt; dp(n + 1, -1);
    return staircaseRecursive2(dp, n);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;bottom-up-1&#34;&gt;Bottom-up&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int staircase3(int n) {
    vector&amp;lt;int&amp;gt; dp(n + 1);
    dp[0] = 1;
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i &amp;lt;= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
    }

    return dp[n];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;3-number-factor&#34;&gt;3. number factor&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定n,求有多少方式使得n等于{1,3,4}的和&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;intput:	n=4
    
output:	4
    
explanation:{1,1,1,1},{1,3},{4},{3,1}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;intput:	n=5
    
output:	6
    
explanation:{1,1,1,1,1},{1,1,3},{4,1},{1,4},{1,3,1},{3,1,1}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;brute-force-2&#34;&gt;Brute-force&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int fib(int n) {
    if (n == 0) {
        return 1;
    }
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 1;
    }
    if (n == 3) {
        return 2;
    }
    return fib(n - 1) + fib(n - 3) + fib(n - 4);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;3^N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;top-down-2&#34;&gt;Top-down&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;
int fibRecursive(vector&amp;lt;int&amp;gt; &amp;amp;dp, int n) {
    if (n == 0) {
        return 1;
    }
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 1;
    }
    if (n == 3) {
        return 2;
    }
    if (dp[n] == -1) {
        dp[n] = fibRecursive(dp, n - 1) + fibRecursive(dp, n - 3) + fibRecursive(dp, n - 4);
        return dp[n];
    }

    return dp[n];
}

int fib2(int n) {
    vector&amp;lt;int&amp;gt; dp(n + 1, -1);
    return fibRecursive(dp, n);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;bottom-up-2&#34;&gt;Bottom-up&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;./3-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int fib3(int n) {
    vector&amp;lt;int&amp;gt; dp(n + 1);
    dp[0] = 1;
    dp[1] = 1;
    dp[2] = 1;
    dp[3] = 2;
    for (int i = 4; i &amp;lt;= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 3] + dp[i - 4];
    }

    return dp[n];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;4-minimum-jumps-to-reach-the-end&#34;&gt;4. minimum jumps to reach the end&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定一组整数（&amp;gt;=0）,每个数代表可以往右跳的最大步数，求最小跳几次到达数组最后&lt;/p&gt;

&lt;p&gt;元素为0时，不能跳&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2, 1, 1, 1, 4]

output:	3
    
explanation:0-index(2) -&amp;gt; 2-index(1) -&amp;gt; 3-index(1) -&amp;gt; 4-index
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[ 1,1, 3, 6, 9, 3, 0, 1, 3]

output:	4
    
explanation:0-index(1) -&amp;gt; 1-index(1) -&amp;gt; 2-index(1) -&amp;gt; 3-index(6)-&amp;gt;8-index
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;brute-force-3&#34;&gt;Brute-force&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int countMinJumpsRecursive(const vector&amp;lt;int&amp;gt; &amp;amp;jumps, int currentIndex) {
    if (currentIndex == jumps.size() - 1) {
        return 0;
    }

    if (jumps[currentIndex] == 0) {
        return INT_MAX;
    }

    int totalJumps = INT_MAX;
    int start = currentIndex + 1;
    int end = currentIndex + jumps[currentIndex];

    while (start &amp;lt; jumps.size() &amp;amp;&amp;amp; start &amp;lt;= end) {
        int minJumps = countMinJumpsRecursive(jumps, start);
        start++;
        if (minJumps != INT_MAX) {
            totalJumps = min(totalJumps, minJumps + 1);
        }
    }
    return totalJumps;
}

int countJumps(const vector&amp;lt;int&amp;gt; &amp;amp;jumps) {
    return countMinJumpsRecursive(jumps, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;2^N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;top-down-3&#34;&gt;Top-down&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int countMinJumpsRecursive2(const vector&amp;lt;int&amp;gt; &amp;amp;jumps, int currentIndex, vector&amp;lt;int&amp;gt; &amp;amp;dp) {
    if (currentIndex == jumps.size() - 1) {
        return 0;
    }

    if (jumps[currentIndex] == 0) {
        return INT_MAX;
    }

    if (dp[currentIndex] == INT_MAX) {
        int totalJumps = INT_MAX;
        int start = currentIndex + 1;
        int end = currentIndex + jumps[currentIndex];

        while (start &amp;lt; jumps.size() &amp;amp;&amp;amp; start &amp;lt;= end) {
            int minJumps = countMinJumpsRecursive2(jumps, start, dp);
            start++;
            if (minJumps != INT_MAX) {
                totalJumps = min(totalJumps, minJumps + 1);
            }
        }
        dp[currentIndex] = totalJumps;
    }

    return dp[currentIndex];
}

int countJumps2(const vector&amp;lt;int&amp;gt; &amp;amp;jumps) {
    vector&amp;lt;int&amp;gt; dp(jumps.size(), INT_MAX);
    return countMinJumpsRecursive2(jumps, 0, dp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N^2&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;bottom-up-3&#34;&gt;Bottom-up&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;./4-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//dp[currenIndex]代表以当前位置为起点到达终点的最小跳
int countJumps3(const vector&amp;lt;int&amp;gt; &amp;amp;jumps) {
    vector&amp;lt;int&amp;gt; dp(jumps.size());

    //除了jumps[0]都为INT_MAX
    for (int i = 1; i &amp;lt; jumps.size(); i++) {
        dp[i] = INT_MAX;
    }

    for (int start = 0; start &amp;lt; jumps.size() - 1; start++) {
        for (int end = start + 1; end &amp;lt;= start + jumps[start] &amp;amp;&amp;amp; end &amp;lt; jumps.size(); end++) {
            //dp[start]到达 其能达到 的范围内的跳数  等于dp[start]+1
            //比较这俩值
            dp[end] = min(dp[end], dp[start] + 1);
        }
    }

    return dp[jumps.size() - 1];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N^2&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;5-minimum-jumps-with-fee&#34;&gt;5. minimum jumps with fee&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定N，代表n步台阶，N个元素的数组代表上某一台阶的花费，你每次可以走1,2,3步，求最小花费到达终点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;input:	n=6, fee:[1,2,5,2,1,2]

output:	3
    
explanation:0-index(1)-&amp;gt;3-index(2)-&amp;gt;top ,1+2=3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	n=4, fee:[2,3,4,5]

output:	5
    
explanation:0-index(2)-&amp;gt;1-index(3)-&amp;gt;top ,2+3=5
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;brute-force-4&#34;&gt;Brute-force&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int minFeeRecursive(const vector&amp;lt;int&amp;gt; &amp;amp;fees, int currentIndex) {
    if (currentIndex &amp;gt;= fees.size()) {
        return 0;
    }

    int partFee1 = minFeeRecursive(fees, currentIndex + 1);
    int partFee2 = minFeeRecursive(fees, currentIndex + 2);
    int partFee3 = minFeeRecursive(fees, currentIndex + 3);

    return min(partFee1, min(partFee2, partFee3))+ fees[currentIndex];
}

int minFee(const vector&amp;lt;int&amp;gt; &amp;amp;fees) {
    return minFeeRecursive(fees, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;3^N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;top-down-4&#34;&gt;Top-down&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int minFeeRecursive2(const vector&amp;lt;int&amp;gt; &amp;amp;fees, int currentIndex, vector&amp;lt;int&amp;gt; dp) {
    if (currentIndex &amp;gt;= fees.size()) {
        return 0;
    }

    if (dp[currentIndex] == -1) {
        int partFee1 = minFeeRecursive2(fees, currentIndex + 1, dp);
        int partFee2 = minFeeRecursive2(fees, currentIndex + 2, dp);
        int partFee3 = minFeeRecursive2(fees, currentIndex + 3, dp);

        dp[currentIndex] = min(partFee1, min(partFee2, partFee3)) + fees[currentIndex];
    }

    return dp[currentIndex];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;bottom-up-4&#34;&gt;Bottom-up&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int minFee3(const vector&amp;lt;int&amp;gt; &amp;amp;fees) {
    //dp[n]代表，n阶台阶时，最小费用
    vector&amp;lt;int&amp;gt; dp(fees.size() + 1);

    //n=0,时不需要，n=1或2时，只需fees[0]
    dp[0] = 0;
    dp[1] = fees[0];
    dp[2] = fees[0];

    //i,i-1,i-2阶台阶可直接到i+1阶台阶
    for (int i = 2; i &amp;lt; fees.size(); i++) {
        dp[i + 1] = min(fees[i] + dp[i], min(fees[i - 1] + dp[i - 1], fees[i - 2] + dp[i - 2]));
    }
    return dp[fees.size()];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;6-house-thief&#34;&gt;6. house thief&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;小偷偷房子，n元数组代表n个房子的财富，小偷不能偷连续2个房子，求能偷到的最大财富&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2,5,1,3,6,2,4]

output:	15
    
expalanation:5 + 6 + 4 = 15
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2, 10, 14, 8, 1]

output:	18
    
expalanation:10 + 8 = 18
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;brute-force-5&#34;&gt;Brute-force&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int maxWealthRecursive(const vector&amp;lt;int&amp;gt; &amp;amp;wealth, int currentIndex) {
    if (currentIndex &amp;gt;= wealth.size()) {
        return 0;
    }

    int part1wealth = maxWealthRecursive(wealth, currentIndex + 2) + wealth[currentIndex];
    int part2wealth = maxWealthRecursive(wealth, currentIndex + 1);

    return max(part1wealth, part2wealth);
}

int maxWealth(const vector&amp;lt;int&amp;gt; &amp;amp;wealth) {
    return maxWealthRecursive(wealth, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;2^N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;top-down-5&#34;&gt;Top-down&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int maxWealthRecursive2(const vector&amp;lt;int&amp;gt; &amp;amp;wealth, int currentIndex, vector&amp;lt;int&amp;gt; dp) {
    if (currentIndex &amp;gt;= wealth.size()) {
        return 0;
    }

    if (dp[currentIndex] == -1) {
        int part1wealth = maxWealthRecursive2(wealth, currentIndex + 2, dp) + wealth[currentIndex];
        int part2wealth = maxWealthRecursive2(wealth, currentIndex + 1, dp);
        dp[currentIndex] = max(part1wealth, part2wealth);
    }

    return dp[currentIndex];
}

int maxWealth2(const vector&amp;lt;int&amp;gt; &amp;amp;wealth) {
    vector&amp;lt;int&amp;gt; dp(wealth.size() + 1, -1);
    return maxWealthRecursive2(wealth, 0, dp);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;bottom-up-5&#34;&gt;Bottom-up&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int maxWealth3(const vector&amp;lt;int&amp;gt; &amp;amp;wealth) {
    //dp[n],当物品为n时最大财富
    vector&amp;lt;int&amp;gt; dp(wealth.size() + 1);
    dp[0] = 0;
    dp[1] = wealth[0];
//    dp[2]=max(wealth[0],wealth[1]);
    for (int i = 1; i &amp;lt; wealth.size(); i++) {
        //dp[i]:不偷；
        //dp[i-1]+wealth[i]:偷 i-1个物品最大值，加上第i+1个物品的价值
        dp[i + 1] = max(dp[i], dp[i - 1] + wealth[i]);
    }
    return dp[wealth.size()];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dynamic Programming-3 Unbounded Knapsack</title>
      <link>/code/dynamic-progamming/3-unbounded-knapsack/</link>
      <pubDate>Wed, 01 Jul 2020 16:34:12 +0800</pubDate>
      <guid>/code/dynamic-progamming/3-unbounded-knapsack/</guid>
      <description>

&lt;h2 id=&#34;1-unbounded-knapsack&#34;&gt;1. unbounded knapsack&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定N个物品的价值和重量，一个容量为C的背包。每个物品不限次数且总容量不能超过C，求最大价值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	weights=[1, 2, 3]
    	profits=[15, 20, 50]
    	C=5
    
output:	80
  
explanations:	2*15+50=80
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	weights=[1, 3, 4, 5]
    	profits=[15, 50, 60, 90]
    	C=8
    
output:	140
  
explanations:	50+90=140
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;brute-force&#34;&gt;Brute-force&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int knapsackRecursive(const vector&amp;lt;int&amp;gt; &amp;amp;weight, const vector&amp;lt;int&amp;gt; &amp;amp;profits, int capacity, int currentIndex) {
    if (capacity &amp;lt;= 0 || currentIndex &amp;gt;= weight.size() || weight.size() != profits.size()) {
        return 0;
    }

    int profit1 = 0;
    //选中之后，currentIndex不增加
    if (weight[currentIndex] &amp;lt;= capacity) {
        profit1 = profits[currentIndex] +
                  knapsackRecursive(weight, profits, capacity - weight[currentIndex], currentIndex );
    }

    int profit2 = knapsackRecursive(weight, profits, capacity, currentIndex + 1);

    return max(profit1, profit2);
}

int knapsack(const vector&amp;lt;int&amp;gt; &amp;amp;weight, const vector&amp;lt;int&amp;gt; &amp;amp;profits, int capacity) {
    return knapsackRecursive(weight, profits, capacity, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;2^(N+C)&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N + C&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;top-down&#34;&gt;Top-down&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int knapsackRecursive2(const vector&amp;lt;int&amp;gt; &amp;amp;weight, const vector&amp;lt;int&amp;gt; &amp;amp;profits, int capacity, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;dp,
                      int currentIndex) {
    if (capacity &amp;lt;= 0 || currentIndex &amp;gt;= weight.size()) {
        return 0;
    }

    if (dp[currentIndex][capacity] != -1) {
        return dp[currentIndex][capacity];
    }


    int profit1 = 0;

    if (weight[currentIndex] &amp;lt;= capacity) {
        profit1 = profits[currentIndex] +
                  knapsackRecursive2(weight, profits, capacity - weight[currentIndex], dp, currentIndex );
    }

    int profit2 = knapsackRecursive2(weight, profits, capacity, dp, currentIndex + 1);
    dp[currentIndex][capacity] = max(profit1, profit2);

    return dp[currentIndex][capacity];
}

int knapsack2(const vector&amp;lt;int&amp;gt; &amp;amp;weight, const vector&amp;lt;int&amp;gt; &amp;amp;profits, int capacity) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(weight.size(), vector&amp;lt;int&amp;gt;(capacity + 1, -1));
    return knapsackRecursive2(weight, profits, capacity, dp, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N + C&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N + C&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;bottom-up&#34;&gt;Bottom-up&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;./1-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int knapsack3(const vector&amp;lt;int&amp;gt; &amp;amp;weight, const vector&amp;lt;int&amp;gt; &amp;amp;profits, int capacity) {
    if (capacity &amp;lt;= 0 || profits.empty() || profits.size() != weight.size()) {
        return 0;
    }

    int n = profits.size();
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(n, vector&amp;lt;int&amp;gt;(capacity + 1));

    for (int i = 0; i &amp;lt; n; i++) {
        dp[i][0] = 0;
    }
    //如果第一个物品小于物品重量，放置,可以重复拿
    for (int j = 0; j &amp;lt;= capacity; j++) {
        if (weight[0] &amp;lt;= j) {
            dp[0][j] = profits[0]+dp[0][j-weight[0]];
        }
    }

    for (int i = 1; i &amp;lt; n; i++) {
        for (int c = 1; c &amp;lt;= capacity; c++) {
            int profit1 = 0, profit2 = 0;

            if (weight[i] &amp;lt;= c) {
                profit1 = profits[i] + dp[i][c - weight[i]];
            }
            profit2 = dp[i - 1][c];

            dp[i][c] = max(profit1, profit2);
        }
    }

    return dp[n - 1][capacity];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N + C&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N + C&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-9.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-10.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-11.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-12.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-13.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;selected-item&#34;&gt;selected item&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//有选中的项目，有具体选了几次
void printSelectElements(const vector&amp;lt;int&amp;gt; &amp;amp;weight, const vector&amp;lt;int&amp;gt; &amp;amp;profits, int capacity, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;dp) {
    int n = weight.size();
    int totalProfit = dp[n - 1][capacity];
    cout &amp;lt;&amp;lt; &amp;quot;--------&amp;quot;&amp;lt;&amp;lt;endl;
    //不能等于0，会越界
    
    //选中，下一次同行
    //未选中，上一行
    int row=n-1;
    while(row&amp;gt;0){
        if (totalProfit != dp[row - 1][capacity]) {

            cout &amp;lt;&amp;lt; weight[row] &amp;lt;&amp;lt; &amp;quot;  &amp;quot;;
            cout &amp;lt;&amp;lt; &amp;quot;index=&amp;quot; &amp;lt;&amp;lt; row &amp;lt;&amp;lt; &amp;quot; &amp;quot;&amp;lt;&amp;lt;endl;
            capacity -= weight[row];
            totalProfit -= profits[row];
        }else{
            row--;
        }
    }

    //判断第一个元素是否被选中,这个时候跳出来循环，第一个元素不止选了一次
    while(totalProfit != 0) {
        cout &amp;lt;&amp;lt; weight[0]&amp;lt;&amp;lt;&amp;quot;  &amp;quot;;
        totalProfit-=profits[0];
        cout &amp;lt;&amp;lt; &amp;quot;index=&amp;quot; &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &amp;quot;  &amp;quot;&amp;lt;&amp;lt;endl;
    }
    cout &amp;lt;&amp;lt; &amp;quot;--------&amp;quot;&amp;lt;&amp;lt;endl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./1-14.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-rod-cutting&#34;&gt;2. rod cutting&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定长度为N的杆，切成小段，不同长度有不同的价格，求最大收益&lt;/p&gt;

&lt;p&gt;同上题1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	lengths= [1, 2, 3, 4, 5]
    	prices= [2, 6, 7, 10, 13]
        N=5
    
output:	14
    
explanations:2*(length=2)+1*(length=1)=14
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bottom-up-1&#34;&gt;Bottom-up&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;./2-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int knapsack(const vector&amp;lt;int&amp;gt; &amp;amp;lengths, const vector&amp;lt;int&amp;gt; &amp;amp;prices, int rodLength) {
    if (rodLength &amp;lt;= 0 || prices.empty() || prices.size() != lengths.size()) {
        return 0;
    }

    int n = prices.size();
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(n, vector&amp;lt;int&amp;gt;(rodLength + 1));

    for (int i = 0; i &amp;lt; n; i++) {
        dp[i][0] = 0;
    }
    //如果第一个物品小于物品重量，放置,可以重复拿
    for (int j = 0; j &amp;lt;= rodLength; j++) {
        if (lengths[0] &amp;lt;= j) {
            dp[0][j] = prices[0]+dp[0][j-lengths[0]];
        }
    }

    for (int i = 1; i &amp;lt; n; i++) {
        for (int r = 1; r &amp;lt;= rodLength; r++) {
            int profit1 = 0, profit2 = 0;

            if (lengths[i] &amp;lt;= r) {
                profit1 = prices[i] + dp[i][r - lengths[i]];
            }
            profit2 = dp[i - 1][r];

            dp[i][r] = max(profit1, profit2);
        }
    }

    return dp[n - 1][rodLength];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N + C&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N + C&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-9.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-10.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-11.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;selected-item-1&#34;&gt;selected item&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;./2-12.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-coin-change&#34;&gt;3. coin change&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;无限量不同面值的零钱和要换的钱N，求有多少种换钱的方式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 2, 3] , amount=5
  
output:	5
    
explanation:{1,1,1,1,1},{1,1,1,2},{1,2,2},{1,1,3},{2,3}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;brute-force-1&#34;&gt;Brute-force&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int coinChangeRecursive(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int total, int currentIndex) {
    //空集为一种
    if (total == 0) {
        return 1;
    }
    if (currentIndex &amp;gt;= nums.size()) {
        return 0;
    }

    int part1 = 0, part2 = 0;
    if (nums[currentIndex] &amp;lt;= total) {
        part1 = coinChangeRecursive(nums, total - nums[currentIndex], currentIndex);
    }
    part2 = coinChangeRecursive(nums, total, currentIndex + 1);

    return part1 + part2;
}

int coinChange(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int total) {
    if (nums.empty()) {
        return 0;
    }
    return coinChangeRecursive(nums, total, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;2^(N+T)&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N + T&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;top-down-1&#34;&gt;Top-down&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int coinChangeRecursive2(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int total, int currentIndex, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp) {
    if (total == 0) {
        return 1;
    }
    if (currentIndex &amp;gt;= nums.size()) {
        return 0;
    }

    if (dp[currentIndex][total] == -1) {
        int part1 = 0, part2 = 0;
        if (nums[currentIndex] &amp;lt;= total) {
            part1 = coinChangeRecursive2(nums, total - nums[currentIndex], currentIndex, dp);
        }
        part2 = coinChangeRecursive2(nums, total, currentIndex + 1, dp);
        dp[currentIndex][total] = part1 + part2;
    }


    return dp[currentIndex][total];
}

int coinChange2(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int total) {
    if (nums.empty()) {
        return 0;
    }
    int n = nums.size();
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(n, vector&amp;lt;int&amp;gt;(total + 1, -1));
    return coinChangeRecursive2(nums, total, 0, dp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * T&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * T&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;bottom-up-2&#34;&gt;Bottom-up&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;./3-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int coinChange3(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int total) {
    if (nums.empty()) {
        return 0;
    }
    int n = nums.size();
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(n, vector&amp;lt;int&amp;gt;(total + 1));

    //第一列，空集算一种
    for (int i = 0; i &amp;lt; n; i++) {
        dp[i][0] = 1;
    }

    //只有nums[0]一个元素,当t整除nums[0]时，一种
    for (int t = 1; t &amp;lt;= total; t++) {
        dp[0][t] = (t % nums[0] == 0 ? 1 : 0);
    }

    for (int i = 1; i &amp;lt; n; i++) {
        for (int t = 1; t &amp;lt;= total; t++) {
            dp[i][t] = dp[i - 1][t];
            if (nums[i] &amp;lt;= t) {
                dp[i][t] = dp[i][t] + dp[i][t - nums[i]];
            }
        }
    }

    return dp[n - 1][total];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * T&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * T&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./3-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./3-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./3-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./3-5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./3-6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./3-7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-minimum-coin-change&#34;&gt;4. minimum coin change&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;无限量不同面值的硬币和要换的总钱N，求硬币总数最小值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 2, 3] , amount=5
  
output:	2
    
explanation:{2,3}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 2, 3] , amount=11
  
output:	4
    
explanation:{2,3,3,3}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;brute-force-2&#34;&gt;Brute-force&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int countCoinChangeRecursive(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int total, int currentIndex) {
    if (total == 0) {
        return 0;
    }
    if (currentIndex &amp;gt;= nums.size()) {
        return -1;
    }

    int count1 = INT_MAX;
    if (nums[currentIndex] &amp;lt;= total) {
        if (INT_MAX != countCoinChangeRecursive(nums, total - nums[currentIndex], currentIndex)) {
            count1 = 1 + countCoinChangeRecursive(nums, total - nums[currentIndex], currentIndex);
        }
    }
    int count2 = countCoinChangeRecursive(nums, total, currentIndex + 1);

    return min(count1, count2);
}

int countCoinChange(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int total) {
    if (nums.empty()) {
        return INT_MAX;
    }
    int result = countCoinChangeRecursive(nums, total, 0);
    return result == INT_MAX ? -1 : result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;2^(N+T)&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N + T&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;top-down-2&#34;&gt;Top-down&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int countCoinChangeRecursive2(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int total, int currentIndex, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp) {
    if (total == 0) {
        return 0;
    }
    if (currentIndex &amp;gt;= nums.size()) {
        return INT_MAX;
    }

    if (dp[currentIndex][total] != INT_MAX) {
        int count1 = INT_MAX;
        if (nums[currentIndex] &amp;lt;= total) {
            if (INT_MAX != countCoinChangeRecursive2(nums, total - nums[currentIndex], currentIndex, dp)) {
                count1 = 1 + countCoinChangeRecursive2(nums, total - nums[currentIndex], currentIndex, dp);
            }
        }
        int count2 = countCoinChangeRecursive2(nums, total, currentIndex + 1, dp);
        dp[currentIndex][total] = min(count1, count2);
    }


    return dp[currentIndex][total];
}

int countCoinChange2(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int total) {
    if (nums.empty()) {
        return -1;
    }

    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums.size(), vector&amp;lt;int&amp;gt;(total + 1, INT_MAX));
    int result = countCoinChangeRecursive(nums, total, 0);
    return result == INT_MAX ? -1 : result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * T&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * T&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;bottom-up-3&#34;&gt;Bottom-up&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;./4-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int countCoinChange3(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int total) {
    if (nums.empty()) {
        return -1;
    }
    if (total == 0) {
        return 0;
    }
    int n = nums.size();
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(n, vector&amp;lt;int&amp;gt;(total + 1));

    for (int i = 0; i &amp;lt; n; i++) {
        dp[i][0] = 0;
    }
    //只有nums[0]时，最小个数为t/nums[0];
    for (int t = 1; t &amp;lt;= total; t++) {
        dp[0][t] = (t % nums[0] == 0 ? t / nums[0] : INT_MAX);
    }

    for (int i = 1; i &amp;lt; n; i++) {
        for (int t = 1; t &amp;lt;= total; t++) {
            dp[i][t] = dp[i - 1][t];
            //选中
            if (nums[i] &amp;lt;= t) {
                if (dp[i][t - nums[i]] != INT_MAX) {
                    dp[i][t] = min(dp[i - 1][t], 1 + dp[i][t - nums[i]]);
                }
            }

        }
    }

    return (dp[n - 1][total] == INT_MAX) ? -1 : dp[n - 1][total];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * T&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * T&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./4-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./4-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./4-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./4-5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./4-6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./4-7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./4-8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;5-maximum-ribbon-cut&#34;&gt;5. maximum ribbon cut&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;相当于：无限量不同面值的硬币和要换的总钱N，求硬币总数最大值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2,3,5] ,total=5
    
output:	2
    
explanation: {2,3}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2,3] ,total=7
    
output:	3
    
explanation: {2,2,3}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, 5,7] ,total=13
    
output:	3
    
explanation: {3,3,7}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;brute-force-3&#34;&gt;Brute-force&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int countCoinChangeRecursive(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int total, int currentIndex) {
    if (total == 0) {
        return 0;
    }
    if (currentIndex &amp;gt;= nums.size()) {
        return INT_MIN;
    }

    int count1 = INT_MIN;
    if (nums[currentIndex] &amp;lt;= total) {
        if (INT_MIN != countCoinChangeRecursive(nums, total - nums[currentIndex], currentIndex)) {
            count1 = 1 + countCoinChangeRecursive(nums, total - nums[currentIndex], currentIndex);
        }
    }
    int count2 = countCoinChangeRecursive(nums, total, currentIndex + 1);

    return max(count1, count2);
}

int countCoinChange(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int total) {
    if (nums.empty()) {
        return -1;
    }

    int result = countCoinChangeRecursive(nums, total, 0);
    return result == INT_MIN ? -1 : result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;2^(N+T)&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N + T&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;bottom-up-4&#34;&gt;Bottom-up&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;./5-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int countCoinChange3(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int total) {
    if (nums.empty()) {
        return -1;
    }
    if (total == 0) {
        return 0;
    }
    int n = nums.size();
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(n, vector&amp;lt;int&amp;gt;(total + 1));

    for (int i = 0; i &amp;lt; n; i++) {
        dp[i][0] = 0;
    }
    //只有nums[0]时，最小个数为t/nums[0];
    for (int t = 1; t &amp;lt;= total; t++) {
        dp[0][t] = (t % nums[0] == 0 ? t / nums[0] : INT_MIN);
    }

    for (int i = 1; i &amp;lt; n; i++) {
        for (int t = 1; t &amp;lt;= total; t++) {
            dp[i][t] = dp[i - 1][t];
            //选中
            if (nums[i] &amp;lt;= t) {
                if (dp[i][t - nums[i]] != INT_MIN) {
                    dp[i][t] = max(dp[i - 1][t], 1 + dp[i][t - nums[i]]);
                }
            }

        }
    }

    return (dp[n - 1][total] == INT_MIN) ? -1 : dp[n - 1][total];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * T&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * T&lt;/em&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dynamic Programming-2 0-1 Knapsack</title>
      <link>/code/dynamic-progamming/2-0-1-knapsack/</link>
      <pubDate>Wed, 01 Jul 2020 16:33:38 +0800</pubDate>
      <guid>/code/dynamic-progamming/2-0-1-knapsack/</guid>
      <description>

&lt;h2 id=&#34;1-0-1-knapsack&#34;&gt;1、0-1 Knapsack&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定N个物品的价值和重量，一个容量为C的背包。每个物品只能挑选一次且总容量不能超过C，求最大价值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	weights=[2, 3, 1, 4]
    	profits=[4, 5, 3, 7]
    	C=5
    
output:	10  
  
explanations:	1+4=5,3+7=10
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;暴力法&#34;&gt;暴力法&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;./1-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int knapsackRecursive(const vector&amp;lt;int&amp;gt; &amp;amp;weight, const vector&amp;lt;int&amp;gt; &amp;amp;profits, int capacity, int currentIndex) {
    if (capacity &amp;lt;= 0 || currentIndex &amp;gt;= weight.size() || weight.size() != profits.size()) {
        return 0;
    }

    int profit1 = 0;

    if (weight[currentIndex] &amp;lt;= capacity) {
        profit1 = profits[currentIndex] +
                  knapsackRecursive(weight, profits, capacity - weight[currentIndex], currentIndex + 1);
    }

    int profit2 = knapsackRecursive(weight, profits, capacity, currentIndex + 1);

    return max(profit1, profit2);
}

int knapsack(const vector&amp;lt;int&amp;gt; &amp;amp;weight, const vector&amp;lt;int&amp;gt; &amp;amp;profits, int capacity) {
    return knapsackRecursive(weight, profits, capacity, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;2^N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;自顶向下&#34;&gt;自顶向下&lt;/h3&gt;

&lt;p&gt;有重复&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int knapsackRecursive(const vector&amp;lt;int&amp;gt; &amp;amp;weight, const vector&amp;lt;int&amp;gt; &amp;amp;profits, int capacity, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;dp,
                       int currentIndex) {
    if (capacity &amp;lt;= 0 || currentIndex &amp;gt;= weight.size()) {
        return 0;
    }

    if (dp[currentIndex][capacity] != -1) {
        return dp[currentIndex][capacity];
    }

    int profit1 = 0;

    if (weight[currentIndex] &amp;lt;= capacity) {
        profit1 = profits[currentIndex] +
                  knapsackRecursive(weight, profits, capacity - weight[currentIndex], dp, currentIndex + 1);
    }

    int profit2 = knapsackRecursive(weight, profits, capacity, dp, currentIndex + 1);
    dp[currentIndex][capacity] = max(profit1, profit2);

    return dp[currentIndex][capacity];
}

int knapsack(const vector&amp;lt;int&amp;gt; &amp;amp;weight, const vector&amp;lt;int&amp;gt; &amp;amp;profits, int capacity) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(weight.size(), vector&amp;lt;int&amp;gt;(capacity + 1, -1));
    return knapsackRecursive(weight, profits, capacity, dp, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * C&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * C&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;自底向上&#34;&gt;自底向上&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;./1-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-8.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-9.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-10.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-11.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-12.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-13.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-14.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-15.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int knapsack3(const vector&amp;lt;int&amp;gt; &amp;amp;weight, const vector&amp;lt;int&amp;gt; &amp;amp;profits, int capacity) {
    if (capacity &amp;lt;= 0 || profits.empty() || profits.size() != weight.size()) {
        return 0;
    }

    int n = profits.size();
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(n, vector&amp;lt;int&amp;gt;(capacity + 1));

    for (int i = 0; i &amp;lt; n; i++) {
        dp[i][0] = 0;
    }

    //如果第一个物品小于物品重量，放置
    for (int j = 0; j &amp;lt;= capacity; j++) {
        if (weight[0] &amp;lt;= j) {
            dp[0][j] = profits[0];
        }
    }

    //之后的物品
    for (int i = 1; i &amp;lt; n; i++) {
        for (int j = 1; j &amp;lt;= capacity; j++) {
            int profit1 = 0, profit2 = 0;

            if (weight[i] &amp;lt;= j) {
                profit1 = profits[i] + dp[i - 1][j - weight[i]];
            }
            profit2 = dp[i - 1][j];
            dp[i][j] = max(profit1, profit2);
        }
    }
	
    return dp[n - 1][capacity];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * C&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * C&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;输出选择的物品：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当某个物品不选择时，dp的值来源于正上方，且相等。若不相等，则此物品被选中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./1-16.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void printSelectElements(const vector&amp;lt;int&amp;gt; &amp;amp;weight, const vector&amp;lt;int&amp;gt; &amp;amp;profits, int capacity, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;dp) {
    int n = weight.size();
    int totalProfit = dp[n - 1][capacity];
    cout &amp;lt;&amp;lt; &amp;quot;--------&amp;quot;;
    //不能等于0，会越界
    for (int i = n - 1; i &amp;gt; 0; i--) {
        //最值与正上方比较,选中
        if (totalProfit != dp[i - 1][capacity]) {

            cout &amp;lt;&amp;lt; weight[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            cout &amp;lt;&amp;lt; &amp;quot;index=&amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            capacity -= weight[i];
            totalProfit -= profits[i];
        }
    }
    //判断第一个元素是否被选中
    if (totalProfit != 0) {
        cout &amp;lt;&amp;lt; weight[0];
        cout &amp;lt;&amp;lt; &amp;quot;index=&amp;quot; &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
    }
    cout &amp;lt;&amp;lt; &amp;quot;--------&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;优化一：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int knapsack4(const vector&amp;lt;int&amp;gt; &amp;amp;weight, const vector&amp;lt;int&amp;gt; &amp;amp;profits, int capacity) {
    if (capacity &amp;lt;= 0 || profits.empty() || profits.size() != weight.size()) {
        return 0;
    }

    int n = profits.size();
    //当前dp的值，只与上一行有关，两行就行，覆盖即可，
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(2, vector&amp;lt;int&amp;gt;(capacity + 1));


    //如果第一个物品小于物品重量，放置
    for (int j = 0; j &amp;lt;= capacity; j++) {
        if (weight[0] &amp;lt;= j) {
            dp[0][j] = dp[1][j] = profits[0];
        }
    }

    //之后的物品
    for (int i = 1; i &amp;lt; n; i++) {
        for (int j = 1; j &amp;lt;= capacity; j++) {
            int profit1 = 0, profit2 = 0;

            if (weight[i] &amp;lt;= j) {
                profit1 = profits[i] + dp[(i - 1) % 2][j - weight[i]];
            }
            profit2 = dp[(i - 1) % 2][j];
            dp[i % 2][j] = max(profit1, profit2);
        }
    }
    return dp[(n - 1) % 2][capacity];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * C&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;C&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;优化二：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int knapsack5(const vector&amp;lt;int&amp;gt; &amp;amp;weight, const vector&amp;lt;int&amp;gt; &amp;amp;profits, int capacity) {
    if (capacity &amp;lt;= 0 || profits.empty() || profits.size() != weight.size()) {
        return 0;
    }

    int n = profits.size();
    vector&amp;lt;int&amp;gt; dp(capacity + 1);


    //如果第一个物品小于物品重量，放置
    for (int j = 0; j &amp;lt;= capacity; j++) {
        if (weight[0] &amp;lt;= j) {
            dp[j] = profits[0];
        }
    }

    //之后的物品
    for (int i = 1; i &amp;lt; n; i++) {
        //顺序改变防止覆盖
        for (int j = capacity; j &amp;gt;= 0; j--) {
            int profit1 = 0, profit2 = 0;

            if (weight[i] &amp;lt;= j) {
                profit1 = profits[i] + dp[j - weight[i]];
            }
            profit2 = dp[j];
            dp[j] = max(profit1, profit2);
        }
    }
    return dp[capacity];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * C&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;C&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;2-equal-subsets-sum-partition&#34;&gt;2、equal subsets sum partition&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定正整数数组，是否存在一种分法将数组分为不相交的两部分，使得他们的和相等&lt;/p&gt;

&lt;p&gt;即求是否存在子数组使得其和为数组和的一半&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;暴力法-1&#34;&gt;暴力法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool partitionRecursive(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int sum, int currentIndex) {
    if (sum == 0) {
        return true;
    }

    if (currentIndex &amp;gt;= nums.size()) {
        return false;
    }
    if (nums[currentIndex] &amp;lt;= sum) {
        if (partitionRecursive(nums, sum - nums[currentIndex], currentIndex + 1)) {
            return true;
        }
    }
    return partitionRecursive(nums, sum, currentIndex + 1);
}

bool equalSubset(const vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    if (nums.empty()) {
        return false;
    }
    
    int sum = 0;
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        sum += nums[i];
    }

    if (sum % 2 != 0) {
        return false;
    }

    return partitionRecursive(nums, sum / 2, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(2^&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;自顶向下-1&#34;&gt;自顶向下&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool partitionRecursive2(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int sum, int currentIndex, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;dp) {
    if (sum == 0) {
        return true;
    }

    if (currentIndex &amp;gt;= nums.size()) {
        return false;
    }

    if (dp[currentIndex][sum] == -1) {
        if (nums[currentIndex] &amp;lt;= sum) {
            if (partitionRecursive(nums, sum - nums[currentIndex], currentIndex + 1)) {
                dp[currentIndex][sum] = 1;
                return true;
            }
        }
        dp[currentIndex][sum] = partitionRecursive(nums, sum, currentIndex + 1) ? 1 : 0;
    }

    return dp[currentIndex][sum] == 1 ? true : false;
}

bool equalSubset2(const vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    if (nums.empty()) {
        return false;
    }

    int sum = 0;
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        sum += nums[i];
    }

    if (sum % 2 != 0) {
        return false;
    }

    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums.size(), vector&amp;lt;int&amp;gt;(sum / 2 + 1, -1));
    return partitionRecursive2(nums, sum / 2, 0, dp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * S&lt;/em&gt;) ，S为数组和&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * S&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;自底向上-1&#34;&gt;自底向上&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool equalSubset3(const vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    if (nums.empty()) {
        return false;
    }

    int sum = 0;
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        sum += nums[i];
    }

    if (sum % 2 != 0) {
        return false;
    }
    int halfSum = sum / 2;

    vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; dp(nums.size(), vector&amp;lt;bool&amp;gt;(halfSum + 1));

    //第一列
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        dp[i][0] = true;
    }

    //第一行：第二个到最后一个
    //此行非常重要，值不一定相同，视情况而定
    //当处理nums[0]时，如果其值等于s,表明数组其余的元素和也是s
    for (int s = 1; s &amp;lt;= halfSum; s++) {
        //dp[0][s]= (nums[0]==s? true: false);
        if (nums[0] == s) {
            dp[0][s] = true;
        } else {
            dp[0][s] = false;
        }

    }

    for (int i = 1; i &amp;lt; nums.size(); i++) {
        for (int s = 1; s &amp;lt;= halfSum; s++) {
            //选中nums[i]
            if(dp[i-1][s]) {
                //跳过nums[i]
                dp[i][s] = dp[i - 1][s];
            
            }else if (nums[i] &amp;lt;= s) {
                dp[i][s] = dp[i - 1][s - nums[i]];
            }
        }
    }
    return dp[nums.size() - 1][halfSum];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * S&lt;/em&gt;) ，S为数组和&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * S&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;拓展：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;输出和相等的两个分组&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; printPartition(const vector&amp;lt;int&amp;gt; &amp;amp;nums, const vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; &amp;amp;dp) {
    int row = nums.size();
    int halfSum = dp[0].size() - 1;
    //能否分成和相等的两部分
    bool canPartition = dp[row - 1][halfSum];

    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;
    vector&amp;lt;int&amp;gt; part1;
    vector&amp;lt;int&amp;gt; part2;


    for (int i = row - 1; i &amp;gt; 0; i--) {
        //选中，上一行和此行比较
        if (dp[i - 1][halfSum] != canPartition) {
            part1.push_back(nums[i]);

            //跳到选中之前的一步
            halfSum -= nums[i];
            //既然两行的值不一样，下一步比较时，canPartition取反
            canPartition = dp[i - 1][halfSum];
        } else {
            part2.push_back(nums[i]);
            //canPartition = dp[i][halfSum];
        }

    }

    //处理第一行，halfSum==0时，未选中。
    if (halfSum != 0) {
        part1.push_back(nums[0]);
    } else {
        part2.push_back(nums[0]);
    }
    result.push_back(part1);
    result.push_back(part2);
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-subset-sum&#34;&gt;3、subset sum&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定正整数数组和S值，判断是否存在子数组，使得其和等于S&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 2, 3, 7], s=6
    
output:	true
    
explanation:sum(1, 2, 3)=6
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 2, 7, 1, 5], s=10
    
output:	true
    
explanation:sum(1, 2, 7)=10
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 3, 4, 8], s=6
    
output:	false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;暴力法-2&#34;&gt;暴力法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool subsetSumRecursive(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int sum, int currentIndex) {
    if (sum == 0) {
        return true;
    }
    if (currentIndex &amp;gt;= nums.size()) {
        return false;
    }
    
    if (nums[currentIndex] &amp;lt;= sum) {
        //一定要加if判断，此分支(及分支的分支···）为假，不代表下一分支假
        //为假时跳到下一步
        if (subsetSumRecursive(nums, sum - nums[currentIndex], currentIndex + 1)) {
            return true;
        }
    }
    //上一分支为假
    return subsetSumRecursive(nums, sum, currentIndex + 1);
}

bool subsetSum(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int sum) {
    if (sum == 0) {
        return true;
    }
    if (nums.empty()) {
        return false;
    }
    return subsetSumRecursive(nums, sum, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(2^&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;自顶向下-2&#34;&gt;自顶向下&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool subsetSumRecursive2(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int sum, int currentIndex, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;dp) {
    if (sum == 0) {
        return true;
    }

    if (currentIndex &amp;gt;= nums.size()) {
        return false;
    }

    if (dp[currentIndex][sum] == -1) {

        if (nums[currentIndex] &amp;lt;= sum) {
            if (subsetSumRecursive2(nums, sum - nums[currentIndex], currentIndex + 1, dp)) {
                dp[currentIndex][sum] = 1;
                return true;
            }
        }
        dp[currentIndex][sum] = subsetSumRecursive2(nums, sum, currentIndex + 1, dp) ? 1 : 0;

    }

    return dp[currentIndex][sum] == 1 ? true : false;
}

bool subsetSum2(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int sum) {
    if (sum == 0) {
        return true;
    }
    if (nums.empty()) {
        return false;
    }
    int n = nums.size();
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(n, vector&amp;lt;int&amp;gt;(sum + 1, -1));
    return subsetSumRecursive2(nums, sum, 0, dp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * S&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * S&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;自底向上-2&#34;&gt;自底向上&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;./1-17.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-18.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-19.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-20.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-21.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool subsetSum3(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int sum) {
    if (sum == 0) {
        return true;
    }
    if (nums.empty()) {
        return false;
    }
    int n = nums.size();
    vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; dp(n, vector&amp;lt;bool&amp;gt;(sum + 1));

    for (int i = 0; i &amp;lt; n; i++) {
        dp[i][0] = true;
    }
    for (int s = 1; s &amp;lt;= sum; s++) {
        if (nums[0] == s) {
            dp[0][s] = true;
        } else {
            dp[0][s] = false;
        }
    }

    for (int i = 1; i &amp;lt; n; i++) {
        for (int s = 1; s &amp;lt;= sum; s++) {
          	//选中nums[i]
            if(dp[i-1][s]) {
                //跳过nums[i]
                dp[i][s] = dp[i - 1][s];
                
            }else if (nums[i] &amp;lt;= s) {
                dp[i][s] = dp[i - 1][s - nums[i]];
            }
        }
    }
    return dp[n - 1][sum];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * S&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * S&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;4-minimum-subset-sum-different&#34;&gt;4、minimum subset sum different&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定正整数组成的数组，将其分为不重合的两个子数组，使得子数组的和 的差的绝对值最小，输出最小的差&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 2, 3, 9]

output:	3
    
explanation：|sum(1,2,3) - sum(9)| = 3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 2, 7, 1, 5]

output:	0
    
explanation：|sum(1,2,5) - sum(7,1)| = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1,  3, 100, 4]

output:	92
    
explanation：|sum(1,3,4) - sum(100)| = 92
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;暴力法-3&#34;&gt;暴力法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int minSubsetSumDifferentRecursive(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int sum1, int sum2, int currentIndex) {
    if (currentIndex == nums.size()) {
        return abs(sum1 - sum2);
    }
    
    int diff1 = minSubsetSumDifferentRecursive(nums, sum1 + nums[currentIndex], sum2, currentIndex + 1);
    int diff2 = minSubsetSumDifferentRecursive(nums, sum1, sum2 + nums[currentIndex], currentIndex + 1);

    return min(diff1, diff2);
}


int minSubsetSumDifferent(const vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    return minSubsetSumDifferentRecursive(nums, 0, 0, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;2^N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;自顶向下-3&#34;&gt;自顶向下&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int minSubsetSumDifferentRecursive2(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int sum1, int sum2,
        int currentIndex,vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;dp) {
    if (currentIndex == nums.size()) {
        return abs(sum1-sum2);
    }
    if(dp[currentIndex][sum1]==-1){
        int diff1 = minSubsetSumDifferentRecursive(nums, sum1 + nums[currentIndex], sum2, currentIndex + 1);
        int diff2 = minSubsetSumDifferentRecursive(nums, sum1, sum2 + nums[currentIndex], currentIndex + 1);

        dp[currentIndex][sum1] = min(diff1,diff2);
    }
    
    return dp[currentIndex][sum1];
}

int minSubsetSumDifferent2(const vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    int sum=0;
    for(int i=0;i&amp;lt;nums.size();i++){
        sum+=nums[i];
    }
    
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(nums.size(),vector&amp;lt;int&amp;gt;(sum+1,-1));
    return minSubsetSumDifferentRecursive2(nums, 0, 0, 0,dp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * S&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * S&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;自底向上-3&#34;&gt;自底向上&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;子数组和等于Sum/2时，有最小值，如果不等于，求最接近sum/2的子数组。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./1-22.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-23.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-24.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-25.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-26.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-27.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int minSubsetSumDifferent3(const vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    int sum = 0;
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        sum += nums[i];
    }
    int n = nums.size();
    int halfSum = sum / 2;

    vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; dp(n, vector&amp;lt;bool&amp;gt;(halfSum + 1));

    for (int i = 0; i &amp;lt; n; i++) {
        dp[i][0] = true;
    }

    for (int s = 1; s &amp;lt;= halfSum; s++) {
        dp[0][s] = (nums[0] == s ? true : false);
    }
    for (int i = 1; i &amp;lt; n; i++) {
        for (int s = 1; s &amp;lt;= halfSum; s++) {
            if(dp[i-1][s]) {
                //跳过nums[i]
                dp[i][s] = dp[i - 1][s];

            }else if (nums[i] &amp;lt;= s) {
                dp[i][s] = dp[i - 1][s - nums[i]];
            }
        }
    }

    int sum1 = 0;

    //最后一行索引最大的值
    for (int i = halfSum; i &amp;gt;= 0; i--) {
        if (dp[n - 1][i] == true) {
            sum1 = i;
            break;
        }
    }
    int sum2 = sum - sum1;
    return abs(sum2 - sum1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * S&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * S&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;5-count-of-subset-sum&#34;&gt;5、count of subset sum&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定正整数数组和S值，求满足子数组和等于S的子数组所有个数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 1, 2, 3], S=4
    
output:	3
    
explanation:[1,1,2], [1,3], [1,3]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 2, 7, 1 , 5], S=9
    
output:	3
    
explanation:[2,7], [1,7,1], [1,2,1,5]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;暴力法-4&#34;&gt;暴力法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int countSubsetRecursive(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int sum, int currentIndex) {
    if (sum == 0) {
        return 1;
    }
    if (currentIndex &amp;gt;= nums.size()) {
        return 0;
    }
    int sum1 = 0;
    if (nums[currentIndex] &amp;lt;= sum) {
        sum1 = countSubsetRecursive(nums, sum - nums[currentIndex], currentIndex + 1);

    }
    int sum2 = countSubsetRecursive(nums, sum, currentIndex + 1);

    return sum1 + sum2;
}

int countSubset(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int sum) {
    if (nums.empty()) {
        return 0;
    }

    return countSubsetRecursive(nums, sum, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;2^N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;自顶向下-4&#34;&gt;自顶向下&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;
int countSubsetRecursive2(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int sum, int currentIndex, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;dp) {
    if (sum == 0) {
        return 1;
    }
    if (currentIndex &amp;gt;= nums.size()) {
        return 0;
    }

    if (dp[currentIndex][sum] == -1) {
        int sum1 = 0;
        if (nums[currentIndex] &amp;lt;= sum) {
            sum1 = countSubsetRecursive(nums, sum - nums[currentIndex], currentIndex + 1);

        }
        int sum2 = countSubsetRecursive(nums, sum, currentIndex + 1);
        dp[currentIndex][sum] = sum1 + sum2;
    }

    return dp[currentIndex][sum];
}

int countSubset2(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int sum) {
    if (nums.empty()) {
        return 0;
    }

    int n = nums.size();
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(n, vector&amp;lt;int&amp;gt;(sum + 1, -1));

    return countSubsetRecursive2(nums, sum, 0, dp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * S&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * S&lt;/em&gt;)&lt;/p&gt;

&lt;h3 id=&#34;自底向上-4&#34;&gt;自底向上&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;./1-5-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int countSubset3(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int sum) {
    if (nums.empty()) {
        return 0;
    }

    int n = nums.size();
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(n, vector&amp;lt;int&amp;gt;(sum + 1, 0));


    for (int i = 0; i &amp;lt; n; i++) {
        dp[i][0] = 1;
    }

    for (int s = 1; s &amp;lt;= sum; s++) {
        dp[0][s] = (nums[0] == s ? 1 : 0);
    }
    for (int i = 1; i &amp;lt; n; i++) {
        for (int s = 1; s &amp;lt;= sum; s++) {
            //未加入，顺序不能错
            dp[i][s] = dp[i - 1][s];

            //加入
            if (nums[i] &amp;lt;= s) {
                dp[i][s] = dp[i][s] + dp[i - 1][s - nums[i]];
            }
        }
    }
    return dp[n - 1][sum];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * S&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * S&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-5-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-5-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-5-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-5-5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-5-6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-5-7.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;6-target-sum&#34;&gt;6、target sum&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定正整数数组和值S，数组每个数前缀&amp;rdquo;+&amp;ldquo;或&amp;rdquo;-&amp;ldquo;，使得所有数的和为S，求多少种方式&lt;/p&gt;

&lt;p&gt;即求子数组a1，子数组a2，使得sum(a1) - sum(a2)=S&lt;/p&gt;

&lt;p&gt;且sum(a1) + sum(a2)= S-total&lt;/p&gt;

&lt;p&gt;则：sum(a1)=(S + S-total)/2&lt;/p&gt;

&lt;p&gt;即求子数组，使得其和为(S + S-total)/2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 2, 2, 3] ,s=1
    
output:	3
   
explanation:+1-1-2+3=1, -1+1-2+3=1, +1+1+2-3=1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1 ,2 ,7, 1] ,s=9
   
output:	2
    
explanation:+1+2+7-1=9 , -1+2+7+1=2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;自底向上-5&#34;&gt;自底向上&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int countSubsets(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int sum) {
    int n = nums.size();
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(n, vector&amp;lt;int&amp;gt;(sum + 1));
    for (int i = 0; i &amp;lt; n; i++) {
        dp[i][0] = 1;
    }

    for (int s = 1; s &amp;lt;= sum; s++) {
        dp[0][s] = (nums[0] == s ? 1 : 0);
    }

    for (int i = 1; i &amp;lt; n; i++) {
        for (int s = 1; s &amp;lt;= sum; s++) {
            dp[i][s] = dp[i - 1][s];
            if (nums[i] &amp;lt;= s) {
                dp[i][s] = dp[i][s] + dp[i - 1][s - nums[i]];
            }
        }
    }

    return dp[n - 1][sum];
}

int targetSum(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int target) {
    int totalSum = 0;
    for (auto n:nums) {
        totalSum += n;
    }

    if (totalSum &amp;lt; target || (target + totalSum) % 2 == 1) {
        return 0;
    }

    return countSubsets(nums, (target + totalSum) / 2);
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * S&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * S&lt;/em&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dynamic Programming-1 Introduction</title>
      <link>/code/dynamic-progamming/1-introduction/</link>
      <pubDate>Wed, 01 Jul 2020 16:33:16 +0800</pubDate>
      <guid>/code/dynamic-progamming/1-introduction/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;p&gt;​       解决多阶段决策过程最优化的一种数学方法。把多阶段问题变换为一系列相互联系的的单阶段问题，然后逐个加以解决。是一种数学方法，是求解某类问题的一种方法，而&lt;strong&gt;不是一种特殊的算法&lt;/strong&gt;，没有一个标准的数学表达式或明确定义的一种规则。&lt;/p&gt;

&lt;h2 id=&#34;2-特征&#34;&gt;2、特征&lt;/h2&gt;

&lt;h3 id=&#34;重叠子问题&#34;&gt;重叠子问题&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;./2-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;最优子结构&#34;&gt;最优子结构&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;./2-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-方法&#34;&gt;3、方法&lt;/h2&gt;

&lt;h3 id=&#34;自顶向下-缓存已计算的重复结果&#34;&gt;自顶向下，缓存已计算的重复结果&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int fibRecursive(vector&amp;lt;int&amp;gt; &amp;amp;memoize, int n) {
    if (n &amp;lt; 2) return n;

    if (memoize[n] != 0) {
        return memoize[n];
    }
    
    memoize[n] = fibRecursive(memoize, n - 1) + fibRecursive(memoize, n - 2);

    return memoize[n];
}

int fib(int n) {
    vector&amp;lt;int&amp;gt; memoize(n + 1, 0);
    return fibRecursive(memoize, n-1)+fibRecursive(memoize,n-2);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;自底向上-列表计算后续结果&#34;&gt;自底向上，列表计算后续结果&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int fib(int n) {
    if (n == 0) return 0;
    vector&amp;lt;int&amp;gt; dp(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i &amp;lt;= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[n];
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-18 Miscellaneous</title>
      <link>/code/pattern/miscellaneous/</link>
      <pubDate>Sun, 24 May 2020 12:30:08 +0800</pubDate>
      <guid>/code/pattern/miscellaneous/</guid>
      <description>

&lt;h2 id=&#34;2号&#34;&gt;2号&lt;/h2&gt;

&lt;h3 id=&#34;3号&#34;&gt;3号&lt;/h3&gt;

&lt;h4 id=&#34;4号&#34;&gt;4号&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-19 Conclusion</title>
      <link>/code/pattern/conclusion/</link>
      <pubDate>Sat, 23 May 2020 18:01:15 +0800</pubDate>
      <guid>/code/pattern/conclusion/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Pattern-17 Topological Sort</title>
      <link>/code/pattern/topological-sort/</link>
      <pubDate>Sat, 23 May 2020 17:59:08 +0800</pubDate>
      <guid>/code/pattern/topological-sort/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Pattern-16 0-1 Knapsack</title>
      <link>/code/pattern/0-1-knapsack/</link>
      <pubDate>Sat, 23 May 2020 17:57:50 +0800</pubDate>
      <guid>/code/pattern/0-1-knapsack/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Pattern-15 K Way Merge</title>
      <link>/code/pattern/k-way-merge/</link>
      <pubDate>Sat, 23 May 2020 17:56:50 +0800</pubDate>
      <guid>/code/pattern/k-way-merge/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;p&gt;解决k个有序数组的合并、最值问题。用heap。&lt;/p&gt;

&lt;h2 id=&#34;2-merge-k-sorted-lists&#34;&gt;2、merge k sorted lists&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定K组有序链表，合成一个有序链表&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	l1=[2, 6, 8], l2=[3, 6, 7], l3=[1, 3, 4]
    
output:	[1, 2, 3, 3, 4, 6, 6, 7, 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	l1=[5, 8, 9] ,l2=[1, 7]
    
output:	[1, 5, 7, 8, 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct ListNode {
    int val;
    ListNode *next;

    ListNode(int data) : val(data), next(NULL) {};
};

struct cmp_greater {
    bool operator()(const ListNode *x, const ListNode *y) {
        return x-&amp;gt;val &amp;gt; y-&amp;gt;val;
    }
};

ListNode *merge(const vector&amp;lt;ListNode *&amp;gt; &amp;amp;lists) {

    priority_queue&amp;lt;ListNode *, vector&amp;lt;ListNode *&amp;gt;, cmp_greater&amp;gt; minHeap;

    for (auto root:lists) {
        if (root != NULL) {
            minHeap.push(root);
        }
    }

    ListNode *resultHead = NULL;
    ListNode *resultTail = NULL;

    while (!minHeap.empty()) {
        ListNode *node = minHeap.top();
        minHeap.pop();
        if (resultHead == NULL) {
            resultHead = node;
            resultTail = node;
        } else {
            resultTail-&amp;gt;next = node;
            resultTail = resultTail-&amp;gt;next;
            //resultTail=node;
        }

        if (node-&amp;gt;next != NULL) {
            minHeap.push(node-&amp;gt;next);
        }
    }

    return resultHead;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * log K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;3-kth-smallest-number-in-m-sorted-lists&#34;&gt;3、kth smallest number in m sorted lists&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定M个有序数组，求所有数组中第K小的元素&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	l1=[2, 6, 8], l2=[3, 6, 7], l3=[1, 3, 4],K=5
    
output:	4

explanations:[1, 2, 3, 3, 4, 6, 6, 7, 8] 5th-&amp;gt;4
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: l1=[5, 8, 9], l2=[1, 7],K=3
   
output:	7
    
explanations:[1, 5, 7, 8, 9] 3th-&amp;gt;7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_greater {
    bool operator()(const pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; &amp;amp;x, const pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; &amp;amp;y) {
        return x.first &amp;gt; y.first;
    }
};

int kthSmallest(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;lists, int k) {
    //pair&amp;lt;int,pair&amp;lt;int,int&amp;gt;&amp;gt;&amp;gt; 值，值所在第几个数组，值得索引
    priority_queue&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;, vector&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt;, cmp_greater&amp;gt; minHeap;
    for (int i = 0; i &amp;lt; lists.size(); i++) {
        if (!lists[i].empty()) {
            minHeap.push({lists[i][0], {i, 0}});
        }
    }

    int numberCount = 0, result = 0;

    while (!minHeap.empty()) {
        auto node = minHeap.top();
        minHeap.pop();

        result = node.first;

        if (++numberCount == k) {
            break;
        }

        //下一个node
        node.second.second++;

        //node 所在链表还有元素
        if (lists[node.second.first].size() &amp;gt; node.second.second) {
            node.first = lists[node.second.first][node.second.second];
            minHeap.push(node);
        }
    }

    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;K * log M&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;M&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;相似问题1：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;求m个有序数组、链表的平均值&lt;/p&gt;

&lt;p&gt;解：此时k=N/2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;相似问题1：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;合并m个有序数组&lt;/p&gt;

&lt;p&gt;解：同此题，要记录元素所在数组及索引&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;4-kth-smallest-number-in-a-sorted-matrix&#34;&gt;4、kth smallest number in a sorted matrix&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定矩阵和K值，每行每列增序，求第K小的数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	maxtrix=[
    [2, 6, 8],
    [3, 7, 10],
    [5, 8, 11]
	], k=5

output:	7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_greater {
    bool operator()(const pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; &amp;amp;x, const pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; &amp;amp;y) {
        return x.first &amp;gt; y.first;
    }
};

int kthSmallest(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;matrix, int k) {
    //pair&amp;lt;int,pair&amp;lt;int,int&amp;gt;&amp;gt;&amp;gt; 值，值所在第几个数组，值得索引
    priority_queue&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;, vector&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt;, cmp_greater&amp;gt; minHeap;

    //每行第一个元素放入heap，且不需要超过k个元素
    for (int i = 0; i &amp;lt; matrix.size() &amp;amp;&amp;amp; i &amp;lt; k; i++) {
        minHeap.push({matrix[i][0], {i, 0}});
    }

    int numberCount = 0, result = 0;

    while (!minHeap.empty()) {
        auto node = minHeap.top();
        minHeap.pop();

        result = node.first;

        if (++numberCount == k) {
            break;
        }

        //下一个node
        node.second.second++;

        //node 所在链表还有元素
        if (matrix.size() &amp;gt; node.second.second) {
            node.first = matrix[node.second.first][node.second.second];
            minHeap.push(node);
        }
    }

    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;min(K,N)&lt;/em&gt; + &lt;em&gt;K * log N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;二分查找的方法：&lt;/p&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;待看
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-smallest-number-range&#34;&gt;5、smallest number range&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定m个有序数组，求长度最小的范围区间，使得区间包含每个数组至少一个元素&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	l1=[1, 5, 8], l2=[4, 12], l3=[7, 8, 10]
    
output:	[4, 7]

explanation: l1:-&amp;gt;5,l2:-&amp;gt;4, l3:-&amp;gt;7
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	l1=[1, 9], l2=[4, 12], l3=[7, 10, 16]
    
output:	[9, 12]

explanation: l1:-&amp;gt;9 ,l2:-&amp;gt;12, l3:-&amp;gt;10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_greater {
    bool operator()(const pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; &amp;amp;x, const pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; &amp;amp;y) {
        return x.first &amp;gt; y.first;
    }
};

pair&amp;lt;int, int&amp;gt; smallestRange(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;lists) {
    //pair&amp;lt;int,pair&amp;lt;int,int&amp;gt;&amp;gt;&amp;gt; 值，值所在第几个数组，值得索引
    priority_queue&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;, vector&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt;, cmp_greater&amp;gt; minHeap;

    int rangeStart = 0, rangeEnd = INT_MAX;
    int currentMaxNumber = INT_MIN;

    for (int i = 0; i &amp;lt; lists.size(); i++) {
        if (!lists[i].empty()) {
            minHeap.push({lists[i][0], {i, 0}});
            //minHeap.push(make_pair(lists[i][0], make_pair(i, 0)));
            currentMaxNumber = max(lists[i][0], currentMaxNumber);
        }
    }


    while (minHeap.size() == lists.size()) {
        auto node = minHeap.top();
        minHeap.pop();

        if (rangeEnd - rangeStart &amp;gt; currentMaxNumber - node.first) {
            rangeStart = node.first;
            rangeEnd = currentMaxNumber;
        }

        //下一个node
        node.second.second++;

        //node 所在链表还有元素
        if (lists[node.second.first].size() &amp;gt; node.second.second) {
            node.first = lists[node.second.first][node.second.second];
            minHeap.push(node);
            currentMaxNumber = max(currentMaxNumber, node.first);
        }
    }

    return make_pair(rangeStart, rangeEnd);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * log M&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;M&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;6-k-pair-with-largest-sums&#34;&gt;6、k pair with largest sums&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定两个降序数组和k值，求和最大的K对数(每个数组各一个值，值允许重复)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	l1=[9, 8, 2], l2=[6, 3, 1], k=3
    
output:	[9, 3],[9, 6],[8, 6]

explanation: 和最大的三组
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	l1=[5, 2, 1], l2=[2, -1], k=3
    
output:	[5, 2],[5, -1], [2,2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_greater_sum{
    bool operator()(const pair&amp;lt;int,int&amp;gt; &amp;amp;x,const pair&amp;lt;int,int&amp;gt; &amp;amp;y){
        return x.first+x.second&amp;gt;y.second+y.first;
    }
};

vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; klargestPairs(const vector&amp;lt;int&amp;gt; &amp;amp;num1,const vector&amp;lt;int&amp;gt; &amp;amp;num2,int k) {
    priority_queue&amp;lt;pair&amp;lt;int,int&amp;gt;,vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt;,cmp_greater_sum&amp;gt; minHeap;

    for(int i=0;i&amp;lt;num1.size();i++){
        for(int j=0;i&amp;lt;num2.size();j++){
            if(minHeap.size()&amp;lt;k){
                minHeap.push(make_pair(num1[i],num2[j]));
            }else{
                if(num1[i]+num2[j]&amp;lt;minHeap.top().first+minHeap.top().second){
                    break;
                }else{
                    minHeap.pop();
                    minHeap.push(make_pair(num1[i],num2[j]));
                }
            }
        }
    }

    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;
    while(!minHeap.empty()){
        result.push_back({minHeap.top().first,minHeap.top().second});
        minHeap.pop();
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * M * log K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-14 Top K Elements</title>
      <link>/code/pattern/top-k-elements/</link>
      <pubDate>Sat, 23 May 2020 17:56:30 +0800</pubDate>
      <guid>/code/pattern/top-k-elements/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;p&gt;最大/最小/出现次数 的 第/前 K个元素，常用heap。&lt;/p&gt;

&lt;h2 id=&#34;2-top-k-numbers&#34;&gt;2、top k numbers&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定未排序数组和K值，求前K个大的元素&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, 1, 5, 12, 2, 11] ,K=3
    
output: [5, 12, 11]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[5, 12, 11, -1, 12] ,K=3
    
output: [5, 12, 12]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;int&amp;gt; findLargestNumbers(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) {
    priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; minHeap;
    vector&amp;lt;int&amp;gt; result;
    for (int i = 0; i &amp;lt; k; i++) {
        minHeap.push(nums[i]);
    }

    for (int i = k; i &amp;lt; nums.size(); i++) {
        if (nums[i] &amp;gt; minHeap.top()) {
            minHeap.pop();
            minHeap.push(nums[i]);
        }
    }
    for (int i = 0; i &amp;lt; k; i++) {
        result.push_back(minHeap.top());
        minHeap.pop();
    }
    return result;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;  * log &lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;3-kth-smallest-number&#34;&gt;3、kth smallest number&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定未排序数组和K值，求第K个小的元素&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 5, 12, 2, 11, 5] ,K=3
    
output: 5
    
explanations: 1 2 5 5 11 12
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 5, 12, 2, 11, 5] ,K=4
    
output: 5
    
explanations: 1 2 5 5 11 12
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[5, 11, 12, -1, 12] ,K=3
    
output: 11
    
explanations: -1 5  11 12 12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int kthSmallestNumber(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) {
    priority_queue&amp;lt;int&amp;gt; maxHeap;
    for (int i = 0; i &amp;lt; k; i++) {
        maxHeap.push(nums[i]);
    }

    for (int i = k; i &amp;lt; nums.size(); i++) {
        if (nums[i] &amp;lt; maxHeap.top()) {
            maxHeap.pop();
            maxHeap.push(nums[i]);
        }
    }
    return maxHeap.top();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;  * log &lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;使用小顶堆：&lt;/p&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int kthSmallestNumberUseMinHeap(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) {
    priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; minHeap;
    
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        minHeap.push(nums[i]);
    }

    for (int i = 0; i &amp;lt; k - 1; i++) {
        minHeap.pop();
    }
    
    return minHeap.top();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;  + &lt;em&gt;K&lt;/em&gt; log &lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;4-k-closest-points-to-the-origin&#34;&gt;4、k closest points to the origin&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定一组二位坐标点和K值，求前K个离原点最近的的点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[[1, 2], [1, 3]], k=1
    
output:	[[1, 2]]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[[1, 3], [3, 4], [2, -1]], k=2
    
output:	[[1, 3],[2, -1]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct Point {
    int x, y;

    Point(int _x, int _y) : x(_x), y(_y) {};
};

int distance(Point p) {
    return p.x * p.x + p.y + p.y;
}

bool operator&amp;lt;(Point a, Point b) {
    //return a.x*a.x +a.y*a.y &amp;gt; b.x*b.x+b.y+b.y;
    return distance(a) &amp;lt; distance(b);
}


vector&amp;lt;Point&amp;gt; findKthClosestPoints(const vector&amp;lt;Point&amp;gt; &amp;amp;Points, int k) {
    priority_queue&amp;lt;Point&amp;gt; maxHeap;

    vector&amp;lt;Point&amp;gt; result;
    for (int i = 0; i &amp;lt; k; i++) {
        maxHeap.push(Points[i]);
    }

    for (int i = k; i &amp;lt; Points.size(); i++) {
        if (distance(Points[i]) &amp;lt; distance(maxHeap.top())) {
            maxHeap.pop();
            maxHeap.push(Points[i]);
        }
    }
    for (int i = 0; i &amp;lt; k; i++) {
        result.push_back(maxHeap.top());
        maxHeap.pop();
    }
    return result;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;  * log &lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;5-connect-ropes&#34;&gt;5、connect ropes&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;把N段不同绳子连接成一段长绳子，使得cost最小&lt;/p&gt;

&lt;p&gt;连接两段绳子的cost= 两段绳子的长度和&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 3, 11, 5]

output: 33
    
explanations: cost1: 1 + 3 = 4; cost2: 4 + 5 = 9 ; cost3 :9 + 11 =20 ;totalcost: 4 + 9 + 20 = 33
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [3, 4, 5, 6]

output: 36
    
explanations: cost1: 3 + 4 = 7; cost2: 5 + 6 = 11 ; cost3 :7 + 11 =18 ;totalcost: 7 + 11 + 18 = 36
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 3, 11, 5, 2]

output: 42
    
explanations: cost1: 1 + 2 = 3; cost2: 3 + 3 = 6 ; cost3 :6 + 5 =11 ;cost4 :11 + 11 =22 ; totalcost: 3 +6  + 11 + 12 = 42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int minimumCostConnectRopes(const vector&amp;lt;int&amp;gt; &amp;amp;nums) {

    int result = 0;
    int temp = 0;

    priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; minHeap;

    for (int i = 0; i &amp;lt; nums.size(); i++) {
        minHeap.push(nums[i]);
    }

    while (minHeap.size() &amp;gt; 1) {
        temp = minHeap.top();
        minHeap.pop();
        temp += minHeap.top();
        minHeap.pop();
        result += temp;
        minHeap.push(temp);
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;  * log &lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;6-top-k-frequent-numbers&#34;&gt;6、top k frequent numbers&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定未排序数组和K值，求出现次数前K的数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 3, 5, 12, 11, 12, 11], k=2
    
output:	[12, 11]

explanations: 12(2), 11(2) , 其他1次
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [5, 12, 11, 3, 11], k=2
    
output:	[11, 5] 或[11, 12] 或[11, 3]

explanations: 11(2), 其他1次
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_greater {
    bool operator()(const pair&amp;lt;int, int&amp;gt; &amp;amp;x, const pair&amp;lt;int, int&amp;gt; &amp;amp;y) {
        return x.second &amp;gt; y.second;
    }
};

vector&amp;lt;int&amp;gt; findTopKFrequencyNumbers(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) {
    unordered_map&amp;lt;int, int&amp;gt; numFrequencyMap;
    for (auto n:nums) {
        numFrequencyMap[n]++;
    }

    priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;, cmp_greater&amp;gt; minHeap;

    for (auto entry: numFrequencyMap) {
        minHeap.push(entry);
        if (minHeap.size() &amp;gt; k) {
            minHeap.pop();
        }
    }

    vector&amp;lt;int&amp;gt; topNumbers;
    while (!minHeap.empty()) {
        topNumbers.push_back(minHeap.top().first);
        minHeap.pop();
    }

    return topNumbers;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; + &lt;em&gt;N&lt;/em&gt;  * log &lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;7-frequency-sort&#34;&gt;7、frequency sort&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定字符串，按照字符出现的次数降序排列&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;Programming&amp;quot;
    
output:	&amp;quot;rrggmmPiano&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;abcbab&amp;quot;
    
output:	&amp;quot;bbbaac&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_smaller {
    bool operator()(const pair&amp;lt;char, int&amp;gt; &amp;amp;x, const pair&amp;lt;char, int&amp;gt; &amp;amp;y) {
        return x.second &amp;lt; y.second;
    }
};

string sortCharacterByFrequency(const string &amp;amp;str) {
    unordered_map&amp;lt;char, int&amp;gt; characterFrequencyMap;
    for (char chr:str) {
        characterFrequencyMap[chr]++;
    }

    priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;, cmp_smaller&amp;gt; maxHeap;
    for (auto entry :characterFrequencyMap) {
        maxHeap.push(entry);
    }

    string sortedString = &amp;quot;&amp;quot;;
    while (!maxHeap.empty()) {
        auto entry = maxHeap.top();
        maxHeap.pop();
        for (int i = 0; i &amp;lt; entry.second; i++) {
            sortedString += entry.first;
        }
    }

    return sortedString;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;  * log &lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;8-kth-largest-number-in-a-stream&#34;&gt;8、kth largest number in a stream&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;设计一个类，求数据流中的最大值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;9-k-closest-numbers&#34;&gt;9、k closest numbers&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定排序的数组，及整数K和X。求数组中K个接近X的数，将返回的数排序，X不一定在原数组中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[5, 6, 7, 8, 9] , k=3 ,x=7
    
output:	[6, 7 , 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2 ,4 ,5 ,6 ,9] ,k=3 ,x=6
    
output:	[4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2, 4, 5, 6, 9] ,k=3 ,x=10
    
output:	[5, 6, 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_greater {
    bool operator()(const pair&amp;lt;int, int&amp;gt; &amp;amp;x, const pair&amp;lt;int, int&amp;gt; &amp;amp;y) {
        return x.first &amp;gt; y.first;
    }
};

int binarySearch(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int target) {

    int low = 0;
    int high = arr.size() - 1;

    while (low &amp;lt;= high) {

        int mid = low + (high - low) / 2;
        if (target = arr[mid]) {
            return mid;
        } else if (target &amp;gt; arr[mid]) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    if (low &amp;gt; 0) {
        return low - 1;
    }
    return low;
}

vector&amp;lt;int&amp;gt; findClosestElements(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int k, int x) {
    int index = binarySearch(arr, x);
    int low = index - k;
    int high = index + k;
    low = max(low, 0);
    high = min((int) arr.size() - 1, high);

    priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;, cmp_greater&amp;gt; minHeap;

    for (int i = low; i &amp;lt;= high; i++) {
        minHeap.push(make_pair(abs(arr[i] - x), i));
    }

    vector&amp;lt;int&amp;gt; result;
    for (int i = 0; i &amp;lt; k; i++) {
        result.push_back(arr[minHeap.top().second]);
        minHeap.pop();
    }

    sort(result.begin(), result.end());
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;( log &lt;em&gt;N&lt;/em&gt; + &lt;em&gt;K&lt;/em&gt;  * log &lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;双指针法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int binarySearch(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int target) {
    int low = 0;
    int high = arr.size() - 1;

    while (low &amp;lt;= high) {

        int mid = low + (high - low) / 2;
        if (target = arr[mid]) {
            return mid;
        } else if (target &amp;gt; arr[mid]) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    if (low &amp;gt; 0) {
        return low - 1;
    }
    return low;
}


vector&amp;lt;int&amp;gt; findClosestElements2(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int k, int x) {
    deque&amp;lt;int&amp;gt; result;
    int index = binarySearch(arr, x);
    int leftPointer = index;
    int rightPointer = index + 1;
    for (int i = 0; i &amp;lt; k; i++) {
        if (leftPointer &amp;gt;= 0 &amp;amp;&amp;amp; rightPointer &amp;lt; (int) arr.size()) {
            int diff1 = abs(x - arr[leftPointer]);
            int diff2 = abs(x - arr[rightPointer]);
            if (diff1 &amp;lt;= diff2) {
                result.push_back(arr[leftPointer]);
                leftPointer--;
            } else {
                result.push_back(arr[rightPointer++]);
            }
        } else if (leftPointer &amp;gt;= 0) {
            result.push_back(arr[leftPointer--]);
        } else if (rightPointer &amp;lt; (int) arr.size()) {
            result.push_back(arr[rightPointer++]);
        }
    }
    
    vector&amp;lt;int&amp;gt; resultvec;
    move(begin(result), end(result), back_inserter(resultvec));
    sort(resultvec.begin(), resultvec.end());
    return resultvec;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;K&lt;/em&gt;  + log &lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;1&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;10-maximum-distinct-elements&#34;&gt;10、maximum distinct elements&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定数组和K值，删除K个数后，求剩余的不重复的数的最大个数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./10-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_greater {
    bool operator()(const pair&amp;lt;int, int&amp;gt; &amp;amp;x, const pair&amp;lt;int, int&amp;gt; &amp;amp;y) {
        return x.second &amp;gt; y.second;
    }
};

int maximumDistinctElements(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) {
    int distinctElementsCount = 0;
    if (nums.size() &amp;lt;= k) {
        return distinctElementsCount;
    }

    unordered_map&amp;lt;int, int&amp;gt; numFrequencyMap;
    for (auto num:nums) {
        numFrequencyMap[num]++;
    }

    priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;, cmp_greater&amp;gt; minHeap;
    for (auto entry:numFrequencyMap) {
        if (entry.second == 1) {
            distinctElementsCount++;
        } else {
            minHeap.push(entry);
        }
    }

    while (k &amp;gt; 0 &amp;amp;&amp;amp; !minHeap.empty()) {
        auto entry = minHeap.top();
        minHeap.pop();
        k -= entry.second - 1;
        if (k &amp;gt;= 0) {
            distinctElementsCount++;
        }
    }

    if (k &amp;gt; 0) {
        distinctElementsCount -= k;
    }

    return distinctElementsCount;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;( &lt;em&gt;N&lt;/em&gt; * log &lt;em&gt;N&lt;/em&gt; + &lt;em&gt;K&lt;/em&gt;  * log &lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;11-sum-of-elements&#34;&gt;11、sum of elements&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定数组和K1、K2值，求第k1小和第k2小之间元素和&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1 ,3 ,12 ,5 ,15 ,11] , k1= 3, k2 = 6
    
output:	23
    
explanations:3th-&amp;gt;5,6th-&amp;gt;15   ,11(4th) + 12(5th) = 23
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, 5, 8, 7] , k1=1, k2 = 4
    
output:	12
    
explanations:1th-&amp;gt;3,4th-&amp;gt;8   ,5(2th) + 7(3th) = 12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int sumOfElements(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int k1, int k2) {
    int sum = 0;
    priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; minHeap;
    for (auto num:nums) {
        minHeap.push(num);
    }

    for (int i = 0; i &amp;lt; k1; i++) {
        minHeap.pop();
    }

    for (int i = 0; i &amp;lt; k2 - k1 - 1; i++) {
        sum += minHeap.top();
        minHeap.pop();
    }

    return sum;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;  * log &lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;大顶堆方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int sumOfElements2(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int k1, int k2) {
    int sum = 0;
    priority_queue&amp;lt;int&amp;gt; maxHeap;
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        if (i &amp;lt; k2 - 1) {
            maxHeap.push(nums[i]);
        } else if (nums[i] &amp;lt; maxHeap.top()) {
            maxHeap.pop();
            maxHeap.push(nums[i]);
        }
    }
    
    for (int i = 0; i &amp;lt; k2 - k1 - 1; i++) {
        sum += maxHeap.top();
        maxHeap.pop();
    }

    return sum;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;  * log &lt;em&gt;K2&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;K2&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;12-rearrange-string&#34;&gt;12、rearrange string&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定字符串，重新排列，使得相同字符不在一起&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;aappp&amp;quot;
    
output:	&amp;quot;papap&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;Programming&amp;quot;
    
output:	&amp;quot;rgmrgmPiano&amp;quot;,或&amp;quot;gmringmrPoa&amp;quot;,等等
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;aapa&amp;quot;
    
output:	&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_smaller {
    bool operator()(const pair&amp;lt;char, int&amp;gt; &amp;amp;x, const pair&amp;lt;char, int&amp;gt; &amp;amp;y) {
        return x.second &amp;lt; y.second;
    }
};

string rearrangeString(const string &amp;amp;str) {
    unordered_map&amp;lt;char, int&amp;gt; charFrequencyMap;
    priority_queue&amp;lt;pair&amp;lt;char, int&amp;gt;, vector&amp;lt;pair&amp;lt;char, int&amp;gt;&amp;gt;, cmp_smaller&amp;gt; maxHeap;
    string resultString = &amp;quot;&amp;quot;;
    pair&amp;lt;char, int&amp;gt; previousEntry(-1, -1);

    for (auto chr:str) {
        charFrequencyMap[chr]++;
    }

    for (auto entry:charFrequencyMap) {
        maxHeap.push(entry);
    }

    while (!maxHeap.empty()) {
        pair&amp;lt;char, int&amp;gt; currentEntry = maxHeap.top();
        maxHeap.pop();
        if (previousEntry.second &amp;gt; 0) {
            maxHeap.push(previousEntry);
        }

        resultString += currentEntry.first;
        currentEntry.second--;
        previousEntry = currentEntry;
    }

    return resultString.length() == str.length() ? resultString : &amp;quot;&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;  * log &lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;13-rearrange-string-k-distance-apart&#34;&gt;13、rearrange string k distance apart&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定字符串和K值，重新排列字符串，使得相同字符至少相隔k个字符&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;mmpp&amp;quot;, k=2
    
output:	&amp;quot;mpmp&amp;quot; 或 &amp;quot;pmpm&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;aappa&amp;quot;, k=3
    
output:	&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;Programming&amp;quot;, k=3
    
output:	&amp;quot;rgmPrgmiano&amp;quot; 或 &amp;quot;gmrPagimnor&amp;quot; 等等
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_smaller {
    bool operator()(const pair&amp;lt;char, int&amp;gt; &amp;amp;x, const pair&amp;lt;char, int&amp;gt; &amp;amp;y) {
        return x.second &amp;lt; y.second;
    }
};

string reorganizeString(const string &amp;amp;str, int k) {
    unordered_map&amp;lt;char, int&amp;gt; charFrequencyMap;
    priority_queue&amp;lt;pair&amp;lt;char, int&amp;gt;, vector&amp;lt;pair&amp;lt;char, int&amp;gt;&amp;gt;, cmp_smaller&amp;gt; maxHeap;
    string resultString = &amp;quot;&amp;quot;;

    queue&amp;lt;pair&amp;lt;char, int&amp;gt;&amp;gt; queue;

    if (k &amp;lt;= 1) {
        return str;
    }

    for (auto chr:str) {
        charFrequencyMap[chr]++;
    }

    for (auto entry:charFrequencyMap) {
        maxHeap.push(entry);
    }

    while (!maxHeap.empty()) {
        pair&amp;lt;char, int&amp;gt; currentEntry = maxHeap.top();
        maxHeap.pop();

        resultString += currentEntry.first;
        currentEntry.second--;
        queue.push(currentEntry);
        if (queue.size() == k) {
            auto entry = queue.front();
            queue.pop();
            if (entry.second &amp;gt; 0) {
                maxHeap.push(entry);
            }
        }
    }
    return resultString.length() == str.length() ? resultString : &amp;quot;&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;  * log &lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;14-scheduling-tasks&#34;&gt;14、scheduling tasks&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;任务调度，给定一组任务和K值，一个任务执行后必须间隔K 段时间，求完成调度最小总时间，当任务不能调度时用idle&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./14-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_smaller {
    bool operator()(const pair&amp;lt;char, int&amp;gt; &amp;amp;x, const pair&amp;lt;char, int&amp;gt; &amp;amp;y) {
        return x.second &amp;lt; y.second;
    }
};

int scheduleTask(const vector&amp;lt;char&amp;gt; &amp;amp;task, int k) {
    int intervalCount = 0;
    unordered_map&amp;lt;char, int&amp;gt; charFrequencyMap;
    priority_queue&amp;lt;pair&amp;lt;char, int&amp;gt;, vector&amp;lt;pair&amp;lt;char, int&amp;gt;&amp;gt;, cmp_smaller&amp;gt; maxHeap;


    for (auto chr:task) {
        charFrequencyMap[chr]++;
    }

    for (auto entry:charFrequencyMap) {
        maxHeap.push(entry);
    }

    while (!maxHeap.empty()) {
        vector&amp;lt;pair&amp;lt;char, int&amp;gt;&amp;gt; waitList;
        int n = k + 1;
        for (; n &amp;gt; 0 &amp;amp;&amp;amp; !maxHeap.empty(); n--) {
            intervalCount++;
            auto currentEntry = maxHeap.top();
            maxHeap.pop();

            if (currentEntry.second &amp;gt; 1) {
                currentEntry.second--;
                waitList.push_back(currentEntry);
            }
        }

        for (auto w:waitList) {
            maxHeap.push(w);
        }

        if (!maxHeap.empty()) {
            intervalCount += n;
        }
    }
    return intervalCount;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;  * log &lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;15-frequency-stack&#34;&gt;15、frequency stack&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;设计类&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-13 Bitwise Xor</title>
      <link>/code/pattern/bitwise-xor/</link>
      <pubDate>Sat, 23 May 2020 17:55:41 +0800</pubDate>
      <guid>/code/pattern/bitwise-xor/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;p&gt;异或操作&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;异或性质：
    
1、自身异或为0：
    1 ^ 1 = 0, 29 ^ 29 = 0
 
2、与0异或为自身：
    1 ^ 0 = 1, 29 ^ 0 = 29  
    
3、交换律和结合律：
    (a ^ b) ^ c = a ^ (b ^ c)
    
    a ^ b = b ^ a
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-missing-number-and-single-number&#34;&gt;2、missing number and single number&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定数组（元素为n-1个），范围（1-n），求缺失的数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findMissingNumber(const vector&amp;lt;int&amp;gt; &amp;amp;arr) {
    int n = arr.size() + 1;
    int s1 = 1;
    for (int i = 2; i &amp;lt;= n; i++) {
        s1 ^= i;
    }

    int s2 = arr[0];
    for (int j = 1; j &amp;lt; n - 1; j++) {
        s2 ^= arr[j];
    }

    return s1 ^ s2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;p&gt;相似问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;非空数组，只有1个元素出现1次，其余出现2次，求出现一次的那个数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 4, 2, 1, 3, 2, 3]

output: 4
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [7, 9, 7]

output: 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int singleNumber(const vector&amp;lt;int&amp;gt; &amp;amp;arr) {
    int result = arr[0];
    //int result1=0; for循环：i=0
    for (int i = 1; i &amp;lt; arr.size(); i++) {
        result ^= arr[i];
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;3-two-single-number&#34;&gt;3、two single number&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;非空数组，有2个元素出现1次，其余出现2次，求出现1次的那2个数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 4, 2, 1, 3, 5, 6, 2,3, 5]

output: [4, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [2, 1, 3, 2]

output: [1, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;int&amp;gt; twoSingleNumber(const vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    int n1xn2 = 0;
    for (auto num: nums) {
        n1xn2 ^= num;
    }

    int rightMostSetBit = 1;
    while ((rightMostSetBit &amp;amp; n1xn2) == 0) {
        rightMostSetBit = rightMostSetBit &amp;lt;&amp;lt; 1;
    }

    int num1 = 0, num2 = 0;
    for (int num: nums) {
        if ((num &amp;amp; rightMostSetBit) != 0) {
            num1 ^= num;
        } else {
            num2 ^= num;
        }
    }
    return vector&amp;lt;int&amp;gt;{num1, num2};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;4-complement-of-base-10-number&#34;&gt;4、complement of base 10 number&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;10进制的正整数，转换为二进制，按位取反后，转化为10进制&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: 8

output: 7
    
explanations: 8 -&amp;gt; 1000 -&amp;gt; 0111 -&amp;gt; 7
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: 10

output: 5
    
explanations: 10 -&amp;gt; 1010 -&amp;gt; 0101 -&amp;gt; 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int bitwiseComplement(int num) {
    int bitCount = 0;
    int n = num;
    while (n &amp;gt; 0) {
        bitCount++;
        n = n &amp;gt;&amp;gt; 1;
    }

    int all_bits_set = pow(2, bitCount) - 1;
    return num ^ all_bits_set;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;b&lt;/em&gt;)，b:整数二进制的位数&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;5-flip-matrix&#34;&gt;5、flip matrix&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;没看懂&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-12 Modified Binary Search</title>
      <link>/code/pattern/modified-binary-search/</link>
      <pubDate>Sat, 23 May 2020 17:55:06 +0800</pubDate>
      <guid>/code/pattern/modified-binary-search/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;p&gt;在数组，链表，矩阵中查找特定的值&lt;/p&gt;

&lt;h2 id=&#34;2-order-agnostic-binary-search&#34;&gt;2、order-agnostic binary search&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定有序数组（不知升序，降序，有可能有重复）和Key值，判断key是否在数组中，返回其索引&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[4, 6, 10] ,key=10
    
output: 2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 2, 3, 4, 6] ,key=4
    
output: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int search(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int key) {
    int start = 0;
    int end = arr.size()-1;
    bool isAscending = arr[start] &amp;lt; arr[end];

    while (start &amp;lt;= end) {
        int mid = start + (end - start) / 2;

        if (key == arr[mid]) {
            return mid;
        }
        if (isAscending) {
            if (key &amp;lt; arr[mid]) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        } else {
            if (key &amp;gt; arr[mid]) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
    }
    return -1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./2-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(log&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;3-ceiling-of-a-number&#34;&gt;3、ceiling of a number&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定升序序列和key值，求ceiling of key（数组中最小的大于等于key的数），返回其索引&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[4, 6, 10] ,key=6
 
output:	1

explanations:	6-&amp;gt;index=1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 3, 8, 10, 15] ,key=12
 
output:	4

explanations:	15-&amp;gt;index=4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int searchCeilingOfANumber(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int key) {
    if (key &amp;gt; arr[arr.size() - 1]) {
        return -1;
    }

    int start = 0;
    int end = arr.size() - 1;
    while (start &amp;lt;= end) {
        int mid = start + (end - start) / 2;
        if (key &amp;lt; arr[mid]) {
            end = mid - 1;
        } else if (key &amp;gt; arr[mid]) {
            start = mid + 1;
        } else {
            return mid;
        }
    }
    //当循环结束时，start=end+1,没有找到等于key的元素，此时arr[start]
    //就是最小的大于等于key的值，
    //等同于 return end+1;
    return start;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./2-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(log&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;4-next-letter&#34;&gt;4、next letter&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定包含小写字母的升序序列和key，寻找最小的字母使得大于key，假定序列为循环序列（当key大于等于arr[arr.size()-1]时，返回arr[0]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[&#39;a&#39;,&#39;c&#39;,&#39;f&#39;,&#39;h&#39;] ,key=&#39;f&#39;
 
output:	&#39;h&#39;

explanations:	&#39;h&#39; &amp;gt; &#39;f&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[&#39;a&#39;,&#39;c&#39;,&#39;f&#39;,&#39;h&#39;] ,key=&#39;m&#39;
 
output:	&#39;a&#39;

explanations:循环后	&#39;a&#39; &amp;gt; &#39;m&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;char searchNextLetter(const vector&amp;lt;char&amp;gt; &amp;amp;letter, char key) {
    int n = letter.size();

    if (key &amp;lt; letter[0] || key &amp;gt;= letter[n - 1]) {
        return letter[0];
    }

    int start = 0;
    int end = n - 1;
    while (start &amp;lt;= end) {
        int mid = start + (end - start) / 2;
        if (key &amp;lt; letter[mid]) {
            end = mid - 1;
        } else {
            start = mid + 1;
        }
    }
    //start=end+1
    return letter[start];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(log&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;5-number-range&#34;&gt;5、number range&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定升序序列和key值，求key值得范围（key出现在序列中起始结束的索引）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[4, 6 ,6 ,6 ,9] ,key=6
 
output:	[1 ,3]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 3, 8, 10, 15] ,key=10
 
output:	[3 ,3]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 3, 8, 10, 15] ,key=112
 
output:	[-1 ,-1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int search(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int key, bool findMaxIndex) {
    //findMaxIndex:是否找最大索引，每次search 只能找最大索引或最小索引
    int keyIndex = -1;
    int start = 0;
    int end = arr.size() - 1;
    while (start &amp;lt;= end) {
        int mid = start + (end - start) / 2;
        if (key &amp;lt; arr[mid]) {
            end = mid - 1;
        } else if (key &amp;gt; arr[mid]) {
            start = mid + 1;
        } else {
            //记录最大索引或最小索引
            keyIndex = mid;
            if (findMaxIndex) {
                //向后找最大索引
                start = mid + 1;
            } else {
                //向前找最大索引
                end = mid - 1;
            }
        }
    }
    return keyIndex;
}

pair&amp;lt;int, int&amp;gt; findRange(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int key) {
    pair&amp;lt;int, int&amp;gt; result(-1, -1);
    result.first = search(arr, key, false);
    if (result.first != -1) {
        result.second = search(arr, key, true);
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(log&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;6-search-in-a-sorted-infinite-array&#34;&gt;6、search in a sorted infinite array&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定未知个数的升序序列和key，判断key是否在其中&lt;/p&gt;

&lt;p&gt;待看&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;7-minimum-difference-element&#34;&gt;7、minimum difference element&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定升序序列和key，求序列中与key 的差的绝对值差距最小的数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[4, 6 ,10] ,key=7
 
output:	6
    
explanations:|6-7|=1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[4, 6 ,10] ,key=4
 
output:	4
    
explanations:|4-4|=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int searchMinimumDifference(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int key) {
    if (key &amp;lt; arr[0]) {
        return arr[0];
    }
    if (key &amp;gt; arr[arr.size() - 1]) {
        return arr[arr.size() - 1];
    }

    int start = 0;
    int end = arr.size() - 1;
    while (start &amp;lt;= end) {
        int mid = start + (end - start) / 2;
        if (key &amp;lt; arr[mid]) {
            end = mid - 1;
        } else if (key &amp;gt; arr[mid]) {
            start = mid + 1;
        } else {
            return arr[mid];
        }
    }
    if ((arr[start] - key) &amp;lt; (key - arr[end])) {
        return arr[start];
    }
    return arr[end];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(log&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;8-bitonic-array-maximum&#34;&gt;8、bitonic array maximum&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求bitonic数组中的最大值&lt;/p&gt;

&lt;p&gt;bitonic array：先单调递增，在单调递减，arr[i] != arr[i+1]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 3, 8, 12, 4, 2]

output:	12
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [3, 8, 3, 1]

output:	8
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 3, 8, 12]

output:	12
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [10, 9 , 8]

output:	10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int finMax(const vector&amp;lt;int&amp;gt; &amp;amp;arr) {
    int start = 0;
    int end = arr.size() - 1;
    while (start &amp;lt; end) {
        int mid = start + (end - start) / 2;
        //当arr[mid]&amp;gt;arr[mid+1]，位于后半段，最大值在mid前面
        if (arr[mid] &amp;gt; arr[mid + 1]) {
            end = mid;
        } else {
            //位于前半段，最大值在mid+1后面
            start = mid + 1;
        }
    }
    //循环结束start==end
    return arr[start];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(log&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;9-search-bitonic-array&#34;&gt;9、search bitonic array&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定bitonic数组和key值，判断key是否在其中，返回索引&lt;/p&gt;

&lt;p&gt;bitonic array：先单调递增，在单调递减，arr[i] != arr[i+1]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 3, 8, 4, 3],key=4

output:	3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [3, 8, 3, 1],key=8

output:	1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 3, 8, 12],key=12

output:	3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [10, 9 , 8],key=10

output:	0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int binarySearch(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int key, int start, int end) {

    bool isAscending = arr[start] &amp;lt; arr[end];

    while (start &amp;lt;= end) {
        int mid = start + (end - start) / 2;

        if (key == arr[mid]) {
            return mid;
        }
        if (isAscending) {
            if (key &amp;lt; arr[mid]) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        } else {
            if (key &amp;gt; arr[mid]) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
    }
    return -1;
}

//返回最大值得索引
int finMax(const vector&amp;lt;int&amp;gt; &amp;amp;arr) {
    int start = 0;
    int end = arr.size() - 1;
    while (start &amp;lt; end) {
        int mid = start + (end - start) / 2;
        //当arr[mid]&amp;gt;arr[mid+1]，位于后半段，最大值在mid前面
        if (arr[mid] &amp;gt; arr[mid + 1]) {
            end = mid;
        } else {
            //位于前半段，最大值在mid+1后面
            start = mid + 1;
        }
    }
    //循环结束start==end
    return start;
}

int search(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int key) {
    int maxIndex = finMax(arr);
    //前半段
    int keyIndex = binarySearch(arr, key, 0, maxIndex);
    if (keyIndex != -1) {
        return keyIndex;
    }
    //后半段
    return binarySearch(arr, key, maxIndex + 1, arr.size() - 1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(log&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;10-search-in-rotated-array&#34;&gt;10、search in rotated array&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定rotated array(不含重复)和key，判断key是否在其中，返回索引&lt;/p&gt;

&lt;p&gt;rotated array：旋转数组，有序数组旋转了有理数个位置，生成两段递增子数组&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./10-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int search(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int key) {
    int start = 0;
    int end = arr.size() - 1;

    while (start &amp;lt;= end) {
        int mid = start + (end - start) / 2;
        if (arr[mid] == key) {
            return mid;
        }
        //左开左开右闭区间
        //[start,mid]之间有序，较长段有序序列在前
        if (arr[start] &amp;lt;= arr[mid]) {
            //判断key在[start,mid]之间，还是在之后
            if (key &amp;gt;= arr[start] &amp;amp;&amp;amp; key &amp;lt; arr[mid]) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
            //[mid，end]之间有序，较长段有序序列在后
        } else {
            if (key &amp;gt; arr[mid] &amp;amp;&amp;amp; key &amp;lt;= arr[end]) {
                //判断key在[mid，end]之间，还是在之后
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
    }
    return -1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./10-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(log&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;p&gt;相似问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;给定rotated array(含重复)和key，判断key是否在其中，返回索引&lt;/p&gt;

&lt;p&gt;rotated array：旋转数组，有序数组旋转了有理数个位置，生成两段递增子数组&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./10-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int searchDuplicate(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int key) {
    int start = 0;
    int end = arr.size() - 1;

    while (start &amp;lt;= end) {
        int mid = start + (end - start) / 2;
        if (arr[mid] == key) {
            return mid;
        }
        //左开左开右闭区间

        //当arr[start]=arr[mid]==arr[end]时，无法分辨数组那一部分是有序的
        if((arr[start]==arr[mid])&amp;amp;&amp;amp;(arr[end]==arr[mid])){
            //跳过一位
            start++;
            end--;

            //[start,mid]之间有序，较长段有序序列在前
        }else if (arr[start] &amp;lt;= arr[mid]) {
            //判断key在[start,mid]之间，还是在之后
            if (key &amp;gt;= arr[start] &amp;amp;&amp;amp; key &amp;lt; arr[mid]) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
            
            //[mid，end]之间有序，较长段有序序列在后
        } else {
            if (key &amp;gt; arr[mid] &amp;amp;&amp;amp; key &amp;lt;= arr[end]) {
                //判断key在[mid，end]之间，还是在之后
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
    }
    return -1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(log&lt;em&gt;N&lt;/em&gt;)，最坏： &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;11-rotation-count&#34;&gt;11、rotation count&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求旋转数组(无重复)旋转了几个位置&lt;/p&gt;

&lt;p&gt;等同于求最小值的索引&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./11-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./11-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int countRotations(const vector&amp;lt;int&amp;gt; &amp;amp;arr) {
    int start = 0;
    int end = arr.size() - 1;

    while (start &amp;lt; end) {
        int mid = start + (end - start) / 2;

        //最小值前面全是比它大的元素
        if (mid &amp;lt; end &amp;amp;&amp;amp; arr[mid] &amp;gt; arr[mid + 1]) {
            return mid +1;
        }
        if (mid &amp;gt; start &amp;amp;&amp;amp; arr[mid - 1] &amp;gt; arr[mid]) {
            return mid;
        }

        //左侧有序，最小值在右面
        if (arr[start] &amp;lt; arr[mid]) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(log&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;p&gt;相似问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;求旋转数组(有重复)旋转了几个位置&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./11-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int countRotationsDuplicate(const vector&amp;lt;int&amp;gt; &amp;amp;arr) {
    int start = 0;
    int end = arr.size() - 1;

    while (start &amp;lt; end) {
        int mid = start + (end - start) / 2;

        //最小值前面全是比它大的元素
        if (mid &amp;lt; end &amp;amp;&amp;amp; arr[mid] &amp;gt; arr[mid + 1]) {
            return mid + 1;
        }
        if (mid &amp;gt; start &amp;amp;&amp;amp; arr[mid - 1] &amp;gt; arr[mid]) {
            return mid;
        }

        //arr[start] = arr[end] =arr[mid]，挑一步
        if (arr[start] == arr[end] &amp;amp;&amp;amp; arr[end] == arr[mid]) {
            if (arr[start] &amp;gt; arr[start + 1]) {
                return start + 1;
            }
            start++;
            if (arr[end - 1] &amp;gt; arr[end]) {
                return end;
            }
            end--;

            //左侧有序，最小值在右面
        } else if (arr[start] &amp;lt; arr[mid] || (arr[start] == arr[mid]) &amp;amp;&amp;amp; (arr[mid] &amp;gt; arr[end])) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(log&lt;em&gt;N&lt;/em&gt;)，最坏： &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>pattern-11 Subsets</title>
      <link>/code/pattern/subsets/</link>
      <pubDate>Sat, 23 May 2020 17:53:35 +0800</pubDate>
      <guid>/code/pattern/subsets/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;p&gt;解决排列和组合问题，使用广度优先算法&lt;/p&gt;

&lt;h2 id=&#34;2-subsets&#34;&gt;2、subsets&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定不含重复元素的集合，求其所有不同的子集&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 3]

output:	[], [1], [3], [1, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 5, 3]

output:	[], [1], [3], [5] ,[1, 3], [1, 5], [3 ,5],[1 ,3 ,5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; findSubsets(const vector&amp;lt;int&amp;gt;&amp;amp;nums){
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsets;
    subsets.push_back(vector&amp;lt;int&amp;gt;());
	//取已经有的子集，插入新的元素，生成新的子集
    for(auto currentNumber: nums){
        int n=subsets.size();
        for(int i=0;i&amp;lt;n;i++){
            vector&amp;lt;int&amp;gt; set(subsets[i]);
            set.push_back(currentNumber);
            subsets.push_back(set);
        }
    }
    return subsets;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(2^&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(2^&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;3-subsets-with-duplicates&#34;&gt;3、subsets with Duplicates&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定含重复元素的集合，求其所有不同的子集&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 3, 3]

output:	[], [1], [3], [1, 3], [3, 3], [1, 3, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 5, 3, 3]

output:	[], [1], [3], [5], [1, 5] ,[1, 3], [1, 5, 3], [3, 3], [1, 3, 3],[5 ,3], [3,3,5],[1, 5, 3, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; findSubsets(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    sort(nums.begin(), nums.end());
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsets;
    subsets.push_back(vector&amp;lt;int&amp;gt;());
    int startIndex = 0;
    int endIndex = 0;
    
    //当遇到重复的元素时，取上一步生成的子集，插入新的元素，生成新的子集
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        startIndex = 0;
        if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) {
            startIndex = endIndex + 1;
        }
        endIndex = subsets.size() - 1;
        for (int j = startIndex; j &amp;lt;= endIndex; j++) {
            vector&amp;lt;int&amp;gt; set(subsets[j]);
            set.push_back(nums[i]);
            subsets.push_back(set);
        }
    }
    return subsets;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./3-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(2^&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(2^&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;4-permutations&#34;&gt;4、permutations&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定不含重复元素的集合，求其所有排列&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 3, 5]

output:	[1, 3, 5], [1 ,5, 3], [3, 5, 1], [3, 1, 5], [5, 1, 3], [5, 3, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; findPermutations(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;
    queue&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permutations;

    permutations.push(vector&amp;lt;int&amp;gt;());
    for (auto currentNumber:nums) {
        int n = permutations.size();
        for (int i = 0; i &amp;lt; n; i++) {
            vector&amp;lt;int&amp;gt; oldPermutation = permutations.front();
            permutations.pop();
            
            //添加currentNumber ，到所有的position
            for (int j = 0; j &amp;lt;= oldPermutation.size(); j++) {
                vector&amp;lt;int&amp;gt; newPermutations(oldPermutation);
                newPermutations.insert(newPermutations.begin() + j, currentNumber);

                if (newPermutations.size() == nums.size()) {
                    result.push_back(newPermutations);
                } else {
                    permutations.push(newPermutations);
                }
            }
        }
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./4-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;递归的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void generatePermutationsRecursive(vector&amp;lt;int&amp;gt; &amp;amp;nums, int numsIndex,
                                   vector&amp;lt;int&amp;gt; &amp;amp;currentPermutation, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;result) {
    if (numsIndex == nums.size()) {
        result.push_back(currentPermutation);
    } else {
        for (int i = 0; i &amp;lt;= currentPermutation.size(); i++) {
            vector&amp;lt;int&amp;gt; newPermutation(currentPermutation);
            newPermutation.insert(newPermutation.begin() + i, nums[numsIndex]);
            generatePermutationsRecursive(nums, numsIndex + 1, newPermutation, result);

        }
    }
}

vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; generatePermutation(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;
    vector&amp;lt;int&amp;gt; currentPermutation;
    
    generatePermutationsRecursive(nums, 0, currentPermutation, result);
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; * &lt;em&gt;N !&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; * &lt;em&gt;N !&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;5-string-permutation-by-changing-case&#34;&gt;5、string permutation by changing case&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定字符串，保留原序列，只改变字母的大小写，求所有排列&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;ad52&amp;quot;
  
ouput:	&amp;quot;ad52&amp;quot; ,&amp;quot;Ad52&amp;quot;, &amp;quot;aD52&amp;quot;, &amp;quot;AD52&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;ab7c&amp;quot;
  
ouput:	&amp;quot;ab7c&amp;quot;, &amp;quot;Ab7c&amp;quot;,&amp;quot;aB7c&amp;quot;,&amp;quot;ab7C&amp;quot;,&amp;quot;AB7c&amp;quot;,&amp;quot;Ab7C&amp;quot;,&amp;quot;aB7C&amp;quot;,&amp;quot;AB7C&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;string&amp;gt; findLetterCaseStringPermutation(const string &amp;amp;str) {
    vector&amp;lt;string&amp;gt; permutations;
    if (str == &amp;quot;&amp;quot;) {
        return permutations;
    }
    permutations.push_back(str);

    for (int i = 0; i &amp;lt; str.length(); i++) {
        if (isalpha(str[i])) {
            int n = permutations.size();
            for (int j = 0; j &amp;lt; n; j++) {
                vector&amp;lt;char&amp;gt; chs(permutations[j].begin(), permutations[j].end());
                if (isupper(chs[i])) {
                    chs[i] = tolower(chs[i]);
                } else {
                    chs[i] = toupper(chs[i]);
                }

                permutations.push_back(string(chs.begin(), chs.end()));
            }
        }
    }
    return permutations;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./5-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; * 2^ &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; * 2^ &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;h2 id=&#34;6-balanced-parentheses&#34;&gt;6、balanced parentheses&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定N，求n对（）的合理的组合&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: N=2
    
output:	(()) ,()()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: N=3
    
output:	((())) ,()()(), (())(), ()(()), ((),())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct Parenthesese {
    string str;
    int openCount;
    int closeCount;

    Parenthesese(const string &amp;amp;str, int openCount, int closeCount) : str(str), openCount(openCount),
                                                                     closeCount(closeCount) {};
};

vector&amp;lt;string&amp;gt; generateValidParentheses(int num) {
    vector&amp;lt;string&amp;gt; result;
    queue&amp;lt;Parenthesese&amp;gt; queue;
    queue.push({&amp;quot;&amp;quot;, 0, 0});

    while (!queue.empty()) {
        Parenthesese ps = queue.front();
        queue.pop();

        if (ps.openCount == num &amp;amp;&amp;amp; ps.closeCount == num) {
            result.push_back(ps.str);
        } else {
            if (ps.openCount &amp;lt; num) {
                queue.push({ps.str + &amp;quot;(&amp;quot;, ps.openCount + 1, ps.closeCount});
            }
            if (ps.openCount &amp;gt; ps.closeCount) {
                queue.push({ps.str + &amp;quot;)&amp;quot;, ps.openCount, ps.closeCount + 1});
            }
        }
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :&lt;img src=&#34;./6-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; * 2^ &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;递归方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void generateValidParenthesesRecursive(int num, int openCount, int closeCount, int stringIndex,
                                       vector&amp;lt;char&amp;gt; &amp;amp;parenthesesString, vector&amp;lt;string&amp;gt; &amp;amp;result) {
    if (openCount == num &amp;amp;&amp;amp; closeCount == num) {
        result.push_back(string(parenthesesString.begin(), parenthesesString.end()));

    } else {
        if (openCount &amp;lt; num) {
            parenthesesString[stringIndex] = &#39;(&#39;;
            generateValidParenthesesRecursive(num, openCount+1, closeCount , stringIndex + 1, parenthesesString,
                                              result);
        }
        if (openCount &amp;gt; closeCount) {
            parenthesesString[stringIndex] = &#39;)&#39;;
            generateValidParenthesesRecursive(num, openCount, closeCount + 1, stringIndex + 1, parenthesesString,
                                              result);
        }
    }
}

vector&amp;lt;string&amp;gt; generateValidParentheses2(int num) {
    vector&amp;lt;string&amp;gt; result;
    vector&amp;lt;char&amp;gt; parenthesesString(2 * num);
    generateValidParenthesesRecursive(num, 0, 0, 0, parenthesesString, result);
    return result;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;7-unique-generalized-abbreviations&#34;&gt;7、unique generalized abbreviations&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;没看懂题目&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;8-evaluate-expression&#34;&gt;8、evaluate expression&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定只包含0-9和+ - *的表达式，计算表达式加上括号后所有合理的运算结果&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;1+2*3&amp;quot;
   
output:	7,9
  
explanations: 1+(2*3)=7, (1+2)*3=9
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;2*3-4-5&amp;quot;
   
output:	8, -12, 7 ,-7 ,-3
  
explanations: 2*(3-(4-5)=8, 2*(3-4-5)=-12, 2*3-(4-5)=7, 2*(3-4)-5=-7, (2*3)-4-5=-3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;int&amp;gt; diffWaysToEvaluateExpression(const string &amp;amp;input) {
    vector&amp;lt;int&amp;gt; result;
    //有两个字符串a、b, 判断a字符串是否包含b字符串，用到string库中的find函数与npos参数。
    //string::npos参数：npos 是一个常数，用来表示不存在的位置
    if (input.find(&#39;+&#39;, 0) == string::npos &amp;amp;&amp;amp;
        input.find(&amp;quot;-&amp;quot;) == string::npos &amp;amp;&amp;amp; input.find(&amp;quot;*&amp;quot;) == string::npos) {

    }
    if (input.find(&amp;quot;+&amp;quot;) == string::npos &amp;amp;&amp;amp;
        input.find(&amp;quot;-&amp;quot;) == string::npos &amp;amp;&amp;amp; input.find(&amp;quot;*&amp;quot;) == string::npos) {

        result.push_back(stoi(input));
    } else {

        for (int i = 0; i &amp;lt; input.length(); i++) {
            char chr = input[i];
            if (!isdigit(chr)) {
                vector&amp;lt;int&amp;gt; leftParts = diffWaysToEvaluateExpression(input.substr(0, i));
                vector&amp;lt;int&amp;gt; rightParts = diffWaysToEvaluateExpression(input.substr(i + 1));
                for (auto part1:leftParts) {
                    for (auto part2:rightParts) {
                        if (chr == &#39;+&#39;) {
                            result.push_back(part1 + part2);
                        } else if (chr == &#39;-&#39;) {
                            result.push_back(part1 - part2);
                        } else if (chr == &#39;*&#39;) {
                            result.push_back(part1 * part2);
                        }
                    }
                }
            }

        }
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : 实际：&lt;img src=&#34;./6-1.png&#34; alt=&#34;&#34; /&gt;  估计：&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; * 2^ &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : 实际：&lt;img src=&#34;./6-1.png&#34; alt=&#34;&#34; /&gt;估计：O*( 2^ &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;节省空间的方法：&lt;/p&gt;

&lt;p&gt;有大量重复计算的值，用哈希表存储中间值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;unordered_map&amp;lt;string, vector&amp;lt;int&amp;gt;&amp;gt; map = unordered_map&amp;lt;string, vector&amp;lt;int&amp;gt;&amp;gt;();

vector&amp;lt;int&amp;gt; diffWaysToEvaluateExpression2(const string &amp;amp;input) {
    if (map.find(input) != map.end()) {
        return map[input];
    }
    vector&amp;lt;int&amp;gt; result;
    if (input.find(&amp;quot;+&amp;quot;) == string::npos &amp;amp;&amp;amp;
        input.find(&amp;quot;-&amp;quot;) == string::npos &amp;amp;&amp;amp; input.find(&amp;quot;*&amp;quot;) == string::npos) {

        result.push_back(stoi(input));
    } else {

        for (int i = 0; i &amp;lt; input.length(); i++) {
            char chr = input[i];
            if (!isdigit(chr)) {
                vector&amp;lt;int&amp;gt; leftParts = diffWaysToEvaluateExpression(input.substr(0, i));
                vector&amp;lt;int&amp;gt; rightParts = diffWaysToEvaluateExpression(input.substr(i + 1));
                for (auto part1:leftParts) {
                    for (auto part2:rightParts) {
                        if (chr == &#39;+&#39;) {
                            result.push_back(part1 + part2);
                        } else if (chr == &#39;-&#39;) {
                            result.push_back(part1 - part2);
                        } else if (chr == &#39;*&#39;) {
                            result.push_back(part1 * part2);
                        }
                    }
                }
            }
        }
    }
    map[input] = result;
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;9-structurally-unique-binary-search-trees&#34;&gt;9、structurally unique binary search trees&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定N，求节点值为1-n的二叉查找树&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./9-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./9-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;TreeNode *&amp;gt; findUniqueTreeRecursive(int start, int end) {
    vector&amp;lt;TreeNode *&amp;gt; result;

    if (start &amp;gt; end) {
        result.push_back(NULL);
        return result;
    }
    for (int i = start; i &amp;lt;= end; i++) {
        vector&amp;lt;TreeNode *&amp;gt; leftSubsets = findUniqueTreeRecursive(start, i - 1);
        vector&amp;lt;TreeNode *&amp;gt; rightSubsets = findUniqueTreeRecursive(i + 1, end);
        for (auto leftTree:leftSubsets) {
            for (auto rightTree :rightSubsets) {
                TreeNode *root = new TreeNode(i);
                root-&amp;gt;left = leftTree;
                root-&amp;gt;right = rightTree;
                result.push_back(root);
            }
        }
    }
    return result;
}

vector&amp;lt;TreeNode *&amp;gt; findUniqueTrees(int n) {
    if (n &amp;lt;= 0) {
        return vector&amp;lt;TreeNode *&amp;gt;();

    } else {
        return findUniqueTreeRecursive(1, n);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : 实际：&lt;img src=&#34;./6-1.png&#34; alt=&#34;&#34; /&gt;  估计：&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; * 2^ &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : 实际：&lt;img src=&#34;./6-1.png&#34; alt=&#34;&#34; /&gt;估计：O*( 2^ &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;h2 id=&#34;10-count-of-structurally-unique-binary-search-tree&#34;&gt;10、count of structurally unique binary search tree&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定N，求节点值为1-n的二叉查找树的个数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./10-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int countTrees(int n) {
    if (n &amp;lt;= 1) return 1;
    int count = 0;
    for (int i = 1; i &amp;lt;= n; i++) {
        int countOfLeftSubtrees = countTrees(i - 1);
        int countOfRightSubtrees = countTrees(n - i);
        count += countOfLeftSubtrees * countOfRightSubtrees;
    }
    return count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : 实际：&lt;img src=&#34;./6-1.png&#34; alt=&#34;&#34; /&gt;  估计：&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; * 2^ &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : 实际：&lt;img src=&#34;./6-1.png&#34; alt=&#34;&#34; /&gt;估计：O*( 2^ &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;节省空间的方法：&lt;/p&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;unordered_map&amp;lt;int, int&amp;gt; map = unordered_map&amp;lt;int, int&amp;gt;();

int countTrees2(int n) {
    if (map.find(n) != map.end()) {
        return map[n];
    }
    if (n &amp;lt;= 1) return 1;
    int count = 0;
    for (int i = 1; i &amp;lt;= n; i++) {
        int countOfLeftSubtrees = countTrees(i - 1);
        int countOfRightSubtrees = countTrees(n - i);
        count += countOfLeftSubtrees * countOfRightSubtrees;
    }
    map[n] = n;
    return count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : O&lt;em&gt;(&lt;/em&gt; &lt;em&gt;N&lt;/em&gt; ^ 2)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-10 Two Heaps</title>
      <link>/code/pattern/two-heaps/</link>
      <pubDate>Sat, 23 May 2020 17:53:19 +0800</pubDate>
      <guid>/code/pattern/two-heaps/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;p&gt;给定一组可以划分成两个部分的元素，要求我们求一部分的最小元素，另一部分的最大元素，用two heaps ：Min Heap和Max Heap，可以解决这类的问题，。&lt;/p&gt;

&lt;h2 id=&#34;2-find-the-median-of-a-number-stream&#34;&gt;2、find the median of a number stream&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;设计一个类，能够计算数据流中的中位数，类必须包含两个函数：&lt;/p&gt;

&lt;p&gt;insertNum(int num) :存储数据&lt;/p&gt;

&lt;p&gt;findMedian() : 返回所有存储进类的数据流的中位数&lt;/p&gt;

&lt;p&gt;如果数据为奇数个，则中位数为中间两个数之和&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./2-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class MedianOfStream{
    priority_queue&amp;lt;int&amp;gt; maxHeap;
    priority_queue&amp;lt;int,vector&amp;lt;int&amp;gt;,greater&amp;lt;int&amp;gt;&amp;gt; minHeap;

    void insertNum(int num){
        //小数存储在大顶堆，大数存储在小顶堆
        //大顶堆个数==[小顶堆，小顶堆+1]
        if(maxHeap.empty()||maxHeap.top()&amp;gt;=num){
            maxHeap.push(num);
        } else{
            minHeap.push(num);
        }


        if(maxHeap.size()&amp;gt;minHeap.size()+1){
            minHeap.push(maxHeap.top());
            maxHeap.pop();
        }else if(maxHeap.size()&amp;lt;minHeap.size()){
            maxHeap.push(minHeap.top());
            minHeap.pop();
        }
    }

    double findMedian(){
        if(maxHeap.size()==minHeap.size()){
            return (maxHeap.top()+minHeap.top())/2.0
        }
        return maxHeap.top()
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-sliding-window-median&#34;&gt;3、sliding window median&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定数组和K值，求所有长度为k的连续子数组的中位数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 2, -1, 3, 5]， k=2
    
output:	[1.5, 0.5, 1.0, 4.0]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 2, -1, 3, 5]， k=3
    
output:	[1.0, 2.0, 3.0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;同上 + 滑动窗口 + 增加queue删除特定的值？
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;4-maximun-capital&#34;&gt;4、maximun capital&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定一组投资项目，已知项目所需投资资金，项目盈利、初始资金、投资的项目个数，求最大剩余的资金&lt;/p&gt;

&lt;p&gt;先前投资的（盈利+本钱）可作为后续投资的资金 ,&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	project capitals:[0, 1 ,2]
		project profits:[1, 2, 3]
		initial capital:1
		number of project:2
            
output:	6
    
explanations：
    1、先投资第2个(所需资金1，盈利2)项目。得到1+2=3(本金+盈利)投资基金
    2、再投资第3个(所需资金2，盈利3)项目。得到3+3=6(本金+盈利)投资基金
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	project capitals:[0, 1 ,2, 3]
		project profits:[1, 2, 3, 5]
		initial capital:0
		number of project:3
            
output:	8
    
explanations：
    1、先投资第1个(所需资金0，盈利1)项目。得到0+1=1(本金+盈利)投资基金
    2、再投资第2个(所需资金1，盈利2)项目。得到1+2=3(本金+盈利)投资基金
    3、再投资第4个(所需资金3，盈利5)项目。得到3+5=8(本金+盈利)投资基金
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_greater_capital {
    bool operator()(const pair&amp;lt;int, int&amp;gt; &amp;amp;x, const pair&amp;lt;int, int&amp;gt; &amp;amp;y) {
        return x.first &amp;gt; y.first;
    }
};

struct cmp_smaller_profit {
    bool operator()(const pair&amp;lt;int, int&amp;gt; &amp;amp;x, const pair&amp;lt;int, int&amp;gt; &amp;amp;y) {
        return x.first &amp;lt; y.first;
    }
};

int maximumCapitals(const vector&amp;lt;int&amp;gt; &amp;amp;capital, const vector&amp;lt;int&amp;gt; &amp;amp;profits, int numOfProject, int initialCapital) {
    int n = profits.size();
    priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;, cmp_greater_capital&amp;gt; minCapitalHeap;

    priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;, cmp_smaller_profit&amp;gt; maxProfitHeap;


    for (int i = 0; i &amp;lt; n; i++) {
        minCapitalHeap.push(make_pair(capital[i], i));
    }

    int result = initialCapital;

    for (int i = 0; i &amp;lt; numOfProject; i++) {
        while (!minCapitalHeap.empty() &amp;amp;&amp;amp; minCapitalHeap.top().first &amp;lt;= result) {
            auto capitalIndex = minCapitalHeap.top().second;
            minCapitalHeap.pop();
            maxProfitHeap.push({profits[capitalIndex], capitalIndex});
        }

        if (maxProfitHeap.empty()) {
            break;
        }

        result += maxProfitHeap.top().first;
        maxProfitHeap.pop();
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N log N&lt;/em&gt; + &lt;em&gt;K log K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;5-next-interval&#34;&gt;5、next interval&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;没看懂&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-9 Tree Depth First Search</title>
      <link>/code/pattern/tree-depth-first-search/</link>
      <pubDate>Sat, 23 May 2020 17:51:56 +0800</pubDate>
      <guid>/code/pattern/tree-depth-first-search/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;深度遍历，树的一种遍历方式，在遍历过程中用递归或栈记录所有父节点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;2-binary-tree-path-sum&#34;&gt;2、binary tree path sum&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定二叉树和数S，判断是否有从根到叶子的路径，使得此路径所有节点的和等于S&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./2-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool hasPath(TreeNode *root, int sum) {
    if (root == NULL) {
        return false;
    }
    if (root-&amp;gt;val == sum &amp;amp;&amp;amp; root-&amp;gt;left == NULL &amp;amp;&amp;amp; root-&amp;gt;right == NULL) {
        return true;
    }

    return hasPath(root-&amp;gt;left, sum - root-&amp;gt;val) || 
           hasPath(root-&amp;gt;right, sum - root-&amp;gt;val);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./2-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h2 id=&#34;3-all-paths-for-a-sum&#34;&gt;3、all Paths for a sum&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定二叉树和数S，求所有从根到叶子的路径，路径所有节点的和等于S&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./3-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;
void findPathRecursive(TreeNode *currentNode, int sum,
           vector&amp;lt;int&amp;gt; &amp;amp;currentPath, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;allPaths) {

    if (currentNode == NULL) {
        return;
    }

    currentPath.push_back(currentNode-&amp;gt;val);
    if (currentNode-&amp;gt;val == sum &amp;amp;&amp;amp; currentNode-&amp;gt;left == NULL &amp;amp;&amp;amp; currentNode-&amp;gt;right == NULL) {
        allPaths.push_back(vector&amp;lt;int&amp;gt;(currentPath));

    } else {
        findPathRecursive(currentNode-&amp;gt;left, sum - currentNode-&amp;gt;val, currentPath, allPaths);
        
        findPathRecursive(currentNode-&amp;gt;right, sum - currentNode-&amp;gt;val, currentPath, allPaths);
    }
    //为了回溯,删除currentNode
    currentPath.pop_back();
}

vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; findPaths(TreeNode *root, int sum) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; allPaths;
    vector&amp;lt;int&amp;gt; currentPath;

    findPathRecursive(root, sum, currentPath, allPaths);
    
    return allPaths;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;^2)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; log&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;相似问题1：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;求所有根到叶子的路径&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void findAllPathRecursive(TreeNode *currentNode,
                       vector&amp;lt;int&amp;gt; &amp;amp;currentPath, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;allPaths) {

    if (currentNode == NULL) {
        return;
    }
    currentPath.push_back(currentNode-&amp;gt;val);

    if ( currentNode-&amp;gt;left == NULL &amp;amp;&amp;amp; currentNode-&amp;gt;right == NULL) {
        allPaths.push_back(vector&amp;lt;int&amp;gt;(currentPath));

    }else{
        findAllPathRecursive(currentNode-&amp;gt;left,  currentPath, allPaths);
        findAllPathRecursive(currentNode-&amp;gt;right, currentPath, allPaths);
    }
    
    //为了回溯，删除currentNode,
    currentPath.pop_back();
}

vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; findAllPaths(TreeNode *root) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; allPaths;
    vector&amp;lt;int&amp;gt; currentPath;

    findAllPathRecursive(root,currentPath, allPaths);

    return allPaths;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相似问题2：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;和最大的路径&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void findMaxPathRecursive(TreeNode *currentNode,
                          int &amp;amp;currentSum, int &amp;amp;maxPathSum) {

    if (currentNode == NULL) {
        return;
    }
    currentSum += currentNode-&amp;gt;val;

    if (currentNode-&amp;gt;left == NULL &amp;amp;&amp;amp; currentNode-&amp;gt;right == NULL) {
        maxPathSum = max(maxPathSum, currentSum);

    } else {
        findMaxPathRecursive(currentNode-&amp;gt;left, currentSum, maxPathSum);
        findMaxPathRecursive(currentNode-&amp;gt;right, currentSum, maxPathSum);
    }

    //为了回溯，删除currentNode-val,
    currentSum -= currentNode-&amp;gt;val;
}

int findMaxPath(TreeNode *root) {
    int maxPathSum = INT_MIN;
    int currentSum = 0;

    findMaxPathRecursive(root, currentSum, maxPathSum);

    return maxPathSum;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-sum-of-path-numbers&#34;&gt;4、sum of path numbers&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定二叉树，节点值在 0 - 9，从根到叶子节点的代表一个整数，求所有路径之和&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./4-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findRootToLeafPathNumbers(TreeNode *currentNode, int pathSum) {

    if (currentNode == NULL) {
        return 0;
    }

    pathSum = 10 * pathSum + currentNode-&amp;gt;val;

    if (currentNode-&amp;gt;left == NULL &amp;amp;&amp;amp; currentNode-&amp;gt;right == NULL) {
        return pathSum;

    }

    return findRootToLeafPathNumbers(currentNode-&amp;gt;left, pathSum) +
           findRootToLeafPathNumbers(currentNode-&amp;gt;right, pathSum);
}

int findSumOfPathNUmbers(TreeNode *root) {

    return findRootToLeafPathNumbers(root, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;5-path-with-given-sequence&#34;&gt;5、path with given sequence&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定二叉树和序列，序列代表从根到叶子节点的路径，判断序列代表的路径是否在树上&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./5-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;
bool findPathRecursive(TreeNode *currentNode, const vector&amp;lt;int&amp;gt; &amp;amp;sequence, int sequenceIndex) {
    if (currentNode == NULL) {
        return false;
    }
    

    if (sequenceIndex &amp;gt;= sequence.size() || currentNode-&amp;gt;val != sequence[sequenceIndex]) {
        return false;
    }
    if (currentNode-&amp;gt;left == NULL &amp;amp;&amp;amp; currentNode-&amp;gt;right == NULL &amp;amp;&amp;amp; sequenceIndex == sequence.size() - 1) {
        return true;
    }

    return findPathRecursive(currentNode-&amp;gt;left, sequence, sequenceIndex + 1) ||
           findPathRecursive(currentNode-&amp;gt;right, sequence, sequenceIndex + 1);

}

bool findPath(TreeNode *root, const vector&amp;lt;int&amp;gt; &amp;amp;sequence) {
    if (root == NULL) {
        return sequence.empty();
    }

    return findPathRecursive(root, sequence, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;6-tree-diameter&#34;&gt;6、tree diameter&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定二叉树，求其diameter(直径)：两叶子结点之间的最长路径。最长直径可能不经过根节点。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./6-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int calculateHeight(TreeNode *currentNode, int &amp;amp;treeDiameter) {
    if (currentNode == NULL) {
        return 0;
    }

    int leftTreeHeight = calculateHeight(currentNode-&amp;gt;left, treeDiameter);
    int rightTreeHeight = calculateHeight(currentNode-&amp;gt;right, treeDiameter);
    //currentNode的直径是左子树的高度+右子树的高度+1
    int diameter = leftTreeHeight + rightTreeHeight + 1;

    //更新整个树的最大直径
    treeDiameter = max(treeDiameter, diameter);

    return max(leftTreeHeight, rightTreeHeight) + 1;
}

int findDiameter(TreeNode *root) {
    int treeDiameter = 0;
    calculateHeight(root, treeDiameter);
    return treeDiameter;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;7-path-with-max-sum&#34;&gt;7、path with max sum&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定二叉树， 求任意两节点之间路径的最大和，不必经过根节点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./7-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findMaximumPathSumRecursive(TreeNode *currentNode, int &amp;amp;globalMaximumSum) {
    if (currentNode == NULL) {
        return 0;
    }

    int maxPathSumFromLeft = findMaximumPathSumRecursive(currentNode-&amp;gt;left, globalMaximumSum);
    int maxPathSumFromRight = findMaximumPathSumRecursive(currentNode-&amp;gt;right, globalMaximumSum);

    //忽略sum=0 的path
    maxPathSumFromLeft = max(maxPathSumFromLeft, 0);
    maxPathSumFromRight = max(maxPathSumFromRight, 0);

    //当前节点的maximumPathSum
    int localMaximumSum = maxPathSumFromLeft + maxPathSumFromRight + currentNode-&amp;gt;val;

    //更新全局maximum Sum
    globalMaximumSum = max(globalMaximumSum, localMaximumSum);

    //经过当前节点所有路径中最大的Sum
    return max(maxPathSumFromLeft, maxPathSumFromRight) + currentNode-&amp;gt;val;

}

int findMaximumPathSum(TreeNode *root) {
    int globalMaximum = INT_MIN;
    findMaximumPathSumRecursive(root, globalMaximum);
    return globalMaximum;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-8 Tree Breadth First Search</title>
      <link>/code/pattern/tree-breadth-first-search/</link>
      <pubDate>Sat, 23 May 2020 17:50:19 +0800</pubDate>
      <guid>/code/pattern/tree-breadth-first-search/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;p&gt;广度遍历，树的一种遍历方式，常用来解决需要一层一层遍历的问题&lt;/p&gt;

&lt;h2 id=&#34;2-binary-tree-level-order-traversal&#34;&gt;2、binary tree level order Traversal&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;层序遍历，每层单独放进数组，每层自顶向下，自左向右&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./2-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//struct TreeNode {
//    int val;
//    TreeNode *left;
//    TreeNode *right;

//    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
//};
vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; traverse(TreeNode *root) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;
    queue&amp;lt;TreeNode *&amp;gt; queue;
    
    if (root == NULL) {
        return result;
    }
    queue.push(root);
    while (!queue.empty()) {
        int levelSize = queue.size();
        vector&amp;lt;int&amp;gt; currentLevel;
        
        for (int i = 0; i &amp;lt; levelSize; i++) {
            TreeNode *currentNode = queue.front();
            queue.pop();
            currentLevel.push_back(currentNode-&amp;gt;val);
            
            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
        result.push_back(currentLevel);
    }
    return result;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./2-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h2 id=&#34;3-reverse-level-order-traversal&#34;&gt;3、reverse level order traversal&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;层序遍历，每层单独放进数组，每层自底向上，自左向右&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./3-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;deque&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; traverse(TreeNode *root) {
    deque&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;
    queue&amp;lt;TreeNode *&amp;gt; queue;

    if (root == NULL) {
        return result;
    }

    queue.push(root);
    while (!queue.empty()) {
        int levelSize = queue.size();
        vector&amp;lt;int&amp;gt; currentLevel;

        for (int i = 0; i &amp;lt; levelSize; i++) {
            TreeNode *currentNode = queue.front();
            queue.pop();
            currentLevel.push_back(currentNode-&amp;gt;val);

            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
        result.push_front(currentLevel);
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h2 id=&#34;4-zigzag-traversal&#34;&gt;4、zigzag traversal&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;层序遍历，每层单独放进数组，每层自顶向下，自左向右和自右向左交替进行&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./4-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; traverse(TreeNode *root) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;
    queue&amp;lt;TreeNode *&amp;gt; queue;
    bool leftToRight = true;

    if (root == NULL) {
        return result;
    }

    queue.push(root);
    while (!queue.empty()) {
        int levelSize = queue.size();
        vector&amp;lt;int&amp;gt; currentLevel(levelSize);

        for (int i = 0; i &amp;lt; levelSize; i++) {
            TreeNode *currentNode = queue.front();
            queue.pop();
            if (leftToRight) {
                currentLevel[i] = currentNode-&amp;gt;val;
            } else {
                currentLevel[levelSize - 1 - i] = currentNode-&amp;gt;val;
            }


            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
        result.push_back(currentLevel);
        leftToRight = !leftToRight;
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h2 id=&#34;5-level-averages-in-a-binary-tree&#34;&gt;5 、level averages in a binary tree&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;层序遍历，计算每一层的平均值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./5-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;double&amp;gt; findLevelAverages(TreeNode *root) {
    vector&amp;lt;double&amp;gt; result;
    queue&amp;lt;TreeNode *&amp;gt; queue;

    if (root == NULL) {
        return result;
    }

    queue.push(root);
    while (!queue.empty()) {
        int levelSize = queue.size();
        vector&amp;lt;int&amp;gt; currentLevel(levelSize);
        double levelSum = 0;

        for (int i = 0; i &amp;lt; levelSize; i++) {
            TreeNode *currentNode = queue.front();
            queue.pop();
            
            levelSum += currentNode-&amp;gt;val;

            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
        result.push_back(levelSum / levelSize);
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;相似问题1：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;求每一层的最大值,和最小值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; findLevelLargestAndSmallest(TreeNode *root) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;
    queue&amp;lt;TreeNode *&amp;gt; queue;

    if (root == NULL) {
        return result;
    }

    queue.push(root);
    while (!queue.empty()) {
        int levelSize = queue.size();
        vector&amp;lt;int&amp;gt; currentLevel(levelSize);
        int maxValue = INT_MIN;
        int minValue = INT_MAX;
        for (int i = 0; i &amp;lt; levelSize; i++) {
            TreeNode *currentNode = queue.front();
            queue.pop();

            maxValue = max(maxValue, currentNode-&amp;gt;val);
            minValue = min(minValue, currentNode-&amp;gt;val);
            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
        result.push_back({maxValue, minValue});
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h2 id=&#34;6-minimum-depth-of-a-binary-tree&#34;&gt;6、minimum depth of a binary tree&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求二叉树最小深度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./6-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int  findMinDepth(TreeNode *root) {
    if (root == NULL) {
        return 0;
    }

    int minimumTreeDepth=0;
    queue&amp;lt;TreeNode*&amp;gt; queue;

    queue.push(root);
    while (!queue.empty()) {
        minimumTreeDepth++;
        int levelSize = queue.size();
        
        for (int i = 0; i &amp;lt; levelSize; i++) {
            TreeNode *currentNode = queue.front();
            queue.pop();

            if(currentNode-&amp;gt;left==NULL&amp;amp;&amp;amp;currentNode-&amp;gt;right==NULL){
                //一旦遇到叶子节点，结束
                return minimumTreeDepth;
            }

            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
    }
    return minimumTreeDepth;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;相似问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;求二叉树最大深度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findMaxDepth(TreeNode *root) {
    if (root == NULL) {
        return 0;
    }

    int maximumTreeDepth = 0;
    queue&amp;lt;TreeNode *&amp;gt; queue;

    queue.push(root);
    while (!queue.empty()) {
        
        maximumTreeDepth++;
        int levelSize = queue.size();

        for (int i = 0; i &amp;lt; levelSize; i++) {
            TreeNode *currentNode = queue.front();
            queue.pop();
			//一直遍历
            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
    }
    return maximumTreeDepth;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h2 id=&#34;7-level-order-successor&#34;&gt;7、level order successor&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求层序遍历某一节点的后继&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./7-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;TreeNode *findSuccessor(TreeNode *root, int key) {
    if (root == NULL) {
        return NULL;
    }

    queue&amp;lt;TreeNode *&amp;gt; queue;

    queue.push(root);
    while (!queue.empty()) {

        TreeNode *currentNode = queue.front();
        queue.pop();

        if (currentNode-&amp;gt;left != NULL) {
            queue.push(currentNode-&amp;gt;left);
        }
        if (currentNode-&amp;gt;right != NULL) {
            queue.push(currentNode-&amp;gt;right);
        }
        if (currentNode-&amp;gt;val == key) {
            break;
        }
    }
    return queue.front();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h2 id=&#34;8-connect-level-order-siblings&#34;&gt;8、connect level order siblings&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;让所有节点指向其层序遍历的后继，每一层最后一个节点指向NULL&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./8-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode *next;

    TreeNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
};

void connect(TreeNode *root) {
    if (root == NULL) {
        return;
    }

    queue&amp;lt;TreeNode *&amp;gt; queue;

    queue.push(root);
    while (!queue.empty()) {
        TreeNode *previousNode = NULL;
        int levelSize = queue.size();

        for (int i = 0; i &amp;lt; levelSize; i++) {
            TreeNode *currentNode = queue.front();
            queue.pop();

            if (previousNode != NULL) {
                previousNode-&amp;gt;next = currentNode;
            }

            previousNode = currentNode;

            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h2 id=&#34;9-connect-all-level-order-siblings&#34;&gt;9、connect all level order siblings&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;连接层序遍历的后继节点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./9-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode *next;

    TreeNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
};

void connect(TreeNode *root) {
    if (root == NULL) {
        return;
    }

    queue&amp;lt;TreeNode *&amp;gt; queue;

    queue.push(root);
    TreeNode *previousNode = NULL;
    TreeNode *currentNode = NULL;
    while (!queue.empty()) {

        int levelSize = queue.size();

        for (int i = 0; i &amp;lt; levelSize; i++) {
            currentNode = queue.front();
            queue.pop();

            if (previousNode != NULL) {
                previousNode-&amp;gt;next = currentNode;
            }
            previousNode = currentNode;

            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h2 id=&#34;10-right-view-of-a-binary-tree&#34;&gt;10、right view of a binary tree&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求二叉树从右侧看到的所有节点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./10-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;TreeNode *&amp;gt; traverse(TreeNode *root) {
    vector&amp;lt;TreeNode *&amp;gt; result;
    queue&amp;lt;TreeNode *&amp;gt; queue;

    if (root == NULL) {
        return result;
    }

    queue.push(root);
    while (!queue.empty()) {
        int levelSize = queue.size();
        vector&amp;lt;int&amp;gt; currentLevel(levelSize);


        for (int i = 0; i &amp;lt; levelSize; i++) {
            TreeNode *currentNode = queue.front();
            queue.pop();

            //如果是这一层的最后一个节点放入result;
            if (i == levelSize - 1) {
                result.push_back(currentNode);
            }

            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;相似问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;求二叉树从左侧看到的所有节点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;TreeNode *&amp;gt; traverse(TreeNode *root) {
    vector&amp;lt;TreeNode *&amp;gt; result;
    queue&amp;lt;TreeNode *&amp;gt; queue;

    if (root == NULL) {
        return result;
    }

    queue.push(root);
    while (!queue.empty()) {
        int levelSize = queue.size();
        vector&amp;lt;int&amp;gt; currentLevel(levelSize);


        for (int i = 0; i &amp;lt; levelSize; i++) {
            TreeNode *currentNode = queue.front();
            queue.pop();

            //如果是这一层的第一个节点放入result;
            if (i == 0) {
                result.push_back(currentNode);
            }

            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h2 id=&#34;11-tree-boundary&#34;&gt;11、tree boundary&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;逆时针输出二叉树的所有边界节点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./11-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./11-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;TreeNode *&amp;gt; findLeavesDFS(TreeNode *root) {
    vector&amp;lt;TreeNode *&amp;gt; leaves;
    stack&amp;lt;TreeNode *&amp;gt; stack;
    stack.push(root);
    while (!stack.empty()) {
        TreeNode *currentNode = stack.top();
        stack.pop();
        if (currentNode-&amp;gt;left == NULL &amp;amp;&amp;amp; currentNode-&amp;gt;right == NULL) {
            leaves.push_back(currentNode);

        }
        if (currentNode-&amp;gt;right != NULL) {
            stack.push(currentNode-&amp;gt;right);
        }
        if (currentNode-&amp;gt;left != NULL) {
            stack.push(currentNode-&amp;gt;left);
        }

    }
    return leaves;

}

vector&amp;lt;TreeNode *&amp;gt; findBoundary(TreeNode *root) {
    if (root == NULL) {
        return vector&amp;lt;TreeNode *&amp;gt;();
    }
    vector&amp;lt;TreeNode *&amp;gt; result;
    vector&amp;lt;TreeNode *&amp;gt; leftView;
    deque&amp;lt;TreeNode *&amp;gt; rightView;

    queue&amp;lt;TreeNode *&amp;gt; queue;
    queue.push(root);
    while (!queue.empty()) {
        int levelSize = queue.size();
        vector&amp;lt;int&amp;gt; currentLevel(levelSize);


        for (int i = 0; i &amp;lt; levelSize; i++) {
            TreeNode *currentNode = queue.front();
            queue.pop();

            //如果是这一层的最后一个节点放入result;
            if (currentNode-&amp;gt;left == NULL &amp;amp;&amp;amp; currentNode-&amp;gt;right == NULL) {
                continue;
            } else if (i == 0) {
                leftView.push_back(currentNode);
            } else if (i == levelSize - 1) {
                rightView.push_front(currentNode);
            }

            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
    }
    vector&amp;lt;TreeNode *&amp;gt; leaves = findLeavesDFS(root);

    result.insert(result.end(), leftView.begin(), leftView.end());
    result.insert(result.end(), leaves.begin(), leaves.end());
    copy(begin(rightView), end(rightView), back_inserter(result));

    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-7 In Place Reversal of a Linked List</title>
      <link>/code/pattern/in-place-reversal-of-a-linked-list/</link>
      <pubDate>Sat, 23 May 2020 17:49:24 +0800</pubDate>
      <guid>/code/pattern/in-place-reversal-of-a-linked-list/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;p&gt;解决原地逆转链表的问题&lt;/p&gt;

&lt;h2 id=&#34;2-reverse-a-linkedlist&#34;&gt;2、reverse a linkedlist&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;逆转链表&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./2.png&#34; alt=&#34;reverse a linkedlis&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;
ListNode *reverse(ListNode *head) {
    ListNode *current = head;
    ListNode *prev = NULL;
    ListNode *next = NULL;
    while (current != NULL) {
        next = current-&amp;gt;next;
        current-&amp;gt;next = prev;
        prev = current;
        current = next;
    }
    return prev;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./2-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;3-reverse-a-sub-list&#34;&gt;3、reverse a sub-list&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;逆转链表第p个至第q个之间的元素&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./3-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ListNode *reverse(ListNode *head, int p, int q) {
    if (p == q) {
        return head;
    }

    ListNode *current = head;
    ListNode *prev = NULL;

    //让current指向pth Node
    for (int i = 0; current != NULL &amp;amp;&amp;amp; i &amp;lt; p - 1; i++) {
        prev = current;
        current = current-&amp;gt;next;
    }

    //第p-1个元素
    ListNode *lastNodeOfFirstPart = prev;
    //逆转部分最后一个
    ListNode *lastNodeOfSubList = current;
    ListNode *next = NULL;


    for (int i = 0; current != NULL &amp;amp;&amp;amp; i &amp;lt; q - p + 1; i++) {
        next = current-&amp;gt;next;
        current-&amp;gt;next = prev;
        prev = current;
        current = next;
    }

    //链接第一部分
    if (lastNodeOfFirstPart != NULL) {
        lastNodeOfFirstPart-&amp;gt;next = prev;

    } else {
        head = prev;
    }
    //链接后一部分
    lastNodeOfSubList-&amp;gt;next = current;
    return head;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;p&gt;相似问题1&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;逆转前k个元素&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;reverse(head, 1 ,n)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相似问题2&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;偶数个元素，逆转前1/2，后1/2；&lt;/p&gt;

&lt;p&gt;奇数个元素，逆转前1/2，后1/2，中间不变；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;偶数
reverse(head, 1 ,n/2)
reverse(head, 1/2 + 1 ,n)   
  
奇数
reverse(head, 1 ,n/2)
reverse(head, 1/2 + 2 ,n)    
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-reverse-every-k-element-sub-list&#34;&gt;4、reverse every  k-element sub-list&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定链表和整数K，每次逆转K个元素&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./4-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ListNode *reverse(ListNode *head, int k) {
    if (k &amp;lt;= 1 || head == NULL) {
        return head;
    }

    ListNode *current = head;
    ListNode *prev = NULL;

    while (true) {
        ListNode *lastNodeOfPreviousPart = prev;
        ListNode *lastNodeOfSubList = current;
        ListNode *next = NULL;

        for (int i = 0; current != NULL &amp;amp;&amp;amp; i &amp;lt; k; i++) {
            next = current-&amp;gt;next;
            current-&amp;gt;next = prev;
            prev = current;
            current = next;
        }

        //链接第一部分
        if (lastNodeOfPreviousPart != NULL) {
            lastNodeOfPreviousPart-&amp;gt;next = prev;

        } else {
            head = prev;
        }
        //链接后一部分
        lastNodeOfSubList-&amp;gt;next = current;
        if (current == NULL) {
            break;
        }
        prev = lastNodeOfSubList;

    }
    return head;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;5-reverse-alternating-k-element-sub-list&#34;&gt;5、reverse alternating k-element sub-list&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定链表和整数K，每次交替逆转K个元素，如果最后要逆转的部分小于k，也要逆转&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./5-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ListNode *reverse(ListNode *head, int k) {
    if (k &amp;lt;= 1 || head == NULL) {
        return head;
    }

    ListNode *current = head;
    ListNode *prev = NULL;

    while (true) {
        ListNode *lastNodeOfPreviousPart = prev;
        ListNode *lastNodeOfSubList = current;
        ListNode *next = NULL;


        for (int i = 0; current != NULL &amp;amp;&amp;amp; i &amp;lt; k; i++) {
            next = current-&amp;gt;next;
            current-&amp;gt;next = prev;
            prev = current;
            current = next;
        }

        if (lastNodeOfPreviousPart != NULL) {
            lastNodeOfPreviousPart-&amp;gt;next = prev;

        } else {
            head = prev;
        }

        lastNodeOfSubList-&amp;gt;next = current;

        for (int i = 0; current != NULL &amp;amp;&amp;amp; i &amp;lt; k; i++) {
            prev = current;
            current = current-&amp;gt;next;
        }

        if (current == NULL) {
            break;
        }
    }
    return head;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;6-rotate-a-linkedlist&#34;&gt;6、rotate a linkedlist&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定链表和整数K，循环将前k元素移到后面&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./6-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ListNode *rotate(ListNode *head, int rotations) {
    if (head == NULL || head-&amp;gt;next == NULL || rotations &amp;lt;= 0) {
        return head;
    }
    ListNode *lastNode = head;
    int listLength = 1;
    while (lastNode-&amp;gt;next != NULL) {
        lastNode = lastNode-&amp;gt;next;
        listLength++;
    }
    lastNode-&amp;gt;next = head;
    rotations %= listLength;
    int skipLength = listLength - rotations;
    ListNode *lastNodeOfRotatedList = head;
    
    for (int i = 0; i &amp;lt; skipLength - 1; i++) {
        lastNodeOfRotatedList = lastNodeOfRotatedList-&amp;gt;next;
    }

    head = lastNodeOfRotatedList-&amp;gt;next;
    lastNodeOfRotatedList-&amp;gt;next = NULL;
    return head;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-6 Cyclic Sort</title>
      <link>/code/pattern/cyclic-sort/</link>
      <pubDate>Sat, 23 May 2020 17:48:24 +0800</pubDate>
      <guid>/code/pattern/cyclic-sort/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;常用来解决数组元素的值在&lt;strong&gt;一定范围&lt;/strong&gt;内的问题&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;2-cyclic-sort&#34;&gt;2、cyclic sort&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定长度为n，所有元素的值在[1,n]内，不重复。原地排序&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, 1, 5, 4, 2]

output:	[1, 2, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2, 6, 4, 3, 1, 5]

output:	[1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void mySwap(vector&amp;lt;int&amp;gt; &amp;amp;arr,int i,int j){
    int temp=arr[i];
    arr[i]=arr[j];
    arr[j]=temp;
}
void sort(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    int i = 0;
    //如果nums[i]不在正确位置上，将交换到正确位置上
    while (i &amp;lt; nums.size()) {
        //j代表num[i]的正确索引位置
        int j = nums[i] - 1;
        if (nums[i] != nums[j]) {
            mySwap(nums,j,i);
            //swap(nums[j], nums[i]);
        } else {
            i++;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./2-1.png&#34; alt=&#34;cyclic sort&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-2.png&#34; alt=&#34;cyclic sort&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;3-find-the-missing-number&#34;&gt;3、find the Missing number&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定长度为n的数组，元素值的范围在[0,n], 不重复，求未包含在其中的数字&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[4, 0, 3, 1]

output:	2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[8, 3, 5, 2, 4, 6, 0, 1]

output:	7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void mySwap(vector&amp;lt;int&amp;gt; &amp;amp;arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

int findMissingNumber(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    int i = 0;
    while (i &amp;lt; nums.size()) {
        //把nums[i]放到到索引为nums[i]的位置上，
        //如 nums[6] -&amp;gt; index=nums[6]
        // 忽略n
        if (nums[i] &amp;lt; nums.size() &amp;amp;&amp;amp; nums[i] != nums[nums[i]]) {
            //交换索引位置上的值
            //也就是swap(nums[i], nums[nums[i]]);
            mySwap(nums, i, nums[i]);
        } else {
            i++;
        }
    }

    for (int i = 0; i &amp;lt; nums.size(); i++) {
        if (nums[i] != i) {
            return i;
        }
    }
    return nums.size();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;4-find-all-missing-numbers&#34;&gt;4、find all missing numbers&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定长度为n的数组，元素值的范围在[1,n], 有重复，求所有未包含在其中的数字&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2, 3, 1, 8, 2, 3, 5, 1]

output:	[4, 6, 7]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2, 4, 1, 2]

output:	[3]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void mySwap(vector&amp;lt;int&amp;gt; &amp;amp;arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

vector&amp;lt;int&amp;gt; findMissingNumbers(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    int i = 0;
    vector&amp;lt;int&amp;gt; missingNumbers;

    while (i &amp;lt; nums.size()) {
        //nums[i] - 1 代表num[i]的正确索引位置
        if (nums[i] != nums[nums[i] - 1]) {
            mySwap(nums, i, nums[i] - 1);
            //swap(nums[i],nums[nums[i] - 1]);
        } else {
            i++;
        }
    }

    for (int i = 0; i &amp;lt; nums.size(); i++) {
        if (nums[i] != i + 1) {
            missingNumbers.push_back(i + 1);
        }
    }
    return missingNumbers;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;5-find-the-duplicate-number&#34;&gt;5、find the duplicate number&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定长度为n+1的数组，元素值的范围在[1,n], 只有一个元素有重复，可多次重复，求重复的数字&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 4, 4, 3, 2]

output:	4
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2, 4, 4, 1, 4]

output:	4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void mySwap(vector&amp;lt;int&amp;gt; &amp;amp;arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

int findNUmber(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    int i = 0;

    while (i &amp;lt; nums.size()) {
        if (nums[i] != i + 1) {
            if (nums[i] != nums[nums[i] - 1]) {
                mySwap(nums, i, nums[i] - 1);
                //swap(nums[i],nums[nums[i] - 1]);
            } else {
                //在交换了一次重复值后，再次碰到，一定是重复的元素
                return nums[i];
            }
        } else {
            i++;
        }
    }
    return -1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;p&gt;相似问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;上述问题，不能改变数组，且要求&lt;em&gt;O&lt;/em&gt;(1)空间&lt;/p&gt;

&lt;p&gt;用快慢指针&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findStart(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int cycleLenghth) {
    int pointer1 = arr[0];
    int pointer2 = arr[0];
    while (cycleLenghth &amp;gt; 0) {
        pointer2 = arr[pointer2];
        cycleLenghth--;
    }

    while (pointer1 != pointer2) {
        pointer1 = arr[pointer1];
        pointer2 = arr[pointer2];
    }
    return pointer1;
}


int findDuplicate(const vector&amp;lt;int&amp;gt; &amp;amp;arr) {
    int fast = 0;
    int slow = 0;
    do {
        slow = arr[slow];
        fast = arr[arr[fast]];
    } while (slow != fast);

    int current = arr[slow];
    int cycleLength = 0;
    do {
        current = arr[current];
        cycleLength++;
    } while (current != arr[slow]);
    
    return findStart(arr, cycleLength);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;6-find-all-duplicate-numbers&#34;&gt;6、find all duplicate numbers&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定长度为n的数组，元素值的范围在[1,n], 有多个有重复，求所有重复的数字，不使用额外空间&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, 4, 4, 5, 5]

output:	[5, 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[5, 4, 7, 2, 3, 5, 3]

output:	[3, 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void mySwap(vector&amp;lt;int&amp;gt; &amp;amp;arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

vector&amp;lt;int&amp;gt; findNumbers(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    int i = 0;
    vector&amp;lt;int&amp;gt; duplicates;

    while (i &amp;lt; nums.size()) {
        if (nums[i] != nums[nums[i] - 1]) {
            mySwap(nums, i, nums[i] - 1);
            //swap(nums[i],nums[nums[i] - 1]);
        } else {
            i++;
        }
    }
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        if (nums[i] != i + 1) {
            duplicates.push_back(nums[i]);
        }
    }
    return duplicates;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;7-find-the-corrupt-pair&#34;&gt;7、find the corrupt pair&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定长度为n的数组，元素值的范围在[1,n], 一个元素有重复且重复一次，求重复的数字和缺失的数字&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, 1, 2, 5, 2]

output:	[2, 4]

explanation: 2重复，4缺失
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, 1, 2, 3, 6, 4]

output:	[3, 5]

explanation: 3重复，5缺失
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;int&amp;gt; findNumbers(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    int i = 0;

    while (i &amp;lt; nums.size()) {
        if (nums[i] != nums[nums[i] - 1]) {
            mySwap(nums, i, nums[i] - 1);
            //swap(nums[i],nums[nums[i] - 1]);
        } else {
            i++;
        }
    }
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        if (nums[i] != i + 1) {
            return vector&amp;lt;int&amp;gt;{nums[i], i + 1};
        }
    }
    return vector&amp;lt;int&amp;gt;{-1, -1};
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;8-find-the-smallest-missing-positive-number&#34;&gt;8、find the smallest missing positive number&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定整数数组，元素值无范围限制，求最小缺失的正整数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-3, 1, 5, 4, 2]

output:	3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, -2, 0, 1, 2]

output:	4
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, 2, 5, 1]

output:	4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void mySwap(vector&amp;lt;int&amp;gt; &amp;amp;arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

int findNumber(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    int i = 0;

    while (i &amp;lt; nums.size()) {
        if (nums[i] &amp;gt; 0 &amp;amp;&amp;amp; nums[i] &amp;lt;= nums.size() &amp;amp;&amp;amp;
            nums[i] != nums[nums[i] - 1]) {

            mySwap(nums, i, nums[i] - 1);
            //swap(nums[i],nums[nums[i] - 1]);
        } else {
            i++;
        }
    }
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        if (nums[i] != i + 1) {
            return i + 1;
        }
    }
    return nums.size() + 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;9-find-the-first-k-missing-positive-numbers&#34;&gt;9、find the first k missing positive numbers&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定整数数组和K值，元素值无范围限制，求最小的前K个缺失的正整数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, -1, 4, 5, 5] ,K=3

output:	[1, 2, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2, 3 ,4] ,K=3

output:	[1, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-2, -3 ,4] ,K=2

output:	[1, 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void mySwap(vector&amp;lt;int&amp;gt; &amp;amp;arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

vector&amp;lt;int&amp;gt; findNumbers(vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) {
    int i = 0;
    vector&amp;lt;int&amp;gt; missingNUmbers;
    unordered_set&amp;lt;int&amp;gt; extraNumbers;

    while (i &amp;lt; nums.size()) {
        if (nums[i] &amp;gt; 0 &amp;amp;&amp;amp; nums[i] &amp;lt;= nums.size() &amp;amp;&amp;amp;
            nums[i] != nums[nums[i] - 1]) {

            mySwap(nums, i, nums[i] - 1);
            //swap(nums[i],nums[nums[i] - 1]);
        } else {
            i++;
        }
    }
    for (int i = 0; i &amp;lt; nums.size() &amp;amp;&amp;amp; missingNUmbers.size() &amp;lt; k; i++) {
        if (nums[i] != i + 1) {
            missingNUmbers.push_back(i + 1);
            extraNumbers.insert(nums[i]);
        }
    }

    for (int i = 1; missingNUmbers.size() &amp;lt; k; i++) {
        int candidateNumber = i + nums.size();
        if (extraNumbers.find(candidateNumber) == extraNumbers.end()) {
            missingNUmbers.push_back(candidateNumber);
        }
    }
    return missingNUmbers;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N + K]&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(K)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-5 Merge Intervals</title>
      <link>/code/pattern/merge-intervals/</link>
      <pubDate>Sat, 23 May 2020 17:47:56 +0800</pubDate>
      <guid>/code/pattern/merge-intervals/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;p&gt;常用来解决重叠区间问题，如求重叠的区间或合并有重叠的区间&lt;/p&gt;

&lt;p&gt;区间 a , b 的6种重叠方式&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-merge-interval&#34;&gt;2、merge interval&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定一组区间，合并重叠的区间&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./2-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; merge(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) {
    if (intervals.size() &amp;lt; 1) {
        return intervals;
    }

    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; mergedResult;
    mergedResult.push_back(intervals[0]);

    for (int i = 1; i &amp;lt; intervals.size(); i++) {
        if (intervals[i][0] &amp;lt;= mergedResult.back()[1]) {

            mergedResult.back()[1] = max(mergedResult.back()[1], intervals[i][1]);
        } else {
            mergedResult.push_back(intervals[i]);
        }
    }
    return mergedResult;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; *  log &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;相似问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;判断一组区间是否重合&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[[1, 4], [2, 5], [7, 9]]

output:	true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool isMerge(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) {
    if (intervals.size() &amp;lt; 1) {
        return false;
    }

    vector&amp;lt;int&amp;gt; temp=intervals[0];

    for (int i = 1; i &amp;lt; intervals.size(); i++) {
        if (intervals[i][0] &amp;lt;= temp[1]) {
            return true;
        } else {
            temp=intervals[i];
        }
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-insert-interval&#34;&gt;3、insert interval&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定一组不重叠区间（按照起始位置排序）和一个区间，合并，生成新的不重叠的区间&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./3-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; insertInterval(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; intervals, vector&amp;lt;int&amp;gt; newInterval) {
    if (intervals.empty()) {
        return vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;{newInterval};
    }

    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;
    int i = 0;
    while (i &amp;lt; intervals.size() &amp;amp;&amp;amp; intervals[i][1] &amp;lt; newInterval[0]) {
        result.push_back(intervals[i]);
        i++;
    }

    while (i &amp;lt; intervals.size() &amp;amp;&amp;amp; intervals[i][0] &amp;lt;= newInterval[1]) {
        newInterval[0] = min(intervals[i][0], newInterval[0]);
        newInterval[1] = max(intervals[i][1], newInterval[1]);
        i++;
    }

    result.push_back(newInterval);

    while (i &amp;lt; intervals.size()) {
        result.push_back(intervals[i]);
        i++;
    }

    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;4-intervals-intersection&#34;&gt;4、intervals intersection&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定两组区间（每组不重叠，按起始位置排序），求其相交区间&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./4-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; merge(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;arr1, const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;arr2) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;

    int i = 0, j = 0;

    while (i &amp;lt; arr1.size() &amp;amp;&amp;amp; j &amp;lt; arr2.size()) {

        if ((arr1[i][0] &amp;gt;= arr2[j][0] &amp;amp;&amp;amp; arr1[i][0] &amp;lt;= arr2[j][1]) ||
            (arr2[j][0] &amp;gt;= arr1[i][0] &amp;amp;&amp;amp; arr2[j][0] &amp;lt;= arr1[i][1])) {

            result.push_back({max(arr1[i][0], arr2[j][0]), min(arr1[i][1], arr2[j][1])});
        }

        if (arr1[i][1] &amp;lt; arr2[j][1]) {
            i++;
        } else {
            j++;
        }
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; + &lt;em&gt;M&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;1&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;5-conflicting-appointments&#34;&gt;5、conflicting appointments&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定一组区间代表一组会议持续时间，判断某人是否能够参加所有的会议&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[[1, 4], [2, 5], [7, 9]]

output:	false
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[[6, 7], [2, 4], [8, 12]]

output:	true
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[[4, 5], [2, 3], [3, 6]]

output:	false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool canAttendAllAppointments(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;nums) {
    sort(nums.begin(), nums.end());

    for (int i = 1; i &amp;lt; nums.size(); i++) {
        if (nums[i][0] &amp;lt; nums[i - 1][1]) {
            return false;
        }
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; *  log &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;相似问题&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;给定一组区间代表一组会议持续时间，求所有冲突的会议&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;待写
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;6-minimum-meeting-rooms&#34;&gt;6、minimum meeting rooms&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定一组区间代表一些会议，求能举办这些会议的最小会议室&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./6-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./6-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./6-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_greater {
    bool operator()(const vector&amp;lt;int&amp;gt; &amp;amp;x, const vector&amp;lt;int&amp;gt; &amp;amp;y) {
        return x[1] &amp;gt; y[1];
    }
};


int minimumMeetingRooms(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;meetings) {
    if (meetings.empty()) {
        return 0;
    }
    sort(meetings.begin(), meetings.end());
    int minRooms = 0;
    priority_queue&amp;lt;vector&amp;lt;int&amp;gt;, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;, cmp_greater&amp;gt; minHeap;

    for (auto m: meetings) {
        while (!minHeap.empty() &amp;amp;&amp;amp; m[0] &amp;gt;= minHeap.top()[1]) {
            minHeap.pop();
        }
        minHeap.push(m);
        minRooms = max(minRooms, (int) minHeap.size());
    }

    return minRooms;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; *  log &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;7-maximum-cpu-load&#34;&gt;7、maximum cpu load&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;没看懂&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;8-employee-free-time&#34;&gt;8、employee free time&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;待看&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-4 Fast and Slow Pointers</title>
      <link>/code/pattern/fast-and-slow-pointers/</link>
      <pubDate>Sat, 23 May 2020 17:46:20 +0800</pubDate>
      <guid>/code/pattern/fast-and-slow-pointers/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;p&gt;移动两个速度不同的指针，常在环形数组和链表问题中使用。&lt;/p&gt;

&lt;h2 id=&#34;2-linkedlist-cycle&#34;&gt;2、linkedlist cycle&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;判断链表是否有环&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./2.png&#34; alt=&#34;有无环的链表&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool hasCycle(ListNode *head) {
    ListNode *fast = head;
    ListNode *slow = head;
    
    while (fast != NULL &amp;amp;&amp;amp; fast-&amp;gt;next != NULL) {
        fast = fast-&amp;gt;next-&amp;gt;next;
        slow = slow-&amp;gt;next;
        if (slow == fast) {
            return true;
        }
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;p&gt;相似问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;求带环链表环的长度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int calculateLength(ListNode *slow) {
    ListNode *current = slow;
    int cycleLength = 0;
    do {
        current = current-&amp;gt;next;
        cycleLength++;
    } while (current != slow);
    return cycleLength;
}

int findCycleLength(ListNode *head) {
    ListNode *fast = head;
    ListNode *slow = head;
    while (fast != NULL &amp;amp;&amp;amp; fast-&amp;gt;next != NULL) {
        fast = fast-&amp;gt;next-&amp;gt;next;
        slow = slow-&amp;gt;next;
        if (slow == fast) {
            return calculateLength(slow);
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;3-start-of-linkedlist-cycle&#34;&gt;3、start of linkedlist cycle&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求带环链表的起点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./3.png&#34; alt=&#34;带环链表起点&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ListNode *findStart(ListNode *head, int cycleLenghth) {
    ListNode *pointer1 = head;
    ListNode *pointer2 = head;
    while (cycleLenghth &amp;gt; 0) {
        pointer2 = pointer2-&amp;gt;next;
        cycleLenghth--;
    }

    while (pointer1 != pointer2) {
        pointer1 = pointer1-&amp;gt;next;
        pointer2 = pointer2-&amp;gt;next;
    }
    return pointer1;
}

int calculateLength(ListNode *slow) {
    ListNode *current = slow;
    int cycleLength = 0;
    do {
        current = current-&amp;gt;next;
        cycleLength++;
    } while (current != slow);
    return cycleLength;
}

ListNode *findCycleStart(ListNode *head) {
    int cycleLength = 0;
    ListNode *fast = head;
    ListNode *slow = head;
    while (fast != NULL &amp;amp;&amp;amp; fast-&amp;gt;next != NULL) {
        fast = fast-&amp;gt;next-&amp;gt;next;
        slow = slow-&amp;gt;next;
        if (slow == fast) {
            cycleLength = calculateLength(slow);
            break;
        }
    }
    return findStart(head, cycleLength);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./3-1.png&#34; alt=&#34;快慢指针&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;4-happy-number&#34;&gt;4、happy number&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;判断整数是否是happy number&lt;/p&gt;

&lt;p&gt;快乐数（happy number）有以下的特性：在给定的进位制下，该数字所有数位(digits)的平方和，得到的新数再次求所有数位的平方和，如此重复进行，最终结果必为1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	23
 
output:	true

explanations:  2*2 + 3*3 = 4 + 9 = 13
    		  1*1 + 3*3 = 1 + 9 = 10
    		  1*1 + 0*0 = 1 + 0 = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	12
 
output:	false

explanations: 5-&amp;gt;25-&amp;gt;29-&amp;gt;85-&amp;gt;89-&amp;gt;145-&amp;gt;42-&amp;gt;20-&amp;gt;4-&amp;gt;16-&amp;gt;37-&amp;gt;58-&amp;gt;89  89重复
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findSquareSum(int num) {
    int sum = 0;
    int digit;
    while (num &amp;gt; 0) {
        digit = num % 10;
        sum += digit * digit;
        num /= 10;
    }
    return sum;
}

int find(int num) {
    //如果不是happy number，在不断生成新数中，定有重复
    int slow = num;
    int fast = num;
    do {
        slow = findSquareSum(slow);
        fast = findSquareSum(findSquareSum(fast));
    } while (slow != fast);

    return slow == 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(log N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;5-middle-of-the-linkedlist&#34;&gt;5、middle of the linkedlist&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求链表的中间节点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5-&amp;gt; NULL
 
output:	3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5-&amp;gt; 6 -&amp;gt; NULL
 
output:	4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ListNode *findMiddle(ListNode *head) {
    ListNode *fast = head;
    ListNode *slow = head;

    while (fast != NULL &amp;amp;&amp;amp; fast-&amp;gt;next != NULL) {
        fast = fast-&amp;gt;next-&amp;gt;next;
        slow = slow-&amp;gt;next;
    }
    return slow;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;6-palindrome-linkedlist&#34;&gt;6、palindrome linkedlist&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;判断链表是否对称&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	2 -&amp;gt; 4 -&amp;gt; 6 -&amp;gt; 4 -&amp;gt; 2-&amp;gt; NULL
 
output:	true
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	2 -&amp;gt; 4 -&amp;gt; 6 -&amp;gt; 4 -&amp;gt; 2 -&amp;gt; 2 -&amp;gt; NULL
 
output:	false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ListNode *reverse(ListNode *head) {
    ListNode *prev = NULL;
    while (head != NULL) {
        ListNode *next = head-&amp;gt;next;
        head-&amp;gt;next = prev;
        prev = head;
        head = next;
    }
    return prev;
}

bool isPalindrome(ListNode *head) {
    if (head == NULL || head-&amp;gt;next == NULL) {
        return true;
    }
    ListNode *fast = head;
    ListNode *slow = head;
    while (fast != NULL &amp;amp;&amp;amp; fast-&amp;gt;next != NULL) {
        fast = fast-&amp;gt;next-&amp;gt;next;
        slow = slow-&amp;gt;next;
    }

    ListNode *headSecondHalf = reverse(slow);
    ListNode *copyHeadSecondHalf = headSecondHalf;

    while (head != NULL &amp;amp;&amp;amp; headSecondHalf != NULL) {
        if (head-&amp;gt;val != headSecondHalf-&amp;gt;val) {
            break;
        }
        head = head-&amp;gt;next;
        headSecondHalf = headSecondHalf-&amp;gt;next;
    }


    reverse(copyHeadSecondHalf);
    if (head == NULL || headSecondHalf == NULL) {
        return true;
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;7-rearrange-a-linkedlist&#34;&gt;7、rearrange a linkedlist&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…&lt;/p&gt;

&lt;p&gt;你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	2 -&amp;gt; 4 -&amp;gt; 6 -&amp;gt; 8 -&amp;gt; 10-&amp;gt; 12 -&amp;gt; NULL
 
output:	2 -&amp;gt; 12 -&amp;gt; 4 -&amp;gt; 10-&amp;gt; 6 -&amp;gt; 8 -&amp;gt; NULL
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	2 -&amp;gt; 4 -&amp;gt; 6 -&amp;gt; 8 -&amp;gt; 10 -&amp;gt; NULL
 
output:	2 -&amp;gt; 10 -&amp;gt; 4 -&amp;gt; 8 -&amp;gt; 6 -&amp;gt; NULL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ListNode *reverse(ListNode *head) {
    ListNode *prev = NULL;
    while (head != NULL) {
        ListNode *next = head-&amp;gt;next;
        head-&amp;gt;next = prev;
        prev = head;
        head = next;
    }
    return prev;
}

void reOrder(ListNode *head) {
    if (head == NULL || head-&amp;gt;next == NULL) {
        return;
    }
    ListNode *fast = head;
    ListNode *slow = head;
    while (fast != NULL &amp;amp;&amp;amp; fast-&amp;gt;next != NULL) {
        fast = fast-&amp;gt;next-&amp;gt;next;
        slow = slow-&amp;gt;next;
    }

    ListNode *headSecondHalf = reverse(slow);
    ListNode *headFirstHalf = head;

    while (headFirstHalf != NULL &amp;amp;&amp;amp; headSecondHalf != NULL) {
        ListNode *temp = headFirstHalf-&amp;gt;next;
        headFirstHalf-&amp;gt;next = headSecondHalf;
        headFirstHalf = temp;

        temp = headSecondHalf-&amp;gt;next;
        headSecondHalf-&amp;gt;next = headFirstHalf;
        headSecondHalf = temp;
    }

    if (headFirstHalf != NULL) {
        headFirstHalf-&amp;gt;next = NULL;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;8-cycle-in-a-circular-array&#34;&gt;8、cycle in a Circular array&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;没看懂题目&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-3 Two Pointers</title>
      <link>/code/pattern/two-pointers/</link>
      <pubDate>Sat, 23 May 2020 17:45:10 +0800</pubDate>
      <guid>/code/pattern/two-pointers/</guid>
      <description>

&lt;h1 id=&#34;1-介绍&#34;&gt;1、介绍&lt;/h1&gt;

&lt;p&gt;在&lt;strong&gt;有序&lt;/strong&gt;数组或链表中查找出满足某些限定条件一组元素时，常用双指针法。&lt;/p&gt;

&lt;h1 id=&#34;2-pair-with-target-sum&#34;&gt;2、pair with target sum&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;给定有序数组、目标值target，在数组中找到一对值，使得其和等于目标值&lt;/p&gt;

&lt;p&gt;返回满足条件的对值的索引&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1,2,3,4,6] ,target=6

output:	[1,3]

2+4=6，index=[1,3]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [2,5,9,11] ,target=11

output:	[0,2]

2+9=6，index=[0,2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;p&gt;双指针法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;pair&amp;lt;int, int&amp;gt; search(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int targetSum) {
    //指向起始，结束位置。
    int left = 0;
    int right = arr.size() - 1;
    
    while (right &amp;gt; left) {
        int currentSum = arr[left] + arr[right];
        if (currentSum == targetSum) {
            return make_pair(left, right);
        }
        if (targetSum &amp;gt; currentSum) {
            left++;
        }
        if (targetSum &amp;lt; currentSum) {
            right--;
        }
    }
    return make_pair(-1, -1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time:   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space:  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;p&gt;哈希表：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;pair&amp;lt;int,int&amp;gt; searchhash(const vector&amp;lt;int&amp;gt; &amp;amp;arr,int targetSum){
    unordered_map&amp;lt;int,int&amp;gt; nums;
    for(int i=0;i&amp;lt;arr.size();i++){
        if(nums.find(targetSum-arr[i])!=nums.end()){
            return make_pair(nums[targetSum-arr[i]],i);
        }else{
            nums[arr[i]]=i;
        }
    }
    return make_pair(-1,-1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time:   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space:  &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h1 id=&#34;3-remove-duplicates&#34;&gt;3、remove Duplicates&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;删除有序数组中重复的元素，不准使用额外的存储空间，返回删除后的新数组长度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2,3,3,3,6,9,9] 

output: 4

after remove:[2,3,6,9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int remove(vector&amp;lt;int&amp;gt; &amp;amp;arr) {
    //nextNonDuplicate前面全是不重复的元素，同时承担计数功能
    //nextNonDuplicate和i都是指针
    int nextNonDuplicate = 1;
    for (int i = 1; i &amp;lt; arr.size(); i++) {
        if (arr[nextNonDuplicate - 1] != arr[i]) {
            arr[nextNonDuplicate] = arr[i];
            nextNonDuplicate++;
        }
    }
    return nextNonDuplicate;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;p&gt;相似问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;删除有序数组中所有等于Target的元素，返回删除后的新数组长度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, 2, 3, 6, 3, 10, 9, 3],key=3

output: 4

after remove:[2,3,10,9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int removeTaget(vector&amp;lt;int&amp;gt; &amp;amp;arr, int key) {
    // nextElement代表不等于key的元素的新位置,同时计数
    // nextElement和i都是指针
    int nextElement = 0;
    for (int i = 0; i &amp;lt; arr.size(); i++) {
        if (arr[i] != key) {
            arr[nextElement] = arr[i];
            nextElement++;
        }
    }
    return nextElement;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h1 id=&#34;4-squaring-a-sorted-arrary&#34;&gt;4、squaring a sorted arrary&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;给定有序数组，将所有元素的平方有序输出&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-2, -1, 0, 2, 3]

output: [0 ,1 ,4 ,4 ,9]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-3, -1, 0, 1, 2]

output: [0 ,1 ,4 ,4 ,9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;int&amp;gt; makeSqueare(vector&amp;lt;int&amp;gt; arr) {
    int n = arr.size();
    vector&amp;lt;int&amp;gt; square(n);
    int highestSquareIndex = n - 1;
    //双指针
    int right = n - 1;
    int left = 0;
    
    while (right &amp;gt;= left) {
        int leftSquare = arr[left] * arr[left];
        int rightSquare = arr[right] * arr[right];
        if (leftSquare &amp;gt; rightSquare) {
            square[highestSquareIndex] = leftSquare;
            highestSquareIndex--;
            left++;
        } else {
            square[highestSquareIndex] = rightSquare;
            highestSquareIndex--;
            right--;
        }
    }
    return square;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h1 id=&#34;5-triplet-sum-to-zero&#34;&gt;5、triplet sum to zero&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;给定未排序的整数数组，找出所有和为0、长度为3且不重复的子数组&lt;/p&gt;

&lt;p&gt;X+Y+Z=0  -&amp;gt; X+Y=_Z&lt;/p&gt;

&lt;p&gt;为了确保不重复，排序后的数组，重复元素相邻可略过&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-3, 0, 1, 2, -1, 1, -2]

output: [[-3 1 2 ][-2 0 2 ][-1 0 1 ]]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-5, 2, -1, -2, 3]

output: [[-5 2 3 ][-2 -1 3 ]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void searchPair(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int targetSum, int left, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;triplets) {
    //双指针
    int right = arr.size() - 1;
    while (left &amp;lt; right) {
        int currentSum = arr[left] + arr[right];
        if (currentSum == targetSum) {
            triplets.push_back({-targetSum, arr[left], arr[right]});
            left++;
            right--;

            //略过重复元素
            while (left &amp;lt; right &amp;amp;&amp;amp; arr[left] == arr[left - 1]) {
                left++;
            }
            //略过重复元素
            while (left &amp;lt; right &amp;amp;&amp;amp; arr[right] == arr[right]) {
                right--;
            }
        } else if (targetSum &amp;gt; currentSum) {
            left++;
        } else {
            right--;
        }
    }
}

vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; searchTriplets(vector&amp;lt;int&amp;gt; &amp;amp;arr) {
    sort(arr.begin(), arr.end());
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; triplets;
    for (int i = 0; i &amp;lt; arr.size() - 2; i++) {
        //略过重复元素
        if (i &amp;gt; 0 &amp;amp;&amp;amp; arr[i] == arr[i - 1]) {
            continue;
        }
        searchPair(arr, -arr[i], i + 1, triplets);
    }
    return triplets;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N^2)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h1 id=&#34;6-triplet-sum-close-to-target&#34;&gt;6、triplet sum close to target&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;给定未排序数组和target值，找出长度为3的子数组，使得子数组的和尽可能接近target，返回子数组的和&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-2, 0, 1, 2],target=2

output: 1

triplet: [-2,1,2]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-3, 1, 1, 2],target=1

output: 0

triplet: [-3,1,2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int searchTriplet(vector&amp;lt;int&amp;gt; &amp;amp;arr, int targetSum) {
    sort(arr.begin(), arr.end());
    int smallestDifference = INT_MAX;
    for (int i = 0; i &amp;lt; arr.size() - 2; i++) {
        int left = i + 1;
        int right = arr.size() - 1;
        while (left &amp;lt; right) {
            int targetDiff = targetSum - arr[i] - arr[left] - arr[right];
            if (targetDiff == 0) {
                return targetSum - targetDiff;
            }
            if (abs(targetDiff) &amp;lt; abs(smallestDifference)) {
                smallestDifference = targetDiff;
            }
            if (targetDiff &amp;gt; 0) {
                left++;
            } else {
                right--;
            }
        }
    }
    return targetSum - smallestDifference;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N^2)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h1 id=&#34;7-triplets-with-smaller-sum&#34;&gt;7、triplets with smaller sum&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;给定未排序数组和target值，找出所有triplets，使得arr[i]+arr[j]+arr[k]&amp;lt; target，i,j,k不相等，返回满足条件的triplets的个数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-1, 0, 2, 3],target=3

output: 2

triplet: [-1,0,3], [-1,0,2]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-1, 4, 2, 1, 3],target=5

output: 4

triplet: [-1,1,4], [-1,1,3], [-1,1,2], [-1,2,3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int searchPair(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int targetSum, int first) {
    int count = 0;
    int left = first + 1;
    int right = arr.size() - 1;
    while (left &amp;lt; right) {
        if (arr[left] + arr[right] &amp;lt; targetSum) {
            count += right - left;
            left++;
        } else {
            right--;
        }
    }
    return count;
}

int searchTriplets(vector&amp;lt;int&amp;gt; &amp;amp;arr, int target) {
    sort(arr.begin(), arr.end());
    int count = 0;
    for (int i = 0; i &amp;lt; arr.size() - 2; i++) {
        count += searchPair(arr, target - arr[i], i);
    }
    return count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N^2)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;相似问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;返回所有的triplets&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-1, 4, 2, 1, 3],target=5

output: [-1,1,4], [-1,1,3], [-1,1,2], [-1,2,3]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-1, 0, 2, 3],target=3

output: [-1,0,3], [-1,0,2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;
void searchPair(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int targetSum, 
                int first, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;triplets) {

    int left = first + 1;
    int right = arr.size() - 1;
    while (left &amp;lt; right) {
        if (arr[left] + arr[right] &amp;lt; targetSum) {
            for (int i = right; i &amp;gt; left; i--) {
                triplets.push_back({arr[first], arr[left], arr[i]});
            }
            left++;
        } else {
            right--;
        }
    }
}

vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; searchTriplets(vector&amp;lt;int&amp;gt; &amp;amp;arr, int target) {
    sort(arr.begin(), arr.end());
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; triplets;

    for (int i = 0; i &amp;lt; arr.size() - 2; i++) {
        searchPair(arr, target - arr[i], i, triplets);
    }
    return triplets;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N^3)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h1 id=&#34;8-subarrary-with-product-less-than-a-target&#34;&gt;8、subarrary with product less than a target&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;给定只包含正整数的数组和target值，寻找所有连续子数组，使得子数组的元素的乘积小于target&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2, 5, 3, 10], target=30

output: [[2 ],[5 ],[2 5 ],[3 ],[5 3 ],[10 ]]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[8, 2, 6, 5], target50

output: [[8 ],[2 ],[8 2 ],[6 ],[2 6 ],[5 ],[6 5 ]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; findSubarrary(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int target) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;
    int product = 1;
    int left = 0;
    for (int right = 0; right &amp;lt; arr.size(); right++) {
        product *= arr[right];
        while (product &amp;gt;= target &amp;amp;&amp;amp; left &amp;lt; arr.size()) {
            product /= arr[left];
            left++;
        }

        deque&amp;lt;int&amp;gt; temList;
        //[left,right]区间内乘积小于target，区间内的子数组当然小于target，
        // 为了避免重复，只计算从arr[right]开始的子数组
        for (int i = right; i &amp;gt;= left; i--) {
            temList.push_front(arr[i]);
            vector&amp;lt;int&amp;gt; resultVec;
            move(begin(temList), end(temList), back_inserter(resultVec));
            result.push_back(resultVec);
        }
    }
    return result;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N^3)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h1 id=&#34;9-dutch-national-flag-problem&#34;&gt;9、dutch National flag problem&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;给定只包含0,1,2的数组，原地排序，不准计算0,1,2的个数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 0, 2, 1, 0]

output: [0, 0, 1, 1, 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2, 2, 0, 1, 2, 0]

output: [0, 0, 1, 2, 2, 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void swap(vector&amp;lt;int&amp;gt; &amp;amp;arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

void sort(vector&amp;lt;int&amp;gt; &amp;amp;arr) {
    //所有0在low左侧，所有2在high右侧
    int low = 0;
    int high = arr.size() - 1;
    
    for (int i = 0; i &amp;lt;= high;) {
        if (arr[i] == 0) {
            swap(arr, i, low);
            i++;
            low++;
        } else if (arr[i] == 1) {
            i++;
        } else {
            swap(arr, i, high);
            high--;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h1 id=&#34;10-quadruple-sum-to-target&#34;&gt;10、quadruple sum to target&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;给定未排序数组和target值，找出所有不同的quadruple（长度为4的子数组），使得其和等于target&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[4, 1, 2, -1, 1, -3]

output: [ [-3, -1, 1, 4 ], [-3, 1, 1, 2 ] ]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2, 0, -1, 1, -2, 2 ]

output:	[[-2, 0, 2 ,2 ], [-1, 0 ,1, 2 ]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void searchPair(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int targetSum,
                int fist, int second, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;quadruplets) {

    int left = second + 1;
    int right = arr.size() - 1;
    while (left &amp;lt;= right) {
        int sum = arr[fist] + arr[second] + arr[left] + arr[right];
        if (sum == targetSum) {
            quadruplets.push_back({arr[fist], arr[second], arr[left], arr[right]});
            left++;
            right--;

            while (left &amp;lt; right &amp;amp;&amp;amp; arr[left] == arr[left - 1]) {
                left++;
            }
            while (left &amp;gt; right &amp;amp;&amp;amp; arr[right] == arr[right - 1]) {
                right--;
            }
        } else if (sum &amp;lt; targetSum) {
            left++;
        } else {
            right--;
        }
    }
}

vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; searchQuadruplets(vector&amp;lt;int&amp;gt; &amp;amp;arr, int target) {
    sort(arr.begin(), arr.end());
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; quadruplets;
    for (int i = 0; i &amp;lt; arr.size() - 3; i++) {
        if (i &amp;gt; 0 &amp;amp;&amp;amp; arr[i] == arr[i - 1]) {
            continue;
        }
        for (int j = i + 1; j &amp;lt; arr.size() - 2; j++) {
            if (j &amp;gt; i + 1 &amp;amp;&amp;amp; arr[j] == arr[j - 1]) {
                continue;
            }
            searchPair(arr, target, i, j, quadruplets);
        };
    }
    return quadruplets;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N^3)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h1 id=&#34;11-comparing-strings-containing-backspaces&#34;&gt;11、comparing strings containing backspaces&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;给定两个包含退格键的字符串，判断他们是否相同，backspace用#表示&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	str1=&amp;quot;xy#z&amp;quot; ,str2=&amp;quot;xzz#&amp;quot;

output:	true

after: str1=&amp;quot;xz&amp;quot; ,str2=&amp;quot;xz&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	str1=&amp;quot;xp#&amp;quot;  ,str2=&amp;quot;xyz##&amp;quot;
    
output:	true
 
after: str1=&amp;quot;x&amp;quot; ,str2=&amp;quot;x&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	str1=&amp;quot;xy#z&amp;quot;  ,str2=&amp;quot;xyz#&amp;quot;
    
output:	false

after: str1=&amp;quot;xz&amp;quot; ,str2=&amp;quot;xy&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int getNextValidCharIndex(const string &amp;amp;str, int index) {
    int backspacesCount = 0;
    while (index &amp;gt;= 0) {
        if (str[index] == &#39;#&#39;) {
            backspacesCount++;
        } else if (backspacesCount &amp;gt; 0) {
            backspacesCount--;
        } else {
            break;
        }

        index--;
    }
    return index;
}

bool compare(const string &amp;amp;str1, const string &amp;amp;str2) {
    int index1 = str1.length() - 1;
    int index2 = str2.length() - 1;
    while (index1 &amp;gt;= 0 || index2 &amp;gt;= 0) {
        int i1 = getNextValidCharIndex(str1, index1);
        int i2 = getNextValidCharIndex(str2, index2);

        if (i1 &amp;lt; 0 &amp;amp;&amp;amp; i2 &amp;lt; 0) {
            return true;
        }

        if (i1 &amp;lt; 0 || i2 &amp;lt; 0) {
            return false;
        }
        if (str1[i1] != str2[i2]) {
            return false;
        }
        index1 = i1 - 1;
        index2 = i2 - 1;
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N+M)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h1 id=&#34;12-mininum-window-sort&#34;&gt;12、mininum window sort&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;求最短子数组的长度，子数组满足条件：当子数组排序后，整个数组是有序的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 2, 5, 3, 7, 10, 9, 12]
    
output:	5

subarray:[5, 3, 7, 10, 9 ]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 3, 2, 0, -1, 7, 10]
    
output:	5

subarray:[ 3, 2, 0, -1, 7 ]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 2, 3]
    
output:	0
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, 2, 1]
    
output:	3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int sort(const vector&amp;lt;int&amp;gt; &amp;amp;arr) {
    int low = 0;
    int high = arr.size() - 1;
    int subarrayMax = INT_MIN;
    int subarrayMin = INT_MAX;

    while (low &amp;lt; arr.size() - 1 &amp;amp;&amp;amp; arr[low] &amp;lt; arr[low + 1]) {
        low++;
    }
    if (low == arr.size() - 1) {
        return 0;
    }
    while (high &amp;gt; 0 &amp;amp;&amp;amp; arr[high] &amp;gt;= arr[high - 1]) {
        high--;
    }

    for (int k = low; k &amp;lt;= high; k++) {
        subarrayMax = max(subarrayMax, arr[k]);
        subarrayMin = min(subarrayMin, arr[k]);
    }
    while (low &amp;gt; 0 &amp;amp;&amp;amp; arr[low - 1] &amp;gt; subarrayMin) {
        low--;
    }
    while (high &amp;lt; arr.size() - 1 &amp;amp;&amp;amp; arr[high + 1] &amp;lt; subarrayMax) {
        high++;
    }
    return high - low + 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-2 Sliding Window</title>
      <link>/code/pattern/sliding-window/</link>
      <pubDate>Sat, 23 May 2020 17:44:03 +0800</pubDate>
      <guid>/code/pattern/sliding-window/</guid>
      <description>

&lt;h3 id=&#34;1-介绍&#34;&gt;1、介绍&lt;/h3&gt;

&lt;p&gt;适用于求&lt;strong&gt;连续&lt;/strong&gt;子数组&lt;/p&gt;

&lt;h3 id=&#34;2-average-of-subarrarys-of-size-k&#34;&gt;2、average of subarrarys of size K&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;求长度为K的连续子数组的平均值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	arrary:[1,3,2,6,-1,4,1,8,2] ,K=5
    
output:	[2.2,2.8,2.4,3.6,2,8]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;double&amp;gt; averageOfSubarrayOfSizeK(int k,vector&amp;lt;int&amp;gt; &amp;amp;arr){
    vector&amp;lt;double&amp;gt; result(arr.size() -k +1);
    int windowStart =0;
    double windowSum =0;
    
    for(int windowEnd =0 ; windowEnd&amp;lt;arr.size() ;windowEnd++){
        //加上下一个元素
        windowSum += arr[windowEnd];
        
        //到达sizeK，滑动窗口
        if(windowEnd &amp;gt;=k-1){
            result[windowStart]=windowSum/k; //计算平均值
            windowSum -=arr[windowStart];  //减去第一个窗口值
            windowStart++; //滑动窗口
        }
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-maximum-sum-of-subarray-of-size-k&#34;&gt;2、maximum sum of subarray of size K&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;求长度为K的连续子数组的最大值&lt;/p&gt;

&lt;p&gt;其中数组元素为正数，K为正数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2,1,5,1,3,2], k=3

output:	9
    
subarray:[5,1,3]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2,3,4,1,5] ,k=2

output:	7
    
 subarray:[3,4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int maxSumSubarrayOfSizeK(int k ,vector&amp;lt;int&amp;gt; &amp;amp;arr){
    int windowStart =0;
    int windowSum=0;
    int maxSum=0;
    
    for(int windowEnd =0; windowEnd&amp;lt;arr.size() ;windowEnd++){
        windowSum +=arr[windowEnd];
        if (windowEnd&amp;gt;=k-1){
            maxSum=max(maxSum,windowSum);
            windowSum -= arr[windowStart];
            windowStart++;
        }
    }
    return maxSum;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time:   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space:  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h3 id=&#34;3-smallest-subarray-whose-sum-is-greater-than-or-equal-to-s&#34;&gt;3、smallest subarray whose sum is greater than or equal to S&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;求最短长度的子数组，使得其和大于等于 S&lt;/p&gt;

&lt;p&gt;其中数组元素为正数，S 为正数；如果子数组不存在，返回0&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2,1,5,2,3,2], S=7
    
output:	2

subarray:[5,2]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3,4,1,1,6],S=8
    
output:	3
    
subarray:[3,4,1],[1,1,6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findMinSubarray(int k, vector&amp;lt;int&amp;gt; &amp;amp;arr){
    int windowSum = 0;
    int minLength = INT_MAX;
    int windowStart = 0;
    
    for (int windowEnd = 0; windowEnd &amp;lt; arr.size(); windowEnd++){
        windowSum += arr[windowEnd];
        
        //当和大于等于K时候，减小窗口大小
        //不确定减去窗口第一个值后，是否满足要求，所以不断减，直到满足K
        while (windowSum &amp;gt;= k){
            //记录满足条件的最小窗口长度
            minLength = min(minLength, windowEnd - windowStart + 1);
            windowSum -= arr[windowStart];
            windowStart++;
        }
    }
    return minLength == INT_MAX ? 0 : minLength;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time:   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space:  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h3 id=&#34;4-longest-subarrary-with-no-more-than-k-distinct-characters&#34;&gt;4、longest subarrary with no more than K distinct characters&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;求包含 不超过K个不同字符 的最长子串的长度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	string=&amp;quot;araaci&amp;quot; ,k=2

output：	4
    
substring:&amp;quot;araa&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	string=&amp;quot;cbbebi&amp;quot; ,k=3

output：	5
    
substring:&amp;quot;cbbeb&amp;quot; &amp;quot;bbebi&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findLength(int k, const string &amp;amp;str) {
    int maxLength = 0;
    int windowStart = 0;
    
    //记录处理过的字符的频率
    unordered_map&amp;lt;char, int&amp;gt; mp;
    
    for (int windowEnd = 0; windowEnd &amp;lt; str.length(); windowEnd++) {
        char rightchar = str[windowEnd];
        mp[rightchar]++;
        //不断减小窗口长度，直到满足K个不同字符
        while (mp.size() &amp;gt; k) {
            char leftchar = str[windowStart];
            mp[leftchar]--;
            //删除值为0的键
            if (mp[leftchar] == 0) {
                mp.erase(leftchar);
            }
            windowStart++;
        }
        //记录满足K的最大长度
        maxLength = max(maxLength, windowEnd - windowStart + 1);
    }
    return maxLength;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time:   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space:  &lt;em&gt;O&lt;/em&gt;(K)&lt;/p&gt;

&lt;h3 id=&#34;5-maximum-number-of-fruits-in-each-basket&#34;&gt;5、maximum number of fruits in each basket&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;字符数组，每个字符代表一种果树，给2个篮子，每个篮子只能装一种水果&lt;/p&gt;

&lt;p&gt;可以从数组任意位置装，不能回头，遇到第三种水果结束&lt;/p&gt;

&lt;p&gt;求两个篮子能装水果的最大值&lt;/p&gt;

&lt;p&gt;同4 ，K=2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findLength(int k, const string &amp;amp;str) {
    int maxLength = 0;
    int windowStart = 0;
    
    //记录处理过的字符的频率
    unordered_map&amp;lt;char, int&amp;gt; mp;
    
    for (int windowEnd = 0; windowEnd &amp;lt; str.length(); windowEnd++) {
        mp[str[windowEnd]]++;
        //不断减小窗口长度，直到满足K个不同字符
        while (mp.size() &amp;gt; k) {
            mp[str[windowStart]]--;
            //删除值为0的键
            if (mp[str[windowStart]] == 0) {
                mp.erase(str[windowStart]);
            }
            windowStart++;
        }
        //记录满足K的最大长度
        maxLength = max(maxLength, windowEnd - windowStart + 1);
    }
    return maxLength;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-no-repeat-substring&#34;&gt;6、no repeat substring&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;求无重复字符的子串的最大长度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	string=&amp;quot;aabccbb&amp;quot;

output:	3

substring:&amp;quot;abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	string=&amp;quot;abccde&amp;quot;

output:	3

substring:&amp;quot;abc&amp;quot; &amp;quot;cde&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findlength(const string &amp;amp;str) {
    int windowStart = 0;
    int maxLength = 0;

    //记录处理后每个字符的最后索引位置，是索引位置，不是频率
    unordered_map&amp;lt;char, int&amp;gt; mp;

    for (int windowEnd = 0; windowEnd &amp;lt; str.size(); windowEnd++) {
        char rightChar = str[windowEnd];

        //如果mp中已经包含rightchar,从windowStart侧缩小窗口
        if (mp.find(rightChar) != mp.end()) {

            //此时窗口还未添加重复元素，改变窗口起始位，比较重复原元素后一位和windowStar大小
            windowStart = max(windowStart, mp[rightChar] + 1);

        }
        //插入rightChar
        mp[rightChar] = windowEnd;
        maxLength = max(maxLength, windowEnd - windowStart + 1);
    }
    return maxLength;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time:   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space:  &lt;em&gt;O&lt;/em&gt;(K)&lt;/p&gt;

&lt;h3 id=&#34;7-longest-substring-with-same-letters-after-replacement&#34;&gt;7、longest substring with same letters after replacement&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;取代不超过K个元素，求包含最长相同元素的字串&lt;/p&gt;

&lt;p&gt;其中字符串全是小写&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	string=&amp;quot;aabccbb&amp;quot; ,k=2

output:	5

substring: bccbb-&amp;gt;bbbbb
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	string=&amp;quot;abccde&amp;quot; ,k=1

output:	3

substring: acc-&amp;gt;ccc ccd-&amp;gt;ccc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findLength(const string &amp;amp;str, int k) {
    int windowStart = 0;
    int maxLength = 0;
    //记录每个窗口内重复最多的元素的个数
    int maxRepeatLetterCount = 0;
    //频率
    unordered_map&amp;lt;char, int&amp;gt; frequencyMap;

    for (int windowEnd = 0; windowEnd &amp;lt; str.size(); windowEnd++) {
        char rightChar = str[windowEnd];
        frequencyMap[rightChar]++;
        maxRepeatLetterCount = max(maxRepeatLetterCount, frequencyMap[rightChar]);

        //窗口的长度减去最多重复的个数，剩下的是可以替换的个数，如果超过K，就要缩小窗口
        if (windowEnd - windowStart + 1 - maxRepeatLetterCount &amp;gt; k) {
            char leftChar = str[windowStart];
            frequencyMap[leftChar]--;
            windowStart++;
        }
        maxLength = max(maxLength, windowEnd - windowStart + 1);
    }
    return maxLength;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time:   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space:  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h3 id=&#34;8-longest-subarray-with-ones-after-replacement&#34;&gt;8、longest subarray with ones after replacement&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;数组只包含0和1，将不超过K个0取代为1，求最长连续只包含1的子数组&lt;/p&gt;

&lt;p&gt;同7&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: arrary=[0,1,1,0,0,0,1,1,0,1,1],k=2

output:	6

index=5,8; 0-&amp;gt;1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: arrary=[0,1,0,0,1,1,0,1,1,0,0,1,1] ,k=3

output:	9

index=6,9,10; 0-&amp;gt;1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findLength(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int k) {
    int windowStart = 0;
    int maxLength = 0;
    //记录每个窗口中1的个数
    int maxOnesCount = 0;

    for (int windowEnd = 0; windowEnd &amp;lt; arr.size(); windowEnd++) {
        if (arr[windowEnd] == 1) {
            maxOnesCount++;
        }
        if (windowEnd - windowStart + 1 - maxOnesCount &amp;gt; k) {
            if (arr[windowStart] == 1) {
                maxOnesCount--;
            }
            windowStart++;
        }
        maxLength = max(maxLength, windowEnd - windowStart + 1);
    }
    return maxLength;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time:   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space:  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h3 id=&#34;9-permutation-in-a-string&#34;&gt;9、permutation in a string&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;文本串和模式串，判断文本串中是否包含模式串的排列&lt;/p&gt;

&lt;p&gt;串的排列：str=“abc”，排列：“abc&amp;rdquo;,&amp;ldquo;acb&amp;rdquo;,&amp;ldquo;bac&amp;rdquo;,&amp;ldquo;bca&amp;rdquo;,&amp;ldquo;cab&amp;rdquo;,&amp;ldquo;cba&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:string=&amp;quot;oidbcaf&amp;quot;,pattern=&amp;quot;abc&amp;quot;
    
output: true
    
permutation:bca&amp;lt;-&amp;gt;abc
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:string=&amp;quot;odicf&amp;quot;,pattern=&amp;quot;dc&amp;quot;
    
output: false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool findPermutation(const string &amp;amp;str, const string &amp;amp;pattern) {
    int windowStart = 0;
    int matched = 0;
    unordered_map&amp;lt;char, int&amp;gt; frequencyMap;
    for (auto c: pattern) {
        frequencyMap[c]++;
    }

    for (int windowEnd = 0; windowEnd &amp;lt; str.size(); windowEnd++) {
        char rightChar = str[windowEnd];
        if (frequencyMap.find(rightChar) != frequencyMap.end()) {
            frequencyMap[rightChar]--;
            if (frequencyMap[rightChar] == 0) {
                matched++;
            }

        }
        if (matched == (int) frequencyMap.size()) {
            return true;
        }

        if (windowEnd &amp;gt;= pattern.length() - 1) {
            char leftChar = str[windowStart];
            windowStart++;
            if (frequencyMap.find(leftChar) != frequencyMap.end()) {
                if (frequencyMap[leftChar] == 0) {
                    matched--;
                }
                frequencyMap[leftChar]++;
            }
        }
    }
    return false;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;10-string-anagrams&#34;&gt;10、string anagrams&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;文本串和模式串，找出文本串中包含模式串的同文异构词的起始索引&lt;/p&gt;

&lt;p&gt;同文异构词就是全排列&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:string=&amp;quot;ppqp&amp;quot;,pattern=&amp;quot;pq&amp;quot;
    
output: [1,2]
    
anagram:&amp;quot;pq&amp;quot;,&amp;quot;qp&amp;quot;,startIndex=[1,2]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:string=&amp;quot;abbcabc&amp;quot;,pattern=&amp;quot;abc&amp;quot;
    
output: [2,3,4]
    
anagram:&amp;quot;bca&amp;quot;,&amp;quot;cab&amp;quot;,&amp;quot;abc&amp;quot;,startIndex=[3,4,5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;int&amp;gt; findStringAnagrams(const string &amp;amp;str, const string &amp;amp;pattern) {
    int windowStart = 0;
    int matched = 0;
    unordered_map&amp;lt;char, int&amp;gt; frequencyMap;
    vector&amp;lt;int&amp;gt; resultIndices;
    for (auto c: pattern) {
        frequencyMap[c]++;
    }

    for (int windowEnd = 0; windowEnd &amp;lt; str.size(); windowEnd++) {
        char rightChar = str[windowEnd];
        if (frequencyMap.find(rightChar) != frequencyMap.end()) {
            frequencyMap[rightChar]--;
            if (frequencyMap[rightChar] == 0) {
                matched++;
            }

        }
        if (matched == (int) frequencyMap.size()) {
            resultIndices.push_back(windowStart);
        }

        if (windowEnd &amp;gt;= pattern.length() - 1) {
            char leftChar = str[windowStart];
            windowStart++;
            if (frequencyMap.find(leftChar) != frequencyMap.end()) {
                if (frequencyMap[leftChar] == 0) {
                    matched--;
                }
                frequencyMap[leftChar]++;
            }
        }
    }
    return resultIndices;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;11-smallest-window-containing-substring&#34;&gt;11、smallest window containing substring&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;文本串和模式串，找出最短的文本字串，使得字串包含模式串所有元素&lt;/p&gt;

&lt;p&gt;与9相似&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:string=&amp;quot;aabdec&amp;quot;,pattern=&amp;quot;abc&amp;quot;
    
output: &amp;quot;abdec&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:string=&amp;quot;abdabca&amp;quot;,pattern=&amp;quot;abc&amp;quot;
    
output: &amp;quot;abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;string findSubstring(const string &amp;amp;str, const string &amp;amp;pattern) {
    int windowStart = 0;
    int matched = 0;
    int minLength = str.length() + 1;
    int subStrStart = 0;
    unordered_map&amp;lt;char, int&amp;gt; frequencyMap;

    for (auto c: pattern) {
        frequencyMap[c]++;
    }

    for (int windowEnd = 0; windowEnd &amp;lt; str.size(); windowEnd++) {
        char rightChar = str[windowEnd];
        if (frequencyMap.find(rightChar) != frequencyMap.end()) {
            frequencyMap[rightChar]--;
            if (frequencyMap[rightChar] == 0) {
                matched++;
            }

        }
        while (matched == (int) pattern.length()) {
            if (minLength &amp;gt; windowEnd - windowStart + 1) {
                minLength = windowEnd - windowStart + 1;
                subStrStart = windowStart;
            }
            char leftChar = str[windowStart];
            windowStart++;
            if (frequencyMap.find(leftChar) != frequencyMap.end()) {
                if (frequencyMap[leftChar] == 0) {
                    matched--;
                }
                frequencyMap[leftChar]++;
            }
        }
    }
    return minLength &amp;gt; str.length() ? &amp;quot;&amp;quot; : str.substr(subStrStart, minLength);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;12-words-concatenation&#34;&gt;12、words concatenation&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;给定一个字符串和一组相同长度的单词组成的字符串数组，在字符串中查找包含数组所有单词的子串，单词在字串中不重叠，求子串的起始位置&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:string=&amp;quot;catfoxcat&amp;quot;,words=[&amp;quot;cat&amp;quot;,&amp;quot;fox&amp;quot;]
    
output: [0,3]

substring:&amp;quot;catfox&amp;quot; -&amp;gt; index=0 ;&amp;quot;foxcat&amp;quot; -&amp;gt;index=3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:string=&amp;quot;catcatfoxfox&amp;quot;,words=[&amp;quot;cat&amp;quot;,&amp;quot;fox&amp;quot;]
    
output: [3]

substring:&amp;quot;catfox&amp;quot; -&amp;gt; index=3 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;程序有误
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-1 Introduction</title>
      <link>/code/pattern/introduction/</link>
      <pubDate>Tue, 19 May 2020 17:36:41 +0800</pubDate>
      <guid>/code/pattern/introduction/</guid>
      <description>&lt;p&gt;课程来源于：&lt;a href=&#34;https://www.educative.io/courses/grokking-the-coding-interview&#34; target=&#34;_blank&#34;&gt;Grokking the Coding Interview: Patterns for Coding Questions&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;课程将面试题目分为14种模式：&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
