[{"authors":["admin"],"categories":null,"content":"学习Go语言中，了解Python，C++\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"学习Go语言中，了解Python，C++","tags":null,"title":"季程雨","type":"authors"},{"authors":[],"categories":[],"content":"","date":1601728984,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1601728984,"objectID":"79a8fa0e82685f963a5765830fe64b85","permalink":"/interview/data-structure/","publishdate":"2020-10-03T20:43:04+08:00","relpermalink":"/interview/data-structure/","section":"interview","summary":"","tags":[],"title":"Data Structure","type":"interview"},{"authors":[],"categories":[],"content":"","date":1601728905,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1601728905,"objectID":"fc871ce50a028b884087285bb4592597","permalink":"/interview/network/","publishdate":"2020-10-03T20:41:45+08:00","relpermalink":"/interview/network/","section":"interview","summary":"","tags":[],"title":"Network","type":"interview"},{"authors":[],"categories":[],"content":"","date":1601728857,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1601728857,"objectID":"424f477c3a53bd3de02044fc06e8840c","permalink":"/interview/large-scale-data/","publishdate":"2020-10-03T20:40:57+08:00","relpermalink":"/interview/large-scale-data/","section":"interview","summary":"","tags":[],"title":"Large Scale Data","type":"interview"},{"authors":[],"categories":[],"content":"","date":1601728735,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1601728735,"objectID":"b5b3d2f4003a3d99bf025307e470cbc3","permalink":"/interview/linux/","publishdate":"2020-10-03T20:38:55+08:00","relpermalink":"/interview/linux/","section":"interview","summary":"","tags":[],"title":"Linux","type":"interview"},{"authors":[],"categories":[],"content":"","date":1601728484,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1601728484,"objectID":"9ab8cee6a64f41303eac9670fe538027","permalink":"/interview/k8s/","publishdate":"2020-10-03T20:34:44+08:00","relpermalink":"/interview/k8s/","section":"interview","summary":"","tags":[],"title":"K8s","type":"interview"},{"authors":[],"categories":[],"content":"","date":1601728457,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1601728457,"objectID":"015367d2d1b032aa881d18ac2debb091","permalink":"/interview/docker/","publishdate":"2020-10-03T20:34:17+08:00","relpermalink":"/interview/docker/","section":"interview","summary":"","tags":[],"title":"Docker","type":"interview"},{"authors":[],"categories":[],"content":"","date":1601728416,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1601728416,"objectID":"e4d8aafb625956e26baf29fb093ce94b","permalink":"/interview/databases/mongodb/","publishdate":"2020-10-03T20:33:36+08:00","relpermalink":"/interview/databases/mongodb/","section":"interview","summary":"","tags":[],"title":"Mongodb","type":"interview"},{"authors":[],"categories":[],"content":"","date":1601728357,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1601728357,"objectID":"2bd4d76c168df7f876133cf4bb019492","permalink":"/interview/databases/redis/","publishdate":"2020-10-03T20:32:37+08:00","relpermalink":"/interview/databases/redis/","section":"interview","summary":"","tags":[],"title":"Redis","type":"interview"},{"authors":[],"categories":[],"content":"","date":1601728341,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1601728341,"objectID":"48dc6ce8f1fdbdda2a4a7246c220265c","permalink":"/interview/databases/mysql/","publishdate":"2020-10-03T20:32:21+08:00","relpermalink":"/interview/databases/mysql/","section":"interview","summary":"","tags":[],"title":"Mysql","type":"interview"},{"authors":[],"categories":[],"content":"","date":1601727913,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1601727913,"objectID":"db6c8f45edea5aa62991fda315f8480e","permalink":"/interview/os/","publishdate":"2020-10-03T20:25:13+08:00","relpermalink":"/interview/os/","section":"interview","summary":"","tags":[],"title":"Os","type":"interview"},{"authors":[],"categories":["leetcode"],"content":" 一. 数组、链表、跳表 11. 盛最多水的容器  给你 n 个非负整数 a1，a2，\u0026hellip;，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n说明：你不能倾斜容器，且 n 的值至少为 2\n https://leetcode-cn.com/problems/container-with-most-water/\n输入：[1,8,6,2,5,4,8,3,7] 输出：49  code\nint maxArea(vector\u0026lt;int\u0026gt; \u0026amp;height) { int start = 0; int end = height.size() - 1; int maxArea = INT_MIN; while (start \u0026lt; end) { int temp = (end - start) * min(height[end], height[start]); maxArea = max(maxArea, temp); if (height[start] \u0026lt; height[end]) { start++; } else { end-- } } return maxArea; }  283. 移动零 https://leetcode-cn.com/problems/move-zeroes/\n 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n example\n输入: [0,1,0,3,12] 输出: [1,3,12,0,0]  code\nvoid moveZeroes(vector\u0026lt;int\u0026gt; \u0026amp;nums) { // 最后的非零值的索引 int lastNonZeroFoundAt = 0; for (int cur = 0; cur \u0026lt; nums.size(); cur++) { if (nums[cur] != 0) { swap(nums[lastNonZeroFoundAt++], nums[cur]); } } }  70. 爬楼梯 https://leetcode-cn.com/problems/climbing-stairs/\n 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n注意：给定 n 是一个正整数。\n example\n输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶  输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶  code\nint climbStairs(int n) { if (n \u0026lt;= 2) { return n; } int i1 = 1; int i2 = 2; for (int i = 2; i \u0026lt; n; i++) { int temp = i1 + i2; i1 = i2; i2 = temp; } return i2; }  ","date":1600177827,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1600177827,"objectID":"897438ebeb338d297f2851a943c5f54e","permalink":"/code/leetcode/","publishdate":"2020-09-15T21:50:27+08:00","relpermalink":"/code/leetcode/","section":"code","summary":"算法训练营题目","tags":["leetcode"],"title":"Leetcode","type":"code"},{"authors":[],"categories":["interview"],"content":" 1. 工作区和GOPATH 问：你知道设置 GOPATH 有什么意义吗？\n你可以把 GOPATH 简单理解成 Go 语言的工作目录，它的值是一个目录的路径，也可以是多个目录路径，每个目录都代表 Go 语言的一个工作区（workspace）。\n我们需要利于这些工作区，去放置 Go 语言的源码文件（source file），以及安装（install）后的归档文件（archive file，也就是以“.a”为扩展名的文件）和可执行文件（executable file）。\n\n事实上，由于 Go 语言项目在其生命周期内的所有操作（编码、依赖管理、构建、测试、安装等）基本上都是围绕着 GOPATH 和工作区进行的。所以，它的背后至少有 3 个知识点，\n分别是：\n1.1. Go 语言源码的组织方式是怎样的；\nGo 语言的源码也是以代码包为基本组织单位的。在文件系统中，这些代码包其实是与目录一一对应的。由于目录可以有子目录，所以代码包也可以有子包。\n一个代码包中可以包含任意个以.go 为扩展名的源码文件，这些源码文件都需要被声明属于同一个代码包。\n代码包的名称一般会与源码文件所在的目录同名。如果不同名，那么在构建、安装的过程中会以代码包名称为准。每个代码包都会有导入路径。代码包的导入路径是其他代码在使用该包中的程序实体时，需要引入的路径。在实际使用程序实体之前，我们必须先导入其所在的代码包。具体的方式就是import该代码包的导入路径。\n在工作区中，一个代码包的导入路径实际上就是从 src 子目录，到该包的实际存储位置的相对路径。\n所以说，Go 语言源码的组织方式就是以环境变量 GOPATH、工作区、src 目录和代码包为主线的。一般情况下，Go 语言的源码文件都需要被存放在环境变量 GOPATH 包含的某个工作区（目录）中的 src 目录下的某个代码包（目录）中。\n1.2. 你是否了解源码安装后的结果（只有在安装后，Go 语言源码才能被我们或其他代码使\n用）；\n源码文件通常会被放在某个工作区的 src 子目录下。那么在安装后如果产生了归档文件（以“.a”为扩展名的文件），就会放进该工作区的 pkg子目录；如果产生了可执行文件，就可能会放进该工作区的 bin 子目录。\n1.3. 你是否理解构建和安装 Go 程序的过程（这在开发程序以及查找程序问题的时候都很有\n用，否则你很可能会走弯路）。\n构建使用命令go build，安装使用命令go install。构建和安装代码包的时候都会执行编译、打包等操作，并且，这些操作生成的任何文件都会先被保存到某个临时的目录中。\n如果构建的是库源码文件，那么操作后产生的结果文件只会存在于临时目录中。这里的构建的主要意义在于检查和验证。\n如果构建的是命令源码文件，那么操作的结果文件会被搬运到源码文件所在的目录中。\n\n2. 命令源码文件 问：命令源码文件的用途是什么，怎样编写它？\n命令源码文件是程序的运行入口，是每个可独立运行的程序必须拥有的。我们可以通过构建或安装，生成与其对应的可执行文件，后者一般会与该命令源码文件的直接父目录同名。\n如果一个源码文件声明属于main包，并且包含一个无参数声明且无结果声明的main函数，那么它就是命令源码文件。 就像下面这段代码：\npackage main import \u0026quot;fmt\u0026quot; func main() { fmt.Println(\u0026quot;Hello, world!\u0026quot;) }  如果你把这段代码存成 demo1.go 文件，那么运行go run demo1.go命令后就会在屏幕（标准输出）中看到Hello, world!\n 当需要模块化编程时，我们往往会将代码拆分到多个文件，甚至拆分到不同的代码包中。但无论怎样，对于一个独立的程序来说，命令源码文件永远只会也只能有一个。如果有与命令源码文件同包的源码文件，那么它们也应该声明属于main包。\n \n3. 库源码文件 库源码文件是不能被直接运行的源码文件，它仅用于存放程序实体，这些程序实体可以被其他代码使用（只要遵从 Go 语言规范的话）。\n这里的“其他代码”可以与被使用的程序实体在同一个源码文件内，也可以在其他源码文件，甚至其他代码包中。\n 那么程序实体是什么呢？在 Go 语言中，程序实体是变量、常量、函数、结构体和接口的统称。\n我们总是会先声明（或者说定义）程序实体，然后再去使用。比如在上一篇的例子中，我们先定义了变量name，然后在main函数中调用fmt.Printf函数的时候用到了它。\n再多说一点，程序实体的名字被统称为标识符。标识符可以是任何 Unicode 编码可以表示的字母字符、数字以及下划线“_”，但是其首字母不能是数字。\n从规则上说，我们可以用中文作为变量的名字。但是，我觉得这种命名方式非常不好，自己也会在开发团队中明令禁止这种做法。作为一名合格的程序员，我们应该向着编写国际水准的程序无限逼近。\n 问：怎样把命令源码文件中的代码拆分到其他库源码文件？\n第一条规则，同目录下的源码文件的代码包声明语句要一致。也就是说，它们要同属于一个代码包。这对于所有源码文件都是适用的。\n如果目录中有命令源码文件，那么其他种类的源码文件也应该声明属于main包。这也是我们能够成功构建和运行它们的前提。\n第二条规则，源码文件声明的代码包的名称可以与其所在的目录的名称不同。在针对代码包进行构建时，生成的结果文件的主名称与其父目录的名称一致。\n对于命令源码文件而言，构建生成的可执行文件的主名称会与其父目录的名称相同，这在我前面的回答中也验证过了。\n\n4. 程序实体的那些事儿（上） Go 语言中的程序实体包括变量、常量、函数、结构体和接口。 Go 语言是静态类型的编程语言，所以我们在声明变量或常量的时候，都需要指定它们的类型，或者给予足够的信息，这样才可以让 Go 语言能够推导出它们的类型。\n 在 Go 语言中，变量的类型可以是其预定义的那些类型，也可以是程序自定义的函数、结构体或接口。常量的合法类型不多，只能是那些 Go 语言预定义的基本类型。它的声明方式也更简单一些\n 问：声明变量有几种方式？\n一个是你要知道 Go 语言中的类型推断，以及它在代码中的基本体现，另一个是短变量声明的用法。\n问：Go 语言的类型推断可以带来哪些好处？\nGo 语言的类型推断可以明显提升程序的灵活性，使得代码重构变得更加容易，同时又不会给代码的维护带来额外负担（实际上，它恰恰可以避免散弹式的代码修改），更不会损失程序的运行效率。\n问：2. 变量的重声明是什么意思？\n这涉及了短变量声明。通过使用它，我们可以对同一个代码块中的变量进行重声明。其含义是对已经声明过的变量再次声明。变量重声明的前提条件如下。\n 由于变量的类型在其初始化时就已经确定了，所以对它再次声明时赋予的类型必须与其原本的类型相同，否则会产生编译错误。 变量的重声明只可能发生在某一个代码块中。如果与当前的变量重名的是外层代码块中的变量，那么就是另外一种含义了，我在下一篇文章中会讲到。 变量的重声明只有在使用短变量声明时才会发生，否则也无法通过编译。如果要在此处声明全新的变量，那么就应该使用包含关键字var的声明语句，但是这时就不能与同一个代码块中的任何变量有重名了\u0010\u0010。 被“声明并赋值”的变量必须是多个，并且其中至少有一个是新的变量。这时我们才可以说对其中的旧变量进行了重声明。  这样来看，变量重声明其实算是一个语法糖（或者叫便利措施）。它允许我们在使用短变量声明时不用理会被赋值的多个变量中是否包含旧变量。\n5. 程序实体的那些事儿（中） 程序实体的访问权限有三种：包级私有的、模块级私有的和公开的。这其实就是 Go 语言在语言层面，依据代码块对程序实体作用域进行的定义。\n一个程序实体的作用域总是会被限制在某个代码块中，而这个作用域最大的用处，就是对程序实体的访问权限的控制。对“高内聚，低耦合”这种程序设计思想的实践，恰恰可以从这里开始。\n问：如果一个变量与其外层代码块中的变量重名会出现什么状况\npackage main import \u0026quot;fmt\u0026quot; var block = \u0026quot;package\u0026quot; func main() { block := \u0026quot;function\u0026quot; { block := \u0026quot;inner\u0026quot; fmt.Printf(\u0026quot;The block is %s.\\n\u0026quot;, block) } fmt.Printf(\u0026quot;The block is %s.\\n\u0026quot;, block) }  这个命令源码文件中有四个代码块，它们是：全域代码块、main包代表的代码块、main函数代表的代码块，以及在main函数中的一个用花括号包起来的代码块。\n能通过编译。运行后打印出的内容是：\nThe block is inner. The block is function.   首先，代码引用变量的时候总会最优先查找当前代码块中的那个变量。注意，这里的“当前代码块”仅仅是引用变量的代码所在的那个代码块，并不包含任何子代码块。 其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接包含当前代码块的那个代码块开始，一层一层地查找。 一般情况下，程序会一直查到当前代码包代表的代码块。如果仍然找不到，那么 Go 语言的编译器就会报错了  问：不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿？\n为了方便描述，我就把不同代码块中的重名变量叫做“可重名变量”吧。注意，在同一个代码块中不允许出现重名的变量，这违背了 Go 语言的语法。关于这两者的表象和机理，我们已经讨论得足够充分了。你现在可以说出几条区别？请想一想，然后再看下面的列表。\n 变量重声明中的变量一定是在某一个代码块内的。注意，这里的“某一个代码块内”并不包含它的任何子代码块，否则就变成了“多个代码块之间”。而可重名变量指的正是在多个代码块之间由相同的标识符代表的变量。 变量重声明是对同一个变量的多次声明，这里的变量只有一个。而可重名变量中涉及的变量肯定是有多个的。 不论对变量重声明多少次，其类型必须始终一致，具体遵从它第一次被声明时给定的类型。而可重名变量之间不存在类似的限制，它们的类型可以是任意的。 如果可重名变量所在的代码块之间，存在直接或间接的嵌套关系，那么它们之间一定会存在“屏蔽”的现象。但是这种现象绝对不会在变量重声明的场景下出现。  \n6. 程序实体的那些事儿 （下) 问：怎样判断一个变量的类型\n答案是使用“类型断言”表达式。具体怎么写呢？\nvalue, ok := interface{}(container).([]string)  这里有一条赋值语句。在赋值符号的右边，是一个类型断言表达式。\n它包括了用来把container变量的值转换为空接口值的interface{}(container)。以及一个用于判断前者的类型是否为切片类型 []string 的 .([]string)。\n这个表达式的结果可以被赋给两个变量，在这里由value和ok代表。变量ok是布尔（bool）类型的，它将代表类型判断的结果，true或false。\n如果是true，那么被判断的值将会被自动转换为[]string类型的值，并赋给变量value，否则value将被赋予nil（即“空”）。\n顺便提一下，这里的ok也可以没有。也就是说，类型断言表达式的结果，可以只被赋给一个变量，在这里是value。\n但是这样的话，当判断为否时就会引发异常。\n这种异常在 Go 语言中被叫做panic，我把它翻译为运行时恐慌。因为它是一种在 Go 程序运行期间才会被抛出的异常，而“恐慌”二字是英文 Panic 的中文直译。\n除非显式地“恢复”这种“恐慌”，否则它会使 Go 程序崩溃并停止。所以，在一般情况下，我们还是应该使用带ok变量的写法。\n问题解析\n正式说明一下，类型断言表达式的语法形式是x.(T)。其中的x代表要被判断类型的值。这个值当下的类型必须是接口类型的，不过具体是哪个接口类型其实是无所谓的。\n所以，当这里的container变量类型不是任何的接口类型时，我们就需要先把它转成某个接口类型的值。\n如果container是某个接口类型的，那么这个类型断言表达式就可以是container.([]string)。\n在 Go 语言中，interface{}代表空接口，任何类型都是它的实现类型。现在你只要知道，任何类型的值都可以很方便地被转换成空接口的值就行了。\n其中的x可以是一个变量，也可以是一个代表值的字面量（比如1.23和struct{}），还可以是一个表达式。\n注意，如果是表达式，那么该表达式的结果只能是一个值，而不能是多个值。在这个上下文中，x可以被叫做源值，它的类型就是源类型，而那个T代表的类型就是目标类型。\n\n问：什么是别名类型？什么是潜在类型？\n我们可以用关键字type声明自定义的各种类型。当然了，这些类型必须在 Go 语言基本类型和高级类型的范畴之内。在它们当中，有一种被叫做“别名类型”的类型。我们可以像下面这样声明它：\ntype MyString = string  这条声明语句表示，MyString是string类型的别名类型。顾名思义，别名类型与其源类型的区别恐怕只是在名称上，它们是完全相同的。\n源类型与别名类型是一对概念，是两个对立的称呼。别名类型主要是为了代码重构而存在的。更详细的信息可参见 Go 语言官方的文档Proposal: Type Aliases。\nGo 语言内建的基本类型中就存在两个别名类型。byte是uint8的别名类型，而rune是int32的别名类型。\n一定要注意，如果我这样声明：\ntype MyString2 string // 注意，这里没有等号。  MyString2和string就是两个不同的类型了。这里的MyString2是一个新的类型，不同于其他任何类型。\n这种方式也可以被叫做对类型的再定义。我们刚刚把string类型再定义成了另外一个类型MyString2。\n7. 数组和切片 数组类型的值（以下简称数组）的长度是固定的，而切片类型的值（以下简称切片）是可变长的。\n数组的长度在声明它的时候就必须给定，并且之后不会再改变。可以说，数组的长度是其类型的一部分。比如，[1]string和[2]string就是两个不同的数组类型。\n问：怎样正确估算切片的长度和容量？\n当我们用make函数初始化切片时，如果不指明其容量，那么它就会和长度一致。如果在初始化时指明了容量，那么切片的实际容量也就是它了。\n切片的容量代表了它的底层数组的长度，但这仅限于使用make函数或者切片值字面量初始化切片的情况。\n问：怎样估算切片容量的增长？\n一旦一个切片无法容纳更多的元素，Go 语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中。在一般的情况下，你可以简单地认为新切片的容量（以下简称新容量）将会是原切片容量（以下简称原容量）的 2 倍。\n但是，当原切片的长度（以下简称原长度）大于或等于1024时，Go 语言将会以原容量的1.25倍作为新容量的基准（以下新容量基准）。新容量基准会被调整（不断地与1.25相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）。最终，新容量往往会比新长度大一些，当然，相等也是可能的。\n另外，如果我们一次追加的元素过多，以至于使新长度比原容量的 2 倍还要大，那么新容量就会以新长度为基准。注意，与前面那种情况一样，最终的新容量在很多时候都要比新容量基准更大一些。更多细节可参见runtime包中 slice.go 文件里的growslice及相关函数的具体实现。\n我把展示上述扩容策略的一些例子都放到了 demo16.go 文件中。你可以去试运行看看。\n问：切片的底层数组什么时候会被替换？\n确切地说，一个切片的底层数组永远不会被替换。为什么？虽然在扩容的时候 Go 语言一定会生成新的底层数组，但是它也同时生成了新的切片。\n它只是把新的切片作为了新底层数组的窗口，而没有对原切片，及其底层数组做任何改动。\n请记住，在无需扩容时，append函数返回的是指向原底层数组的新切片，而在需要扩容时，append函数返回的是指向新底层数组的新切片。所以，严格来讲，“扩容”这个词用在这里虽然形象但并不合适。不过鉴于这种称呼已经用得很广泛了，我们也没必要另找新词了。\n顺便说一下，只要新长度不会超过切片的原容量，那么使用append函数对其追加元素的时候就不会引起扩容。这只会使紧邻切片窗口右边的（底层数组中的）元素被新的元素替换掉。\n8. container包中的那些容器 Go 语言的链表实现在标准库的container/list代码包中。这个代码包中有两个公开的程序实体——List和Element，List 实现了一个双向链表（以下简称链表），而 Element 则代表了链表中元素的结构。\n问：可以把自己生成的Element类型值传给链表吗\n我们在这里用到了List的四种方法。\nMoveBefore方法和MoveAfter方法，它们分别用于把给定的元素移动到另一个元素的前面和后面。\nMoveToFront方法和MoveToBack方法，分别用于把给定的元素移动到链表的最前端和最后端。\n在这些方法中，“给定的元素”都是*Element类型的，*Element类型是Element类型的指针类型，*Element的值就是元素的指针。\nfunc (l *List) MoveBefore(e, mark *Element) func (l *List) MoveAfter(e, mark *Element) func (l *List) MoveToFront(e *Element) func (l *List) MoveToBack(e *Element)  具体问题是，如果我们自己生成这样的值，然后把它作为“给定的元素”传给链表的方法，那么会发生什么？链表会接受它吗？\n这里，给出一个典型回答：不会接受，这些方法将不会对链表做出任何改动。因为我们自己生成的Element值并不在链表中，所以也就谈不上“在链表中移动元素”。更何况链表不允许我们把自己生成的Element值插入其中。\n问题解析\n在List包含的方法中，用于插入新元素的那些方法都只接受interface{}类型的值。这些方法在内部会使用Element值，包装接收到的新元素。\n这样做正是为了避免直接使用我们自己生成的元素，主要原因是避免链表的内部关联，遭到外界破坏，这对于链表本身以及我们这些使用者来说都是有益的。\nList的方法还有下面这几种：\nFront和Back方法分别用于获取链表中最前端和最后端的元素， InsertBefore和InsertAfter方法分别用于在指定的元素之前和之后插入新元素，PushFront和PushBack方法则分别用于在链表的最前端和最后端插入新元素。\nfunc (l *List) Front() *Element func (l *List) Back() *Element func (l *List) InsertBefore(v interface{}, mark *Element) *Element func (l *List) InsertAfter(v interface{}, mark *Element) *Element func (l *List) PushFront(v interface{}) *Element func (l *List) PushBack(v interface{}) *Element  这些方法都会把一个Element值的指针作为结果返回，它们就是链表留给我们的安全“接口”。拿到这些内部元素的指针，我们就可以去调用前面提到的用于移动元素的方法了。\n知识扩展\n问：为什么链表可以做到开箱即用？\nList和Element都是结构体类型。结构体类型有一个特点，那就是它们的零值都会是拥有特定结构，但是没有任何定制化内容的值，相当于一个空壳。值中的字段也都会被分别赋予各自类型的零值。\n 广义来讲，所谓的零值就是只做了声明，但还未做初始化的变量被给予的缺省值。每个类型的零值都会依据该类型的特性而被设定。\n比如，经过语句var a [2]int声明的变量a的值，将会是一个包含了两个0的整数数组。又比如，经过语句var s []int声明的变量s的值将会是一个[]int类型的、值为nil的切片。\n 那么经过语句var l list.List声明的变量l的值将会是什么呢？[1] 这个零值将会是一个长度为0的链表。这个链表持有的根元素也将会是一个空壳，其中只会包含缺省的内容。那这样的链表我们可以直接拿来使用吗？\n答案是，可以的。这被称为“开箱即用”。Go 语言标准库中很多结构体类型的程序实体都做到了开箱即用。这也是在编写可供别人使用的代码包（或者说程序库）时，我们推荐遵循的最佳实践之一。那么，语句var l list.List声明的链表l可以直接使用，这是怎么做到的呢？\n关键在于它的“延迟初始化”机制。\n所谓的延迟初始化，你可以理解为把初始化操作延后，仅在实际需要的时候才进行。延迟初始化的优点在于“延后”，它可以分散初始化操作带来的计算量和存储空间消耗。\n例如，如果我们需要集中声明非常多的大容量切片的话，那么那时的 CPU 和内存空间的使用量肯定都会一个激增，并且只有设法让其中的切片及其底层数组被回收，内存使用量才会有所降低。\n如果数组是可以被延迟初始化的，那么计算量和存储空间的压力就可以被分散到实际使用它们的时候。这些数组被实际使用的时间越分散，延迟初始化带来的优势就会越明显。\n 实际上，Go 语言的切片就起到了延迟初始化其底层数组的作用，你可以想一想为什么会这么说的理由。\n延迟初始化的缺点恰恰也在于“延后”。你可以想象一下，如果我在调用链表的每个方法的时候，它们都需要先去判断链表是否已经被初始化，那这也会是一个计算量上的浪费。在这些方法被非常频繁地调用的情况下，这种浪费的影响就开始显现了，程序的性能将会降低。\n 在这里的链表实现中，一些方法是无需对是否初始化做判断的。比如Front方法和Back方法，一旦发现链表的长度为0, 直接返回nil就好了。\n又比如，在用于删除元素、移动元素，以及一些用于插入元素的方法中，只要判断一下传入的元素中指向所属链表的指针，是否与当前链表的指针相等就可以了。\n如果不相等，就一定说明传入的元素不是这个链表中的，后续的操作就不用做了。反之，就一定说明这个链表已经被初始化了。\n原因在于，链表的PushFront方法、PushBack方法、PushBackList方法以及PushFrontList方法总会先判断链表的状态，并在必要时进行初始化，这就是延迟初始化。\n而且，我们在向一个空的链表中添加新元素的时候，肯定会调用这四个方法中的一个，这时新元素中指向所属链表的指针，一定会被设定为当前链表的指针。所以，指针相等是链表已经初始化的充分必要条件。\n明白了吗？List利用了自身以及Element在结构上的特点，巧妙地平衡了延迟初始化的优缺点，使得链表可以开箱即用，并且在性能上可以达到最优。\n问：Ring与List的区别在哪儿？\ncontainer/ring包中的Ring类型实现的是一个循环链表，也就是我们俗称的环。其实List在内部就是一个循环链表。它的根元素永远不会持有任何实际的元素值，而该元素的存在就是为了连接这个循环链表的首尾两端。\n所以也可以说，List的零值是一个只包含了根元素，但不包含任何实际元素值的空链表。那么，既然Ring和List在本质上都是循环链表，那它们到底有什么不同呢？\n最主要的不同有下面几种。\n Ring类型的数据结构仅由它自身即可代表，而List类型则需要由它以及Element类型联合表示。这是表示方式上的不同，也是结构复杂度上的不同。 一个Ring类型的值严格来讲，只代表了其所属的循环链表中的一个元素，而一个List类型的值则代表了一个完整的链表。这是表示维度上的不同。 在创建并初始化一个Ring值的时候，我们可以指定它包含的元素的数量，但是对于一个List值来说却不能这样做（也没有必要这样做）。循环链表一旦被创建，其长度是不可变的。这是两个代码包中的New函数在功能上的不同，也是两个类型在初始化值方面的第一个不同。 仅通过var r ring.Ring语句声明的r将会是一个长度为1的循环链表，而List类型的零值则是一个长度为0的链表。别忘了List中的根元素不会持有实际元素值，因此计算长度时不会包含它。这是两个类型在初始化值方面的第二个不同。 Ring值的Len方法的算法复杂度是 O(N) 的，而List值的Len方法的算法复杂度则是 O(1) 的。这是两者在性能方面最显而易见的差别。  其他的不同基本上都是方法方面的了。比如，循环链表也有用于插入、移动或删除元素的方法，不过用起来都显得更抽象一些，等等。\n\n9. 字典的操作和约束 为什么字典的键类型会受到约束？\nGo 语言的字典类型其实是一个哈希表（hash table）的特定实现，在这个实现中，键和元素的最大不同在于，键的类型是受限的，而元素却可以是任意类型的。\n如果要探究限制的原因，我们就先要了解哈希表中最重要的一个过程：映射。\n你可以把键理解为元素的一个索引，我们可以在哈希表中通过键查找与它成对的那个元素。\n映射过程的第一步就是：把键值转换为哈希值。**\n在 Go 语言的字典中，每一个键值都是由它的哈希值代表的。也就是说，字典不会独立存储任何键的值，但会独立存储它们的哈希值。\n问：字典的键类型不能是哪些类型？\nGo 语言字典的键类型不可以是函数类型、字典类型和切片类型。\nGo 语言规范规定，在键类型的值之间必须可以施加操作符==和!=。换句话说，键类型的值必须要支持判等操作。由于函数类型、字典类型和切片类型的值并不支持判等操作，所以字典的键类型不能是这些类型。\n另外，如果键的类型是接口类型的，那么键值的实际类型也不能是上述三种类型，否则在程序运行过程中会引发 panic（即运行时恐慌）。\n我们举个例子：\nvar badMap2 = map[interface{}]int{ \u0026quot;1\u0026quot;: 1, []int{2}: 2, // 这里会引发 panic。 3: 3, }  这里的变量badMap2的类型是键类型为interface{}、值类型为int的字典类型。这样声明并不会引起什么错误。或者说，我通过这样的声明躲过了 Go 语言编译器的检查。\n注意，我用字面量在声明该字典的同时对它进行了初始化，使它包含了三个键 - 元素对。其中第二个键 - 元素对的键值是[]int{2}，元素值是2。这样的键值也不会让 Go 语言编译器报错，因为从语法上说，这样做是可以的。\n但是，当我们运行这段代码的时候，Go 语言的运行时（runtime）系统就会发现这里的问题，它会抛出一个 panic，并把根源指向字面量中定义第二个键 - 元素对的那一行。我们越晚发现问题，修正问题的成本就会越高，所以最好不要把字典的键类型设定为任何接口类型。\n还要注意，如果键的类型是数组类型，那么还要确保该类型的元素类型不是函数类型、字典类型或切片类型。\n问：应该优先考虑哪些类型作为字典的键类型？\n你现在已经清楚了，在 Go 语言中，有些类型的值是支持判等的，有些是不支持的。那么在这些值支持判等的类型当中，哪些更适合作为字典的键类型呢？\n求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。\n答案是，优先选用数值类型和指针类型，通常情况下类型的宽度越小越好。如果非要选择字符串类型的话，最好对键值的长度进行额外的约束。\n问题 2：在值为nil的字典上执行读操作会成功吗，那写操作呢？\n由于字典是引用类型，所以当我们仅声明而不初始化一个字典类型的变量的时候，它的值会是nil。\n除了添加键 - 元素对，我们在一个值为nil的字典上做任何操作都不会引起错误。当我们试图在一个值为nil的字典中添加键 - 元素对的时候，Go 语言的运行时系统就会立即抛出一个 panic。\n\n10. 通道的基本操作 通道类型的值本身就是并发安全的，这也是 Go 语言自带的、唯一一个可以满足并发安全性的类型。\n当容量为0时，我们可以称通道为非缓冲通道，也就是不带缓冲的通道。而当容量大于0时，我们可以称为缓冲通道，也就是带有缓冲的通道\n一个通道相当于一个先进先出（FIFO）的队列。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。元素值的发送和接收都需要用到操作符\u0026lt;-。我们也可以叫它接送操作符。一个左尖括号紧接着一个减号形象地代表了元素值的传输方向。\n问：对通道的发送和接收操作都有哪些基本的特性？\n它们的基本特性如下。\n 对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。 发送操作和接收操作中对元素值的处理都是不可分割的。 发送操作在完全完成之前会被阻塞。接收操作也是如此。  问题解析\n我们先来看第一个基本特性。 在同一时刻，Go 语言的运行时系统（以下简称运行时系统）只会执行对同一个通道的任意个发送操作中的某一个。\n直到这个元素值被完全复制进该通道之后，其他针对该通道的发送操作才可能被执行。\n类似的，在同一时刻，运行时系统也只会执行，对同一个通道的任意个接收操作中的某一个。\n直到这个元素值完全被移出该通道之后，其他针对该通道的接收操作才可能被执行。即使这些操作是并发执行的也是如此。\n这里所谓的并发执行，你可以这样认为，多个代码块分别在不同的 goroutine 之中，并有机会在同一个时间段内被执行。\n另外，对于通道中的同一个元素值来说，发送操作和接收操作之间也是互斥的。例如，虽然会出现，正在被复制进通道但还未复制完成的元素值，但是这时它绝不会被想接收它的一方看到和取走。\n这里要注意的一个细节是，元素值从外界进入通道时会被复制。更具体地说，进入通道的并不是在接收操作符右边的那个元素值，而是它的副本。\n另一方面，元素值从通道进入外界时会被移动。这个移动操作实际上包含了两步，第一步是生成正在通道中的这个元素值的副本，并准备给到接收方，第二步是删除在通道中的这个元素值。\n顺着这个细节再来看第二个基本特性。 这里的“不可分割”的意思是，它们处理元素值时都是一气呵成的，绝不会被打断。\n例如，发送操作要么还没复制元素值，要么已经复制完毕，绝不会出现只复制了一部分的情况。\n又例如，接收操作在准备好元素值的副本之后，一定会删除掉通道中的原值，绝不会出现通道中仍有残留的情况。\n这既是为了保证通道中元素值的完整性，也是为了保证通道操作的唯一性。对于通道中的同一个元素值来说，它只可能是某一个发送操作放入的，同时也只可能被某一个接收操作取出。\n再来说第三个基本特性。 一般情况下，发送操作包括了“复制元素值”和“放置副本到通道内部”这两个步骤。\n在这两个步骤完全完成之前，发起这个发送操作的那句代码会一直阻塞在那里。也就是说，在它之后的代码不会有执行的机会，直到这句代码的阻塞解除。\n更细致地说，在通道完成发送操作之后，运行时系统会通知这句代码所在的 goroutine，以使它去争取继续运行代码的机会。\n另外，接收操作通常包含了“复制通道内的元素值”“放置副本到接收方”“删掉原值”三个步骤。\n在所有这些步骤完全完成之前，发起该操作的代码也会一直阻塞，直到该代码所在的 goroutine 收到了运行时系统的通知并重新获得运行机会为止。\n说到这里，你可能已经感觉到，如此阻塞代码其实就是为了实现操作的互斥和元素值的完整。\n知识扩展\n问题 1：发送操作和接收操作在什么时候可能被长时间的阻塞？\n先说针对缓冲通道的情况。如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。\n这时，通道会优先通知最早因此而等待的、那个发送操作所在的 goroutine，后者会再次执行发送操作。\n由于发送操作在这种情况下被阻塞后，它们所在的 goroutine 会顺序地进入通道内部的发送等待队列，所以通知的顺序总是公平的。\n相对的，如果通道已空，那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。这时，通道会通知最早等待的那个接收操作所在的 goroutine，并使它再次执行接收操作。\n因此而等待的、所有接收操作所在的 goroutine，都会按照先后顺序被放入通道内部的接收等待队列。\n对于非缓冲通道，情况要简单一些。无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。由此可见，非缓冲通道是在用同步的方式传递数据。也就是说，只有收发双方对接上了，数据才会被传递。\n并且，数据是直接从发送方复制到接收方的，中间并不会用非缓冲通道做中转。相比之下，缓冲通道则在用异步的方式传递数据。\n在大多数情况下，缓冲通道会作为收发双方的中间件。正如前文所述，元素值会先从发送方复制到缓冲通道，之后再由缓冲通道复制给接收方。\n但是，当发送操作在执行的时候发现空的通道中，正好有等待的接收操作，那么它会直接把元素值复制给接收方。\n以上说的都是在正确使用通道的前提下会发生的事情。下面我特别说明一下，由于错误使用通道而造成的阻塞。\n对于值为nil的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态。它们所属的 goroutine 中的任何代码，都不再会被执行。\n注意，由于通道类型是引用类型，所以它的零值就是nil。换句话说，当我们只声明该类型的变量但没有用make函数对它进行初始化时，该变量的值就会是nil。我们一定不要忘记初始化通道！\n你可以去看一下 demo21.go，我在里面用代码罗列了一下会造成阻塞的几种情况。\n问题 2：发送操作和接收操作在什么时候会引发 panic？\n对于一个已初始化，但并未关闭的通道来说，收发操作一定不会引发 panic。但是通道一旦关闭，再对它进行发送操作，就会引发 panic。\n另外，如果我们试图关闭一个已经关闭了的通道，也会引发 panic。注意，接收操作是可以感知到通道的关闭的，并能够安全退出。\n更具体地说，当我们把接收表达式的结果同时赋给两个变量时，第二个变量的类型就是一定bool类型。它的值如果为false就说明通道已经关闭，并且再没有元素值可取了。\n注意，如果通道关闭时，里面还有元素值未被取出，那么接收表达式的第一个结果，仍会是通道中的某一个元素值，而第二个结果值一定会是true。\n因此，通过接收表达式的第二个结果值，来判断通道是否关闭是可能有延时的。\n由于通道的收发操作有上述特性，所以除非有特殊的保障措施，我们千万不要让接收方关闭通道，而应当让发送方做这件事。\n","date":1595950506,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595950506,"objectID":"75070b357bb0cb54c514e1cbfa4d9d1c","permalink":"/go/interview/gocore36-interview/","publishdate":"2020-07-28T23:35:06+08:00","relpermalink":"/go/interview/gocore36-interview/","section":"go","summary":"面试题答案","tags":["Go"],"title":"Go语言核心36讲面试题","type":"go"},{"authors":[],"categories":["interview"],"content":" 基础概念篇 1. Go 语言在多个工作区中查找依赖包的时候是以怎样的顺序进行的？ 答：你设置的环境变量GOPATH的值决定了这个顺序。如果你在GOPATH中设置了多个工作区，那么这种查找会以从左到右的顺序在这些工作区中进行。\n你可以通过试验来确定这个问题的答案。例如：先在一个源码文件中导入一个在你的机器上并不存在的代码包，然后编译这个代码文件。最后，将输出的编译错误信息与GOPATH的值进行对比。\n2. 如果在多个工作区中都存在导入路径相同的代码包会产生冲突吗？ 答：不会产生冲突。因为代码包的查找是按照已给定的顺序逐一地在多个工作区中进行的。\n3. 默认情况下，我们可以让命令源码文件接受哪些类型的参数值？ 答：这个问题通过查看flag代码包的文档就可以回答了。概括来讲，有布尔类型、整数类型、浮点数类型、字符串类型，以及time.Duration类型。\n4. 我们可以把自定义的数据类型作为参数值的类型吗？如果可以，怎样做？ 答：狭义上讲是不可以的，但是广义上讲是可以的。这需要一些定制化的工作，并且被给定的参数值只能是序列化的。具体可参见flag代码包文档中的例子。\n5. 如果你需要导入两个代码包，而这两个代码包的导入路径的最后一级是相同的，比如：dep/lib/flag和flag，那么会产生冲突吗？ 答：这会产生冲突。因为代表两个代码包的标识符重复了，都是flag。\n6. 如果会产生冲突，那么怎样解决这种冲突？有几种方式？ 答：接上一个问题。很简单，导入代码包的时候给它起一个别名就可以了，比如： import libflag \u0026quot;dep/lib/flag\u0026quot;。或者，以本地化的方式导入代码包，如：import . \u0026quot;dep/lib/flag\u0026quot;。\n7. 如果与当前的变量重名的是外层代码块中的变量，那么意味着什么？ 答：这意味着这两个变量成为了“可重名变量”。在内层的变量所处的那个代码块以及更深层次的代码块中，这个变量会“屏蔽”掉外层代码块中的那个变量。\n8. 如果通过import . XXX这种方式导入的代码包中的变量与当前代码包中的变量重名了，那么 Go 语言是会把它们当做“可重名变量”看待还是会报错呢？ 答：这两个变量会成为“可重名变量”。虽然这两个变量在这种情况下的作用域都是当前代码包的当前文件，但是它们所处的代码块是不同的。\n当前文件中的变量处在该文件所代表的代码块中，而被导入的代码包中的变量却处在声明它的那个文件所代表的代码块中。当然，我们也可以说被导入的代码包所代表的代码块包含了这个变量。\n在当前文件中，本地的变量会“屏蔽”掉被导入的变量。\n9. 除了《程序实体的那些事儿 3》一文中提及的那些，你还认为类型转换规则中有哪些值得注意的地方？ 答：简单来说，我们在进行类型转换的时候需要注意各种符号的优先级。具体可参见 Go 语言规范中的转换部分。\n10. 你能具体说说别名类型在代码重构过程中可以起到的哪些作用吗？ 答：简单来说，我们可以通过别名类型实现外界无感知的代码重构。具体可参见 Go 语言官方的文档 Proposal: Type Aliases。\n数据类型和语句篇 11. 如果有多个切片指向了同一个底层数组，那么你认为应该注意些什么？ 答：我们需要特别注意的是，当操作其中一个切片的时候是否会影响到其他指向同一个底层数组的切片。\n如果是，那么问一下自己，这是你想要的结果吗？无论如何，通过这种方式来组织或共享数据是不正确的。你需要做的是，要么彻底切断这些切片的底层联系，要么立即为所有的相关操作加锁。\n12. 怎样沿用“扩容”的思想对切片进行“缩容”？ 答：关于切片的“缩容”，可参看官方的相关 wiki。不过，如果你需要频繁的“缩容”，那么就可能需要考虑其他的数据结构了，比如：container/list代码包中的List。\n13. container/ring包中的循环链表的适用场景都有哪些？ 答：比如：可重用的资源（缓存等）的存储，或者需要灵活组织的资源池，等等。\n14. container/heap包中的堆的适用场景又有哪些呢？ 答：它最重要的用途就是构建优先级队列，并且这里的“优先级”可以很灵活。所以，想象空间很大。\n15. 字典类型的值是并发安全的吗？如果不是，那么在我们只在字典上添加或删除键 - 元素对的情况下，依然不安全吗？ 答：字典类型的值不是并发安全的，即使我们只是增减其中的键值对也是如此。其根本原因是，字典值内部有时候会根据需要进行存储方面的调整。\n16. 通道的长度代表着什么？它在什么时候会通道的容量相同？ 通道的长度代表它当前包含的元素值的个数。当通道已满时，其长度会与容量相同。\n17. 元素值在经过通道传递时会被复制，那么这个复制是浅表复制还是深层复制呢？ 答：浅表复制。实际上，在 Go 语言中并不存在深层次的复制，除非我们自己来做。\n18. 如果在select语句中发现某个通道已关闭，那么应该怎样屏蔽掉它所在的分支？ 答：很简单，把nil赋给代表了这个通道的变量就可以了。如此一来，对于这个通道（那个变量）的发送操作和接收操作就会永远被阻塞。\n19. 在select语句与for语句联用时，怎样直接退出外层的for语句？ 答：这一般会用到goto语句和标签（label），具体请参看 Go 语言规范的这部分。\n20. complexArray1被传入函数的话，这个函数中对该参数值的修改会影响到它的原值吗？ 答：文中complexArray1变量的声明如下：\ncomplexArray1 := [3][]string{ []string{\u0026quot;d\u0026quot;, \u0026quot;e\u0026quot;, \u0026quot;f\u0026quot;}, []string{\u0026quot;g\u0026quot;, \u0026quot;h\u0026quot;, \u0026quot;i\u0026quot;}, []string{\u0026quot;j\u0026quot;, \u0026quot;k\u0026quot;, \u0026quot;l\u0026quot;}, }  这要看怎样修改了。虽然complexArray1本身是一个数组，但是其中的元素却都是切片。如果对complexArray1中的元素进行增减，那么原值就不会受到影响。但若要修改它已有的元素值，那么原值也会跟着改变。\n21. 函数真正拿到的参数值其实只是它们的副本，那么函数返回给调用方的结果值也会被复制吗？ 答：函数返回给调用方的结果值也会被复制。不过，在一般情况下，我们不用太在意。但如果函数在返回结果值之后依然保持执行并会对结果值进行修改，那么我们就需要注意了。\n22. 我们可以在结构体类型中嵌入某个类型的指针类型吗？如果可以，有哪些注意事项？ 答：当然可以。在这时，我们依然需要注意各种“屏蔽”现象。由于某个类型的指针类型会包含与前者有关联的所有方法，所以我们更要注意。\n另外，我们在嵌入和引用这样的字段的时候还需要注意一些冲突方面的问题，具体请参看 Go 语言规范的这一部分。\n23. 字面量struct{}代表了什么？又有什么用处？ 答：字面量struct{}代表了空的结构体类型。这样的类型既不包含任何字段也没有任何方法。该类型的值所需的存储空间几乎可以忽略不计。\n因此，我们可以把这样的值作为占位值来使用。比如：在同一个应用场景下，map[int] [int]bool类型的值占用更少的存储空间。\n24. 如果我们把一个值为nil的某个实现类型的变量赋给了接口变量，那么在这个接口变量上仍然可以调用该接口的方法吗？如果可以，有哪些注意事项？如果不可以，原因是什么？ 答：可以调用。但是请注意，这个被调用的方法在此时所持有的接收者的值是nil。因此，如果该方法引用了其接收者的某个字段，那么就会引发 panic！\n25. 引用类型的值的指针值是有意义的吗？如果没有意义，为什么？如果有意义，意义在哪里？ 答：从存储和传递的角度看，没有意义。因为引用类型的值已经相当于指向某个底层数据结构的指针了。当然，引用类型的值不只是指针那么简单。\n26. 用什么手段可以对 goroutine 的启用数量加以限制？ 答：一个很简单且很常用的方法是，使用一个通道保存一些令牌。只有先拿到一个令牌，才能启用一个 goroutine。另外在go函数即将执行结束的时候还需要把令牌及时归还给那个通道。\n更高级的手段就需要比较完整的设计了。比如，任务分发器 + 任务管道（单层的通道）+ 固定个数的 goroutine。又比如，动态任务池（多层的通道）+ 动态 goroutine 池（可由前述的那个令牌方案演化而来）。等等。\n27. runtime包中提供了哪些与模型三要素 G、P 和 M 相关的函数？ 答：关于这个问题，我相信你一查文档便知。在线文档在这里。不过光知道还不够，还要会用。\n28. 在类型switch语句中，我们怎样对被判断类型的那个值做相应的类型转换？ 答：其实这个事情可以让 Go 语言自己来做，例如：\nswitch t := x.(type) { // cases }  当流程进入到某个case子句的时候，变量t的值就已经被自动地转换为相应类型的值了。\n29. 在if语句中，初始化子句声明的变量的作用域是什么？ 答：如果这个变量是新的变量，那么它的作用域就是当前if语句所代表的代码块。注意，后续的else if子句和else子句也包含在当前的if语句代表的代码块之内。\n30. 请列举出你经常用到或者看到的 3 个错误类型，它们所在的错误类型体系都是怎样的？你能画出一棵树来描述它们吗？ 答：略。这需要你自己去做，我代替不了你。\n31. 请列举出你经常用到或者看到的 3 个错误值，它们分别在哪个错误值列表里？这些错误值列表分别包含的是哪个种类的错误？ 答：略。这需要你自己去做，我代替不了你。\n32. 一个函数怎样才能把 panic 转化为error类型值，并将其作为函数的结果值返回给调用方？ 答：可以这样编写：\nfunc doSomething() (err error) { defer func() { p := recover() err = fmt.Errorf(\u0026quot;FATAL ERROR: %s\u0026quot;, p) }() panic(\u0026quot;Oops!!\u0026quot;) }  注意结果声明的写法。这是一个带有名称的结果声明。\n33. 我们可以在defer函数中恢复 panic，那么可以在其中引发 panic 吗？ 答：当然可以。这样做可以把原先的 panic 包装一下再抛出去。\nGo 程序的测试 34. 除了本文中提到的，你还知道或用过testing.T类型和testing.B类型的哪些方法？它们都是做什么用的？ 答：略。这需要你自己去做，我代替不了你。\n35. 在编写示例测试函数的时候，我们怎样指定预期的打印内容？ 答：这个问题的答案就在testing代码包的文档中。\n36. -benchmem标记和-benchtime标记的作用分别是什么？ 答：-benchmem标记的作用是在性能测试完成后打印内存分配统计信息。-benchtime标记的作用是设定测试函数的执行时间上限。\n具体请看这里的文档。\n37. 怎样在测试的时候开启测试覆盖度分析？如果开启，会有什么副作用吗？ 答：go test命令可以接受-cover标记。该标记的作用就是开启测试覆盖度分析。不过，由于覆盖度分析开启之后go test命令可能会在程序被编译之前注释掉一部分源代码，所以，若程序编译或测试失败，那么错误报告可能会记录下与原始的源代码不对应的行号。\n标准库的用法 38. 你知道互斥锁和读写锁的指针类型都实现了哪一个接口吗？ 答：它们都实现了sync.Locker接口。\n39. 怎样获取读写锁中的读锁？ 答：sync.RWMutex类型有一个名为RLocker的指针方法可以获取其读锁。\n40. *sync.Cond类型的值可以被传递吗？那sync.Cond类型的值呢？ 答：sync.Cond类型的值一旦被使用就不应该再被传递了，传递往往意味着拷贝。拷贝一个已经被使用的sync.Cond值会引发 panic。但是它的指针值是可以被拷贝的。\n41. sync.Cond类型中的公开字段L是做什么用的？我们可以在使用条件变量的过程中改变这个字段的值吗？ 答：这个字段代表的是当前的sync.Cond值所持有的那个锁。我们可以在使用条件变量的过程中改变该字段的值，但是在改变之前一定要搞清楚这样做的影响。\n42. 如果要对原子值和互斥锁进行二选一，你认为最重要的三个决策条件应该是什么？ 答：我觉得首先需要考虑下面几个问题。\n 被保护的数据是什么类型的？是值类型的还是引用类型的？ 操作被保护数据的方式是怎样的？是简单的读和写还是更复杂的操作？ 操作被保护数据的代码是集中的还是分散的？如果是分散的，是否可以变为集中的？  在搞清楚上述问题（以及你关注的其他问题）之后，优先使用原子值。\n43. 在使用WaitGroup值实现一对多的 goroutine 协作流程时，怎样才能让分发子任务的 goroutine 获得各个子任务的具体执行结果？ 答：可以考虑使用锁 + 容器（数组、切片或字典等），也可以考虑使用通道。另外，你或许也可以用上golang.org/x/sync/errgroup代码包中的程序实体，相应的文档在这里。\n44. Context值在传达撤销信号的时候是广度优先的还是深度优先的？其优势和劣势都是什么？ 答：它是深度优先的。其优势和劣势都是：直接分支的产生时间越早，其中的所有子节点就会越先接收到信号。至于什么时候是优势、什么时候是劣势还要看具体的应用场景。\n例如，如果子节点的存续时间与资源的消耗是正相关的，那么这可能就是一个优势。但是，如果每个分支中的子节点都很多，而且各个分支中的子节点的产生顺序并不依从于分支的产生顺序，那么这种优势就很可能会变成劣势。最终的定论还是要看测试的结果。\n45. 怎样保证一个临时对象池中总有比较充足的临时对象？ 答：首先，我们应该事先向临时对象池中放入足够多的临时对象。其次，在用完临时对象之后，我们需要及时地把它归还给临时对象池。\n最后，我们应该保证它的New字段所代表的值是可用的。虽然New函数返回的临时对象并不会被放入池中，但是起码能够保证池的Get方法总能返回一个临时对象。\n46. 关于保证并发安全字典中的键和值的类型正确性，你还能想到其他的方案吗？ 答：这是一道开放的问题，需要你自己去思考。其实怎样做完全取决于你的应用场景。不过，我们应该尽量避免使用反射，因为它对程序性能还是有一定的影响的。\n47. 判断一个 Unicode 字符是否为单字节字符通常有几种方式？ 答：unicode/utf8代码包中有几个可以做此判断的函数，比如：RuneLen函数、EncodeRune函数等。我们需要根据输入的不同来选择和使用它们。具体可以查看该代码包的文档。\n48. strings.Builder和strings.Reader都分别实现了哪些接口？这样做有什么好处吗？ 答：strings.Builder类型实现了 3 个接口，分别是：fmt.Stringer、io.Writer和io.ByteWriter。\n而strings.Reader类型则实现了 8 个接口，即：io.Reader、io.ReaderAt、io.ByteReader、io.RuneReader、io.Seeker、io.ByteScanner、io.RuneScanner和io.WriterTo。\n好处是显而易见的。实现的接口越多，它们的用途就越广。它们会适用于那些要求参数的类型为这些接口类型的地方。\n49. 对比strings.Builder和bytes.Buffer的String方法，并判断哪一个更高效？原因是什么？ 答：strings.Builder的String方法更高效。因为该方法只对其所属值的内容容器（那个字节切片）做了简单的类型转换，并且直接使用了底层的值（或者说内存空间）。它的源码如下：\n// String returns the accumulated string. func (b *Builder) String() string { return *(*string)(unsafe.Pointer(\u0026amp;b.buf)) }  数组值和字符串值在底层的存储方式其实是一样的。所以从切片值到字符串值的指针值的转换可以是直截了当的。又由于字符串值是不可变的，所以这样做也是安全的。\n不过，由于一些历史、结构和功能方面的原因，bytes.Buffer的String方法却不能这样做。\n50. io包中的同步内存管道的运作机制是什么？ 答：我们实际上已经在正文中做了基本的说明。\nio.Pipe函数会返回一个io.PipeReader类型的值和一个io.PipeWriter类型的值，并将它们分别作为管道的两端。而这两个值在底层其实只是代理了同一个*io.pipe类型值的功能而已。\nio.pipe类型通过无缓冲的通道实现了读操作与写操作之间的同步，并且通过互斥锁实现了写操作之间的串行化。另外，它还使用原子值来处理错误。这些共同保证了这个同步内存管道的并发安全性。\n51. bufio.Scanner类型的主要功用是什么？它有哪些特点？ 答：bufio.Scanner类型俗称带缓存的扫描器。它的功能还是比较强大的。\n比如，我们可以自定义每次扫描的边界，或者说内容的分段方法。我们在调用它的Scan方法对目标进行扫描之前，可以先调用其Split方法并传入一个函数来自定义分段方法。\n在默认情况下，扫描器会以行为单位对目标内容进行扫描。bufio代码包提供了一些现成的分段方法。实际上，扫描器在默认情况下会使用bufio.ScanLines函数作为分段方法。\n又比如，我们还可以在扫描之前自定义缓存的载体和缓存的最大容量，这需要调用它的Buffer方法。在默认情况下，扫描器内部设定的最大缓存容量是64K个字节。\n换句话说，目标内容中的每一段都不能超过64K个字节。否则，扫描器就会使它的Scan方法返回false，并通过其Err方法给予我们一个表示“token too long”的错误值。这里的“token”代表的就是一段内容。\n关于bufio.Scanner类型的更多特点和使用注意事项，你可以通过它的文档获得。\n52. 怎样通过os包中的 API 创建和操纵一个系统进程？ 答：你可以从os包的FindProcess函数和StartProcess函数开始。前者用于通过进程 ID（pid）查找进程，后者用来基于某个程序启动一个进程。\n这两者都会返回一个*os.Process类型的值。该类型提供了一些方法，比如，用于杀掉当前进程的Kill方法，又比如，可以给当前进程发送系统信号的Signal方法，以及会等待当前进程结束的Wait方法。\n与此相关的还有os.ProcAttr类型、os.ProcessState类型、os.Signal类型，等等。你可以通过积极的实践去探索更多的玩法。\n53. 怎样在net.Conn类型的值上正确地设定针对读操作和写操作的超时时间？ 答：net.Conn类型有 3 个可用于设置超时时间的方法，分别是：SetDeadline、SetReadDeadline和SetWriteDeadline。\n这三个方法的签名是一模一样的，只是名称不同罢了。它们都接受一个time.Time类型的参数，并都会返回一个error类型的结果。其中的SetDeadline方法是用来同时设置读操作超时和写操作超时的。\n有一点需要特别注意，这三个方法都会针对任何正在进行以及未来将要进行的相应操作进行超时设定。\n因此，如果你要在一个循环中进行读操作或写操作的话，最好在每次迭代中都进行一次超时设定。\n否则，靠后的操作就有可能因触达超时时间而直接失败。另外，如果有必要，你应该再次调用它们并传入time.Time类型的零值来表达不再限定超时时间。\n54. 怎样优雅地停止基于 HTTP 协议的网络服务程序？ 答：net/http.Server类型有一个名为Shutdown的指针方法可以实现“优雅的停止”。也就是说，它可以在不中断任何正处在活动状态的连接的情况下平滑地关闭当前的服务器。\n它会先关闭所有的空闲连接，并一直等待。只有活动的连接变为空闲之后，它才会关闭它们。当所有的连接都被平滑地关闭之后，它会关闭当前的服务器并返回。当有错误发生时，它还会把相应的错误值返回。\n另外，你还可以通过调用Server值的RegisterOnShutdown方法来注册可以在服务器即将关闭时被自动调用的函数。\n更确切地说，当前服务器的Shutdown方法会以异步的方式调用如此注册的所有函数。我们可以利用这样的函数来通知长连接的客户端“连接即将关闭”。\n55. runtime/trace代码包的功用是什么？ 答：简单来说，这个代码包是用来帮助 Go 程序实现内部跟踪操作的。其中的程序实体可以帮助我们记录程序中各个 goroutine 的状态、各种系统调用的状态，与 GC 有关的各种事件，以及内存相关和 CPU 相关的变化，等等。\n通过它们生成的跟踪记录可以通过go tool trace命令来查看。更具体的说明可以参看runtime/trace代码包的文档。\n有了runtime/trace代码包，我们就可以为 Go 程序加装上可以满足个性化需求的跟踪器了。Go 语言标准库中有的代码包正是通过使用该包实现了自身的功能，例如net/http/pprof包。\n","date":1595935543,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595935543,"objectID":"607f440f7ea0139a562992f940aa4b6f","permalink":"/go/interview/gocore36-think/","publishdate":"2020-07-28T19:25:43+08:00","relpermalink":"/go/interview/gocore36-think/","section":"go","summary":"思考题答案","tags":["Go"],"title":"Go语言核心36讲思考题","type":"go"},{"authors":[],"categories":["interview"],"content":" Day 91. init, 类型 1.下面两段代码能否编译通过？请简要说明。\n第一段：\nfunc f() {} func f() {} func main() {}  第二段：\nfunc init(){} func init(){} func main() {}  参考答案及解析：第二段代码能通过编译。除 init() 函数之外，一个包内不允许有其他同名函数。\n2.下面代码有什么问题？请指出。\nfunc (m map[string]string) Set(key string, value string) { m[key] = value } func main() { m := make(map[string]string) m.Set(\u0026quot;A\u0026quot;, \u0026quot;One\u0026quot;) }  参考答案及解析：Unnamed Type 不能作为方法的接收者。昨天我们讲过 Named Type 与 Unamed Type 的区别，就用 Named Type 来修复下代码：\ntype User map[string]string func (m User) Set(key string, value string) { m[key] = value } func main() { m := make(User) m.Set(\u0026quot;A\u0026quot;, \u0026quot;One\u0026quot;) }  \nDay 92. init ,copy 1.下面代码输出什么？\nvar x int func init() { x++ } func main() { init() fmt.Println(x) }  参考答案及解析：编译失败。init() 函数不能被其他函数调用，包括 main() 函数。\n2.min() 函数是求两个数之间的较小值，能否在 该函数中添加一行代码将其功能补全。\nfunc min(a int, b uint) { var min = 0 fmt.Printf(\u0026quot;The min of %d and %d is %d\\n\u0026quot;, a, b, min) } func main() { min(1225, 256) }  参考答案即解析：利用 copy() 函数的功能：切片复制，并且返回两者长度的较小值。\nfunc min(a int, b uint) { var min = 0 min = copy(make([]struct{},a),make([]struct{},b)) fmt.Printf(\u0026quot;The min of %d and %d is %d\\n\u0026quot;, a, b, min) } func main() { min(1225, 256) }  \nDay 93. main, 类型 1.关于 main() 函数，下面说法正确的是？\n 不能带参数； 不能定义返回值； 所在的包必须为 main 包； 可以使用 flag 包来获取和解析命令行参数；  参考答案及解析：ABCD。\n2.下面代码能编译通过吗？请简要说明。\ntype User struct { Name string } func (u *User) SetName(name string) { u.Name = name fmt.Println(u.Name) } type Employee User func main() { employee := new(Employee) employee.SetName(\u0026quot;Jack\u0026quot;) }  参考答案及解析：编译不通过。当使用 type 声明一个新类型，它不会继承原有类型的方法集。\n\nDay 94. ^, default 1.下面这段代码输出什么？请简要说明。\nfunc main() { a := 2 ^ 15 b := 4 ^ 15 if a \u0026gt; b { println(\u0026quot;a\u0026quot;) } else { println(\u0026quot;b\u0026quot;) } }  参考答案及解析：a。Go 语言里面 ^ 表示按位异或，而不是求幂。\n0010 ^ 1111 == 1101 (2^15 == 13) 0100 ^ 1111 == 1011 (4^15 == 11)  2.下面哪些函数不能通过编译？\nfunc A(string string) string { return string + string } func B(len int) int { return len + len } func C(val, default string) string { if val == \u0026quot;\u0026quot; { return default } return val }  参考答案及解析：C() 函数不能通过编译。C() 函数的 default 属于关键字。string 和 len 是预定义标识符，可以在局部使用。nil 也可以当做变量使用，不过不建议写这样的代码，可读性不好，小心被接手你代码的人胖揍。\nvar nil = new(int) func main() { var p *int if p == nil { fmt.Println(\u0026quot;p is nil\u0026quot;) } else { fmt.Println(\u0026quot;p is not nil\u0026quot;) } }  \nDay 95. select 1.下面代码输出什么？请简要说明。\ntype foo struct{ Val int } type bar struct{ Val int } func main() { a := \u0026amp;foo{Val: 5} b := \u0026amp;foo{Val: 5} c := foo{Val: 5} d := bar{Val: 5} e := bar{Val: 5} f := bar{Val: 5} fmt.Print(a == b, c == foo(d), e == f) }  参考答案及解析：false true true。这道题唯一有疑问的地方就在第一个比较，Go 语言里没有引用变量，每个变量都占用一个惟一的内存位置，所以第一个比较输出 false。这个知识点在《Go 语言没有引用传递》有介绍。\n2.下面代码输出什么？\nfunc A() int { time.Sleep(100 * time.Millisecond) return 1 } func B() int { time.Sleep(1000 * time.Millisecond) return 2 } func main() { ch := make(chan int, 1) go func() { select { case ch \u0026lt;- A(): case ch \u0026lt;- B(): default: ch \u0026lt;- 3 } }() fmt.Println(\u0026lt;-ch) }  参考答案及解析：1、2随机输出。关于 select 的使用可以查看《Go 并发 \u0026ndash; Select》\n\nDay 96. for range,切片 1.下面的代码输出什么？\ntype Point struct{ x, y int } func main() { s := []Point{ {1, 2}, {3, 4}, } for _, p := range s { p.x, p.y = p.y, p.x } fmt.Println(s) }  参考答案及解析：输出 [{1 2} {3 4}]。知识点：for range 循环。range 循环的时候，获取到的元素值是副本，就比如这里的 p。修复代码示例：\ntype Point struct{ x, y int } func main() { s := []*Point{ \u0026amp;Point{1, 2}, \u0026amp;Point{3, 4}, } for _, p := range s { p.x, p.y = p.y, p.x } fmt.Println(*s[0]) fmt.Println(*s[1]) }  2.下面的代码有什么隐患？\nfunc get() []byte { raw := make([]byte, 10000) fmt.Println(len(raw), cap(raw), \u0026amp;raw[0]) return raw[:3] } func main() { data := get() fmt.Println(len(data), cap(data), \u0026amp;data[0]) }  参考答案及解析：get() 函数返回的切片与原切片公用底层数组，如果在调用函数里面（这里是 main() 函数）修改返回的切片，将会影响到原切片。为了避免掉入陷阱，可以如下修改：\nfunc get() []byte { raw := make([]byte, 10000) fmt.Println(len(raw), cap(raw), \u0026amp;raw[0]) res := make([]byte, 3) copy(res, raw[:3]) return res } func main() { data := get() fmt.Println(len(data), cap(data), \u0026amp;data[0]) }  \nDay 97. map,参数传递 1.关于map，下面说法正确的是？\n A. map 反序列化时 json.unmarshal() 的入参必须为map的地址； B. 在函数调用中传递 map，则子函数中对 map 元素的增加不会导致父函数中 map 的修改； C. 在函数调用中传递 map，则子函数中对 map 元素的修改不会导致父函数中 map 的修改； D. 不能使用内置函数 delete() 删除 map 的元素；  参考答案及解析：A。知识点：map 的使用。可以查看《Go Map》\n2.下面代码输出什么？请简要说明。\ntype Foo struct { val int } func (f Foo) Inc(inc int) { f.val += inc } func main() { var f Foo f.Inc(100) fmt.Println(f.val) }  参考答案及解析：输出 0。使用值类型接收者定义的方法，调用的时候，使用的是值的副本，对副本操作不会影响的原来的值。如果想要在调用函数中修改原值，可以使用指针接收者定义的方法。\ntype Foo struct { val int } func (f *Foo) Inc(inc int) { f.val += inc } func main() { f := \u0026amp;Foo{} f.Inc(100) fmt.Println(f.val) // 100 }  \nDay 98. 变量的作用域 1.下面代码输出什么？\nfunc main() { a := 1 for i := 0;i\u0026lt;5;i++ { a := a + 1 a = a * 2 } fmt.Println(a) }  参考答案及解析：1。知识点：变量的作用域。注意 for 语句的变量 a 是重新声明，它的作用范围只在 for 语句范围内。\n2.下面的代码输出什么？\nfunc test(i int) (ret int) { ret = i * 2 if ret \u0026gt; 10 { ret := 10 return } return } func main() { result := test(10) fmt.Println(result) }  参考答案即解析：编译错误。知识点：变量的作用域。编译错误信息：ret is shadowed during return。\n\nDay 99. 变量作用域,defer 1.下面代码能编译通过吗？\nfunc main() { true := false fmt.Println(true) }  参考答案即解析：编译通过。true 是预定义标识符可以用作变量名，但是不建议这么做。\n2.下面的代码输出什么？\nfunc watShadowDefer(i int) (ret int) { ret = i * 2 if ret \u0026gt; 10 { ret := 10 defer func() { ret = ret + 1 }() } return } func main() { result := watShadowDefer(50) fmt.Println(result) }  参考答案即解析：100。知识点：变量作用域和defer 返回值。可以查看文章《5 年 Gopher 都不知道的 defer 细节，你别再掉进坑里！》\n\nDay 100. 读写锁,map 1.下面代码输出什么？\nfunc main() { m := map[string]int{ \u0026quot;G\u0026quot;: 7, \u0026quot;A\u0026quot;: 1, \u0026quot;C\u0026quot;: 3, \u0026quot;E\u0026quot;: 5, \u0026quot;D\u0026quot;: 4, \u0026quot;B\u0026quot;: 2, \u0026quot;F\u0026quot;: 6, \u0026quot;I\u0026quot;: 9, \u0026quot;H\u0026quot;: 8, } var order []string for k, _ := range m { order = append(order, k) } fmt.Println(order) }  参考答案即解析：按字母无序输出。知识点：遍历 map 是无序的。\n2.下面的代码有什么问题？\ntype UserAges struct { ages map[string]int sync.Mutex } func (ua *UserAges) Add(name string, age int) { ua.Lock() defer ua.Unlock() ua.ages[name] = age } func (ua *UserAges) Get(name string) int { if age, ok := ua.ages[name]; ok { return age } return -1 } func main() { count := 1000 gw := sync.WaitGroup{} gw.Add(count * 3) u := UserAges{ages: map[string]int{}} add := func(i int) { u.Add(fmt.Sprintf(\u0026quot;user_%d\u0026quot;, i), i) gw.Done() } for i := 0; i \u0026lt; count; i++ { go add(i) go add(i) } for i := 0; i \u0026lt; count; i++ { go func(i int) { defer gw.Done() u.Get(fmt.Sprintf(\u0026quot;user_%d\u0026quot;, i)) }(i) } gw.Wait() fmt.Println(\u0026quot;Done\u0026quot;) }  参考答案即解析：在执行 Get() 方法时可能报错。知识点：读写锁。虽然可以使用 sync.Mutex 做写锁，但是 map 是并发读写不安全的。map 属于引用类型，并发读写时多个协程是通过指针访问同一个地址，即访问共享变量，此时同时读写资源存在竞争关系，会报错 “fatal error: concurrent map read and map write”。\n有兴趣的同学可以尝试用 sync.RWMutex（读写锁）改进下程序。\n\nDay 101. 循环,select 1.关于循环语句，下面说法正确的有？\n A. 循环语句既支持 for 关键字，也支持 while 和 do-while； B. 关键字for的基本使用方法与C/C++中没有任何差异； C. for 循环支持 continue 和 break 来控制循环，但是它提供了一个更高级的 break，可以选择中断哪一个循环； D. for 循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量；  参考答案及解析：CD。\n2.下面代码的功能是从小到大找出 17 和 38 的 3 个公倍数，请问下面的代码有什么问题？\nvar ch chan int = make(chan int) func generate() { for i := 17; i \u0026lt; 5000; i += 17 { ch \u0026lt;- i time.Sleep(1 * time.Millisecond) } close(ch) } func main() { timeout := time.After(800 * time.Millisecond) go generate() found := 0 for { select { case i, ok := \u0026lt;-ch: if ok { if i%38 == 0 { fmt.Println(i, \u0026quot;is a multiple of 17 and 38\u0026quot;) found++ if found == 3 { break } } } else { break } case \u0026lt;-timeout: fmt.Println(\u0026quot;timed out\u0026quot;) break } } fmt.Println(\u0026quot;The end\u0026quot;) }  参考答案即解析：break 会跳出 select 块，但不会跳出 for 循环。这算是一个比较容易掉的坑。可以使用 break label 特性或者 goto 功能解决这个问题，这里使用 break label 作个示例。\nvar ch chan int = make(chan int) func generate() { for i := 17; i \u0026lt; 5000; i += 17 { ch \u0026lt;- i time.Sleep(1 * time.Millisecond) } close(ch) } func main() { timeout := time.After(800 * time.Millisecond) go generate() found := 0 MAIN_LOOP: for { select { case i, ok := \u0026lt;-ch: if ok { if i%38 == 0 { fmt.Println(i, \u0026quot;is a multiple of 17 and 38\u0026quot;) found++ if found == 3 { break MAIN_LOOP } } } else { break MAIN_LOOP } case \u0026lt;-timeout: fmt.Println(\u0026quot;timed out\u0026quot;) break MAIN_LOOP } } fmt.Println(\u0026quot;The end\u0026quot;) }  \nDay 102. channel, 锁 1.ch := make(chan interface{}) 和 ch := make(chan interface{},1) 有什么区别？\n参考答案及解析：第一个是声明无缓存通道，第二个是声明缓存为 1 的通道。无缓存通道需要一直有接收者接收数据，写操作才会继续，不然会一直阻塞；而缓冲为 1 则即使没有接收者也不会阻塞，因为缓冲大小是 1 ，只有当放第二个值的时候，第一个还没被人拿走，这时候才会阻塞。注意这两者还是有区别的。\n2.下面的代码输出什么？请简要说明。\nvar mu sync.Mutex var chain string func main() { chain = \u0026quot;main\u0026quot; A() fmt.Println(chain) } func A() { mu.Lock() defer mu.Unlock() chain = chain + \u0026quot; --\u0026gt; A\u0026quot; B() } func B() { chain = chain + \u0026quot; --\u0026gt; B\u0026quot; C() } func C() { mu.Lock() defer mu.Unlock() chain = chain + \u0026quot; --\u0026gt; C\u0026quot; }   A. 不能编译； B. 输出 main \u0026ndash;\u0026gt; A \u0026ndash;\u0026gt; B \u0026ndash;\u0026gt; C； C. 输出 main； D. fatal error；  参考答案即解析：D。使用 Lock() 加锁后，不能再继续对其加锁，直到利用 Unlock() 解锁后才能再加锁。\n引自博客《鸟窝》 https://colobu.com/\n\nDay 103. 锁,defer 1.下面代码输出什么？\nfunc main() { fmt.Println(doubleScore(0)) fmt.Println(doubleScore(20.0)) fmt.Println(doubleScore(50.0)) } func doubleScore(source float32) (score float32) { defer func() { if score \u0026lt; 1 || score \u0026gt;= 100 { score = source } }() return source * 2 }  参考答案及解析：输出 0 40 50。知识点：defer 语句与返回值。函数的 return value 不是原子操作，而是在编译器中分解为两部分：返回值赋值 和 return。可以细看《5 年 Gopher 都不知道的 defer 细节，你别再掉进坑里！》\n2.下面代码输出什么？请简要说明。\nvar mu sync.RWMutex var count int func main() { go A() time.Sleep(2 * time.Second) mu.Lock() defer mu.Unlock() count++ fmt.Println(count) } func A() { mu.RLock() defer mu.RUnlock() B() } func B() { time.Sleep(5 * time.Second) C() } func C() { mu.RLock() defer mu.RUnlock() }   A. 不能编译； B. 输出 1； C. 程序 hang 住； D. fatal error；  参考答案及解析：D。当写锁阻塞时，新的读锁是无法申请的（有效防止写锁饥饿），导致死锁。\n\nDay 104. WaitGroup 1.关于同步锁，下面说法正确的是？\n A. 当一个 goroutine 获得了 Mutex 后，其他 goroutine 就只能乖乖的等待，除非该 goroutine 释放这个 Mutex； B. RWMutex 在读锁占用的情况下，会阻止写，但不阻止读； C. RWMutex 在写锁占用情况下，会阻止任何其他 goroutine（无论读和写）进来，整个锁相当于由该 goroutine 独占； D. Lock() 操作需要保证有 Unlock() 或 RUnlock() 调用与之对应；  参考答案及解析：ABC。\n2.下面代码输出什么？请简要说明。\nfunc main() { var wg sync.WaitGroup wg.Add(1) go func() { time.Sleep(time.Millisecond) wg.Done() wg.Add(1) }() wg.Wait() }   A. 不能编译； B. 无输出，正常退出； C. 程序 hang 住； D. panic；  参考答案及解析：D。WaitGroup 在调用 Wait() 之后不能再调用 Add() 方法的。\n\nDay 105. channel,锁 1.下面代码输出什么？请简要说明。\nvar c = make(chan int) var a int func f() { a = 1 \u0026lt;-c } func main() { go f() c \u0026lt;- 0 print(a) }   A. 不能编译； B. 输出 1； C. 输出 0； D. panic；  参考答案及解析：B。能正确输出，不过主协程会阻塞 f() 函数的执行。\n2.下面代码输出什么？请简要说明。\ntype MyMutex struct { count int sync.Mutex } func main() { var mu MyMutex mu.Lock() var mu1 = mu mu.count++ mu.Unlock() mu1.Lock() mu1.count++ mu1.Unlock() fmt.Println(mu.count, mu1.count) }   A. 不能编译； B. 输出 1, 1； C. 输出 1, 2； D. fatal error；  参考答案及解析：D。加锁后复制变量，会将锁的状态也复制，所以 mu1 其实是已经加锁状态，再加锁会死锁。\n\nDay 106. goroutines 1.下面代码输出什么？请简要说明。\nfunc main() { var ch chan int var count int go func() { ch \u0026lt;- 1 }() go func() { count++ close(ch) }() \u0026lt;-ch fmt.Println(count) }   A. 不能编译； B. 输出 1； C. 输出 0； D. panic；  参考答案及解析：D。ch 未被初始化，关闭时会报错。\n2.下面代码输出什么？请简要说明。\nfunc main() { var ch chan int go func() { ch = make(chan int, 1) ch \u0026lt;- 1 }() go func(ch chan int) { time.Sleep(time.Second) \u0026lt;-ch }(ch) c := time.Tick(1 * time.Second) for range c { fmt.Printf(\u0026quot;#goroutines: %d\\n\u0026quot;, runtime.NumGoroutine()) } }   A. 不能编译； B. 一段时间后总是输出 #goroutines: 1； C. 一段时间后总是输出 #goroutines: 2； D. panic；  参考答案即解析：C。程序执行到第二个 groutine 时，ch 还未初始化，导致第二个 goroutine 阻塞。需要注意的是第一个 goroutine 不会阻塞。\n\nDay 107. append,sync.Map 1.下面代码输出什么？请简要说明。\nfunc main() { var m sync.Map m.LoadOrStore(\u0026quot;a\u0026quot;, 1) m.Delete(\u0026quot;a\u0026quot;) fmt.Println(m.Len()) }   A. 不能编译； B. 输出 1； C. 输出 0； D. panic；  参考答案及解析：D。sync.Map 没有 Len() 方法。\n2.下面代码输出什么？请简要说明。\nfunc main() { var wg sync.WaitGroup wg.Add(2) var ints = make([]int, 0, 1000) go func() { for i := 0; i \u0026lt; 1000; i++ { ints = append(ints, i) } wg.Done() }() go func() { for i := 0; i \u0026lt; 1000; i++ { ints = append(ints, i) } wg.Done() }() wg.Wait() fmt.Println(len(ints)) }   A. 不能编译； B. 输出 2000； C. 输出可能不是 2000； D. panic；  参考答案及解析：C。append() 并不是并发安全的，有兴趣的同学可以尝试用锁去解决这个问题。\n\nDay 108. 私有,flag 1.下面的代码输出什么？\ntype People struct { name string `json:\u0026quot;name\u0026quot;` } func main() { js := `{ \u0026quot;name\u0026quot;:\u0026quot;11\u0026quot; }` var p People err := json.Unmarshal([]byte(js), \u0026amp;p) if err != nil { fmt.Println(\u0026quot;err: \u0026quot;, err) return } fmt.Println(\u0026quot;people: \u0026quot;, p) }  参考答案及解析：people:{}。按照 go 的语法，小写开头的方法、属性或 struct 是私有的，同样，在 json 解码或转码的时候也无法实现私有属性的转换。\n这段代码是无法正常得到 People 的 name 值的。而且，私有属性 name 也不应该加 json 的标签。\n2.补充 A、B 两处代码，实现程序能解析 ip 和 prot 参数，默认值是 0.0.0.0 和 8000。\nvar ip string var port int func init() { // A // B } func main() { flag.Parse() fmt.Printf(\u0026quot;%s:%d\u0026quot;, ip, port) }  参考答案及解析：flag 包的使用。\nvar ip string var port int func init() { flag.StringVar(\u0026amp;ip, \u0026quot;ip\u0026quot;, \u0026quot;0.0.0.0\u0026quot;, \u0026quot;ip address\u0026quot;) flag.IntVar(\u0026amp;port, \u0026quot;port\u0026quot;, 8000, \u0026quot;port number\u0026quot;) } func main() { flag.Parse() fmt.Printf(\u0026quot;%s:%d\u0026quot;, ip, port) }  \nDay 109. sort, go 1.下面代码有什么问题？\nfunc main() { ch := make(chan int, 1000) go func() { for i := 0; i \u0026lt; 10; i++ { ch \u0026lt;- i } }() go func() { for { a, ok := \u0026lt;-ch if !ok { fmt.Println(\u0026quot;close\u0026quot;) return } fmt.Println(\u0026quot;a: \u0026quot;, a) } }() close(ch) fmt.Println(\u0026quot;ok\u0026quot;) time.Sleep(time.Second * 20) }  参考答案及解析：panic。协程开启还未来得及执行，chan 就已经 close() ，往已经关闭的 chan 写数据会 panic。\n2.在 A 处添加一行代码实现 S 按升序排列。\ntype S struct { v int } func main() { s := []S{{1}, {3}, {5}, {2}} // A fmt.Printf(\u0026quot;%#v\u0026quot;, s) }  参考答案及解析：可以考虑使用 sort.Slice()。\ntype S struct { v int } func main() { s := []S{{1}, {3}, {5}, {2}} sort.Slice(s, func(i, j int) bool { return s[i].v \u0026lt; s[j].v }) fmt.Printf(\u0026quot;%#v\u0026quot;, s) }  \nDay 110. for range,WaitGroup 1.下面代码输出什么？请简要说明。\ntype T struct { V int } func (t *T) Incr(wg *sync.WaitGroup) { t.V++ wg.Done() } func (t *T) Print() { time.Sleep(1) fmt.Print(t.V) } func main() { var wg sync.WaitGroup wg.Add(10) var ts = make([]T, 10) for i := 0; i \u0026lt; 10; i++ { ts[i] = T{i} } for _, t := range ts { go t.Incr(\u0026amp;wg) } wg.Wait() for _, t := range ts { go t.Print() } time.Sleep(5 * time.Second) }   A. 输出 12345678910； B. 输出 0123456789； C. 输出 9999999999； D. panic；  参考答案及解析：C。这道题需要注意的一点是 for range 循环里的变量 t 是临时变量。\n2.下面的代码可以随机输出大小写字母，尝试在 A 处添加一行代码使得字母先按大写再按小写的顺序输出。\nconst N = 26 func main() { const GOMAXPROCS = 1 runtime.GOMAXPROCS(GOMAXPROCS) var wg sync.WaitGroup wg.Add(2 * N) for i := 0; i \u0026lt; N; i++ { go func(i int) { defer wg.Done() // A runtime.Gosched() fmt.Printf(\u0026quot;%c\u0026quot;, 'a'+i) }(i) go func(i int) { defer wg.Done() fmt.Printf(\u0026quot;%c\u0026quot;, 'A'+i) }(i) } wg.Wait() }  参考答案及解析：\nconst N = 26 func main() { const GOMAXPROCS = 1 runtime.GOMAXPROCS(GOMAXPROCS) var wg sync.WaitGroup wg.Add(2 * N) for i := 0; i \u0026lt; N; i++ { go func(i int) { defer wg.Done() runtime.Gosched() fmt.Printf(\u0026quot;%c\u0026quot;, 'a'+i) }(i) go func(i int) { defer wg.Done() fmt.Printf(\u0026quot;%c\u0026quot;, 'A'+i) }(i) } wg.Wait() }  \nDay 111. 栈增长、逃逸分析 1.下面两处打印的值是否相同？请简要说明。\nfunc main() { var val int println(\u0026amp;val) f(10000) println(\u0026amp;val) } func f(i int) { if i--; i == 0 { return } f(i) }  参考答案及解析：不同。知识点：栈增长、逃逸分析。每个 groutine 都会分配相应的栈内存，比如 Go 1.11 版本是 2Kb，随着程序运行，栈内存会发生增长或缩小，协程会重新申请栈内存块。就像这个题目，循环调用 f()，发生深度递归，栈内存不断增大，当超过范围时，会重新申请栈内存，所以 val 的地址会变化。\n这道题还有个特别注意的地方，如果将 println() 函数换成 fmt.Println() 会发现，打印结果相同。为什么？因为函数 fmt.Println() 使变量 val 发生了逃逸，逃逸到堆内存，即使协程栈内存重新申请，val 变量在堆内存的地址也不会改变。\n2.下面代码 A 处输出什么？请简要说明。\nfunc main() { var val int a := \u0026amp;val println(a) f(10000) b := \u0026amp;val println(b) println(a == b) // A } func f(i int) { if i--; i == 0 { return } f(i) }   A. ture B. false  参考答案及解析：A。这道题和上一道有一定联系，a 是指向变量 val 的指针，我们知道 val 变量的地址发生了改变，a 指向 val 新的地址是由内存管理自动实现的。\nfunc main() { var val int a := \u0026amp;val println(a) f(10000) b := \u0026amp;val println(a) // a b 的值相同 println(b) println(a == b) // A } func f(i int) { if i--; i == 0 { return } f(i) }  \nDay 112. 切片 1.下面代码输出什么？请简要说明。\nfunc main() { x := []int{100, 200, 300, 400, 500, 600, 700} twohundred := \u0026amp;x[1] x = append(x, 800) for i := range x { x[i]++ } fmt.Println(*twohundred) }  参考答案及解析：200。因为原切片的容量已经满了，执行 append 操作之后会创建一个新的底层数组，并将原切片底层数组的值拷贝到新的数组，原数组保持不变。参考《非懂不可的Slice（一）》。\nfunc main() { x := make([]int, 0, 7) x = append(x, 100, 200, 300, 400, 500, 600, 700) twohundred := \u0026amp;x[1] x = append(x, 800) for i := range x { x[i]++ } fmt.Println(*twohundred) // 输出 200 x = make([]int, 0, 8) // 指向另一个切片 x = append(x, 100, 200, 300, 400, 500, 600, 700) twohundred = \u0026amp;x[1] x = append(x, 800) // 执行 append 操作，容量足够，不会重新申请内存 for i := range x { x[i]++ } fmt.Println(*twohundred) // 输出 201 }  2.下面的代码输出什么？请简要说明。\nfunc main() { a := []int{0, 1} fmt.Printf(\u0026quot;%v\u0026quot;, a[len(a):]) }  参考答案及解析：输出 []。对一个切片执行 [i,j] 的时候，i 和 j 都不能超过切片的长度值。参考《非懂不可的Slice（一）》。\n\nDay 113. const, 切片 1.关于 const 常量定义，下面正确的使用方式是？\nA.\nconst Pi float64 = 3.14159265358979323846 const zero= 0.0  B.\nconst ( size int64= 1024 eof = -1 )  C.\nconst ( ERR_ELEM_EXISTerror = errors.New(\u0026quot;element already exists\u0026quot;) ERR_ELEM_NT_EXISTerror = errors.New(\u0026quot;element not exists\u0026quot;) )  D.\nconst u, vfloat32 = 0, 3 const a,b, c = 3, 4, \u0026quot;foo\u0026quot;  参考答案及解析：ABD。\n2.修改下面的代码，使得第二个输出 [seek 1 2 3 4] 。\nfunc link(p ...interface{}) { fmt.Println(p) } func main() { link(\u0026quot;seek\u0026quot;, 1, 2, 3, 4) // 输出 [seek 1 2 3 4] a := []int{1, 2, 3, 4} link(\u0026quot;seek\u0026quot;, a) // 输出 [seek [1 2 3 4]] }  参考答案及解析：\nfunc link(p ...interface{}) { fmt.Println(p) } func main() { link(\u0026quot;seek\u0026quot;, 1, 2, 3, 4) // 输出 [seek 1 2 3 4] a := []int{1, 2, 3, 4} link(\u0026quot;seek\u0026quot;, a) // 输出 [seek [1 2 3 4]] tmplink := make([]interface{}, 0, len(a)+1) tmplink = append(tmplink, \u0026quot;seek\u0026quot;) for _, ii := range a { tmplink = append(tmplink, ii) } link(tmplink...) // 输出 [seek 1 2 3 4] }  \nDay 114. 进制, select 1.下面代码输出什么？\nfunc main() { ns := []int{010: 200, 005: 100} print(len(ns)) }  参考答案及解析：9。Go 语言中，0x 开头表示 十六进制；0 开头表示八进制。\n2.下面的代码输出什么？请简要说明。\nfunc main() { i := 0 f := func() int { i++ return i } c := make(chan int, 1) c \u0026lt;- f() select { case c \u0026lt;- f(): default: fmt.Println(i) } }  参考答案即解析：2。知识点：select 的使用。《Go 并发 \u0026ndash; Select》\n下面这段代码会更有助于大家理解：\nfunc main() { i := 0 f := func() int { fmt.Println(\u0026quot;incr\u0026quot;) i++ return i } c := make(chan int) for j := 0; j \u0026lt; 2; j++ { select { case c \u0026lt;- f(): // noop default: // noop } } fmt.Println(i) }  \nDay 115. 可变函数,switch 1.下面正确的是？\nvar y int func f(x int) int { return 7 } A. switch y = f(2) { case y == 7: return } B. switch y = f(2); { case y == 7: return } C. switch y = f(2) { case 7: return } D. switch y = f(2); { case 7: return }  参考答案及解析：B。知识点：switch case 的使用。\n2.下面的代码输出什么？\nfunc main() { a := []int{1, 2, 3, 4} b := variadic(a...) b[0], b[1] = b[1], b[0] fmt.Println(a) } func variadic(ints ...int) []int { return ints }  参考答案及解析：2 1 3 4。知识点：可变函数。切片作为参数传入可变函数时不会创建新的切片。参见《可变函数》\n\nDay 116. iota 1.下面的代码输出什么？\nconst ( one = 1 \u0026lt;\u0026lt; iota two ) func main() { fmt.Println(one, two) }  2.下面的代码输出什么？\nconst ( greeting = \u0026quot;Hello, Go\u0026quot; one = 1 \u0026lt;\u0026lt; iota two ) func main() { fmt.Println(one, two) }  参考答案及解析：这两道题考的是同一个知识点：iota 的使用。 第一题：1 2；第二题：2 4。\n\nDay 117. WaitGroup,mutex,json 1.Go 语言中中大多数数据类型都可以转化为有效的 JSON 文本，下面几种类型除外。\n A. 指针 B. channel C. complex D. 函数  参考答案及解析：BCD。\n2.下面代码输出什么？如果想要代码输出 10，应该如何修改？\nconst N = 10 func main() { m := make(map[int]int) wg := \u0026amp;sync.WaitGroup{} mu := \u0026amp;sync.Mutex{} wg.Add(N) for i := 0; i \u0026lt; N; i++ { go func() { defer wg.Done() mu.Lock() m[i] = i mu.Unlock() }() } wg.Wait() println(len(m)) }  参考答案及解析：输出 1。知识点：并发、引用。修复代码如下：\nconst N = 10 func main() { m := make(map[int]int) wg := \u0026amp;sync.WaitGroup{} mu := \u0026amp;sync.Mutex{} wg.Add(N) for i := 0; i \u0026lt; N; i++ { go func(i int) { defer wg.Done() mu.Lock() m[i] = i mu.Unlock() }(i) } wg.Wait() println(len(m)) }  \nDay 118. iota 1、下面说法正确的是。\n A. Go 语言中，声明的常量未使用会报错； B. cap() 函数适用于 array、slice、map 和 channel; C. 空指针解析会触发异常； D. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值；  参考答案及解析：CD。A.声明的常量未使用不会报错；B.cap() 函数不适用 map。\n2.下面的代码输出什么？\nconst ( _ = iota c1 int = (10*iota) c2 d = iota ) func main() { fmt.Printf(\u0026quot;%d - %d - %d\u0026quot;,c1,c2, d) }   A. compile error B. 1 - 2 - 3 C. 10 - 20 - 30 D. 10 - 20 - 3  参考答案及解析：D。iota 的使用。\n\nDay 119. slice, map,变量的作用域 1.关于slice或map操作，下面正确的是。\nA.\nvar s []int s = append(s,1)  B.\nvar m map[string]int m[\u0026quot;one\u0026quot;] = 1  C.\nvar s []int s = make([]int, 0) s = append(s,1)  D.\nvar m map[string]int m = make(map[string]int) m[\u0026quot;one\u0026quot;] = 1  参考答案及解析：ACD。\n2.下面代码输出什么？请简要说明。\nvar ErrDidNotWork = errors.New(\u0026quot;did not work\u0026quot;) func DoTheThing(reallyDoIt bool) (err error) { if reallyDoIt { result, err := tryTheThing() if err != nil || result != \u0026quot;it worked\u0026quot; { err = ErrDidNotWork } } return err } func tryTheThing() (string, error) { return \u0026quot;\u0026quot;, ErrDidNotWork } func main() { fmt.Println(DoTheThing(true)) fmt.Println(DoTheThing(false)) }  参考答案即解析：都输出 nil。知识点：变量的作用域。因为 if 语句块内的 err 变量会遮罩函数作用域内的 err 变量。\n修复代码：\nfunc DoTheThing(reallyDoIt bool) (err error) { var result string if reallyDoIt { result, err = tryTheThing() if err != nil || result != \u0026quot;it worked\u0026quot; { err = ErrDidNotWork } } return err }  \nDay 120. 1.下面代码输出什么？\nfunc main() { fmt.Println(len(\u0026quot;你好bj!\u0026quot;)) fmt.Println(len(\u0026quot;你好\u0026quot;)) }  9,6\n2.是否可以编译通过？如果通过，输出什么？\nfunc GetValue(m map[int]string, id int) (string, bool) { if _, exist := m[id]; exist { return \u0026quot;存在数据\u0026quot;, true } return nil, false } func main() { intmap := map[int]string{ 1: \u0026quot;a\u0026quot;, 2: \u0026quot;bb\u0026quot;, 3: \u0026quot;ccc\u0026quot;, } v, err := GetValue(intmap, 3) fmt.Println(v, err) }  cannot use nil as type string in return argument  func GetValue(m map[int]string, id int) (string, bool) { if _, exist := m[id]; exist { return \u0026quot;存在数据\u0026quot;, true } return \u0026quot;\u0026quot;, false } func main() { intmap := map[int]string{ 1: \u0026quot;a\u0026quot;, 2: \u0026quot;bb\u0026quot;, 3: \u0026quot;ccc\u0026quot;, } v, err := GetValue(intmap, 3) fmt.Println(v, err) }  存在数据 true  ","date":1595867403,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595867403,"objectID":"39ce852e148ddc6ce0c27019e8ae1c78","permalink":"/go/interview/91-120/","publishdate":"2020-07-28T00:30:03+08:00","relpermalink":"/go/interview/91-120/","section":"go","summary":"Go语言面试题","tags":["Go"],"title":"Go语言中文网面试题 91-120","type":"go"},{"authors":[],"categories":["interview"],"content":" Day 61. 多重赋值 1.下面这段代码输出什么？\nfunc main() { var k = 1 var s = []int{1, 2} k, s[k] = 0, 3 fmt.Println(s[0] + s[1]) }  参考答案及解析：4。知识点：多重赋值。\n多重赋值分为两个步骤，有先后顺序：\n 计算等号左边的索引表达式和取址表达式，接着计算等号右边的表达式； 赋值；  所以本例，会先计算 s[k]，等号右边是两个表达式是常量，所以赋值运算等同于 k, s[1] = 0, 3。\n2.下面代码输出什么？\nfunc main() { var k = 9 for k = range []int{} {} fmt.Println(k) for k = 0; k \u0026lt; 3; k++ { } fmt.Println(k) for k = range (*[3]int)(nil) { } fmt.Println(k) }  参考答案及解析：932。\n\nDay 62. nil 1.下面哪一行代码会编译出错，请说明。\nfunc main() { nil := 123 fmt.Println(nil) var _ map[string]int = nil }  参考答案及解析：第 4 行，当前作用域中，预定义的 nil 被覆盖，此时 nil 是 int 类型值，不能赋值给 map 类型。\n2.下面代码输出什么？\nfunc main() { var x int8 = -128 var y = x/-1 fmt.Println(y) }  参考答案及解析：-128。因为溢出。\n\nDay 63. 匿名函数、defer 1.下面选项正确的是？\n A. 类型可以声明的函数体内； B. Go 语言支持 ++i 或者 \u0026ndash;i 操作； C. nil 是关键字； D. 匿名函数可以直接赋值给一个变量或者直接执行；  参考答案及解析：AD。\n2.下面的代码输出什么？\nfunc F(n int) func() int { return func() int { n++ return n } } func main() { f := F(5) defer func() { fmt.Println(f()) }() defer fmt.Println(f()) i := f() fmt.Println(i) }  参考答案及解析：768。知识点：匿名函数、defer()。defer() 后面的函数如果带参数，会优先计算参数，并将结果存储在栈中，到真正执行 defer() 的时候取出。\n\nDay 64. recover 1.下面列举的是 recover() 的几种调用方式，哪些是正确的？\n A.\nfunc main() { recover() panic(1) }  B.\nfunc main() { defer recover() panic(1) }  C.\nfunc main() { defer func() { recover() }() panic(1) }  D.\nfunc main() { defer func() { defer func() { recover() }() }() panic(1) }   参考答案及解析：C。recover() 必须在 defer() 函数中直接调用才有效。上面其他几种情况调用都是无效的：直接调用 recover()、在 defer() 中直接调用 recover() 和 defer() 调用时多层嵌套。\n2.下面代码输出什么，请说明？\nfunc main() { defer func() { fmt.Print(recover()) }() defer func() { defer fmt.Print(recover()) panic(1) }() defer recover() panic(2) }  参考答案及解析：21。recover() 必须在 defer() 函数中调用才有效，所以第 9 行代码捕获是无效的。在调用 defer() 时，便会计算函数的参数并压入栈中，所以执行第 6 行代码时，此时便会捕获 panic(2)；此后的 panic(1)，会被上一层的 recover() 捕获。所以输出 21。\n\nDay 65. bool ,defer, recover 1.flag 是 bool 型变量，下面 if 表达式符合编码规范的是？\n A. if flag == 1 B. if flag C. if flag == false D. if !flag  参考答案及解析：BCD。\n2.下面的代码输出什么，请说明？\nfunc main() { defer func() { fmt.Print(recover()) }() defer func() { defer func() { fmt.Print(recover()) }() panic(1) }() defer recover() panic(2) }  参考答案及解析：12。相关知识点请看 第64天 题目解析。\n\nDay 66. for-range, 数组指针,switch 1.下面的代码输出什么？\ntype T struct { n int } func main() { ts := [2]T{} for i, t := range ts { switch i { case 0: t.n = 3 ts[1].n = 9 case 1: fmt.Print(t.n, \u0026quot; \u0026quot;) } } fmt.Print(ts) }  参考答案及解析：0 [{0} {9}]。知识点：for-range 循环数组。此时使用的是数组 ts 的副本，所以 t.n = 3 的赋值操作不会影响原数组。\n2.下面的代码输出什么？\ntype T struct { n int } func main() { ts := [2]T{} for i, t := range \u0026amp;ts { switch i { case 0: t.n = 3 ts[1].n = 9 case 1: fmt.Print(t.n, \u0026quot; \u0026quot;) } } fmt.Print(ts) }  参考答案及解析：9 [{0} {9}]。知识点：for-range 数组指针。for-range 循环中的循环变量 t 是原数组元素的副本。如果数组元素是结构体值，则副本的字段和原数组字段是两个不同的值。\n\nDay 67. for-range 切片 1.下面的代码输出什么？\ntype T struct { n int } func main() { ts := [2]T{} for i := range ts[:] { switch i { case 0: ts[1].n = 9 case 1: fmt.Print(ts[i].n, \u0026quot; \u0026quot;) } } fmt.Print(ts) }  参考答案及解析：9 [{0} {9}]。知识点：for-range 切片。for-range 切片时使用的是切片的副本，但不会复制底层数组，换句话说，此副本切片与原数组共享底层数组。\n2.下面的代码输出什么？\ntype T struct { n int } func main() { ts := [2]T{} for i := range ts[:] { switch t := \u0026amp;ts[i]; i { case 0: t.n = 3; ts[1].n = 9 case 1: fmt.Print(t.n, \u0026quot; \u0026quot;) } } fmt.Print(ts) }  参考答案及解析：9 [{3} {9}]。知识点：for-range 切片。参考前几道题的解析，这道题的答案应该很明显。\n\nDay 68. defer、for-range 1.下面代码有什么问题吗？\nfunc main() { for i:=0;i\u0026lt;10 ;i++ { loop: println(i) } goto loop }  参考答案及解析：goto 不能跳转到其他函数或者内层代码。编译报错：\ngoto loop jumps into block starting at  2.下面代码输出什么，请说明。\nfunc main() { x := []int{0, 1, 2} y := [3]*int{} for i, v := range x { defer func() { print(v) }() y[i] = \u0026amp;v } print(*y[0], *y[1], *y[2]) }  参考答案及解析：22222。知识点：defer()、for-range。for-range 虽然使用的是 :=，但是 v 不会重新声明，可以打印 v 的地址验证下。\n\nDay 69. 闭包, slice , map 1.关于 slice 或 map 操作，下面正确的是？\n A\nvar s []int s = append(s,1)  B\nvar m map[string]int m[\u0026quot;one\u0026quot;] = 1  C\nvar s []int s = make([]int, 0) s = append(s,1)  D\nvar m map[string]int m = make(map[string]int) m[\u0026quot;one\u0026quot;] = 1   参考答案及解析：ACD。\n2.下面代码输出什么？\nfunc test(x int) (func(), func()) { return func() { println(x) x += 10 }, func() { println(x) } } func main() { a, b := test(100) a() b() }  参考答案及解析：100 110。知识点：闭包引用相同变量。\n\nDay 70. 字符串， defer 1.关于字符串连接，下面语法正确的是？\n A. str := \u0026lsquo;abc\u0026rsquo; + \u0026lsquo;123\u0026rsquo; B. str := \u0026ldquo;abc\u0026rdquo; + \u0026ldquo;123\u0026rdquo; C. str ：= \u0026lsquo;123\u0026rsquo; + \u0026ldquo;abc\u0026rdquo; D. fmt.Sprintf(\u0026ldquo;abc%d\u0026rdquo;, 123)  参考答案及解析：BD。知识点：单引号、双引号和字符串连接。在 Go 语言中，双引号用来表示字符串 string，其实质是一个 byte 类型的数组，单引号表示 rune 类型。\n2.下面代码能编译通过吗？可以的话，输出什么？\nfunc main() { println(DeferTest1(1)) println(DeferTest2(1)) } func DeferTest1(i int) (r int) { r = i defer func() { r += 3 }() return r } func DeferTest2(i int) (r int) { defer func() { r += i }() return 2 }  参考答案及解析：43。具体解析请看《5 年 Gopher 都不知道的 defer 细节，你别再掉进坑里！》。\n\nDay 71. 取反 1.判断题：对变量x的取反操作是 ~x？\n从参考答案及解析：错。\nGo 语言的取反操作是 ^，它返回一个每个 bit 位都取反的数。作用类似在 C、C#、Java 语言中中符号 ~，对于有符号的整数来说，是按照补码进行取反操作的（快速计算方法：对数 a 取反，结果为 -(a+1) ），对于无符号整数来说就是按位取反。\n2.下面代码输出什么，请说明原因。\ntype Slice []int func NewSlice() Slice { return make(Slice, 0) } func (s *Slice) Add(elem int) *Slice { *s = append(*s, elem) fmt.Print(elem) return s } func main() { s := NewSlice() defer s.Add(1).Add(2) s.Add(3) }  参考答案及解析：132。这一题有两点需要注意：1.Add() 方法的返回值依然是指针类型 *Slice，所以可以循环调用方法 Add()；2.defer 函数的参数（包括接收者）是在 defer 语句出现的位置做计算的，而不是在函数执行的时候计算的，所以 s.Add(1) 会先于 s.Add(3) 执行。\n\nDay 72. 指针方法, 切片 1.下面的代码输出什么，请说明。\ntype Slice []int func NewSlice() Slice { return make(Slice, 0) } func (s *Slice) Add(elem int) *Slice { *s = append(*s, elem) fmt.Print(elem) return s } func main() { s := NewSlice() defer func() { s.Add(1).Add(2) }() s.Add(3) }  参考答案及解析：312。对比昨天的第二题，本题的 s.Add(1).Add(2) 作为一个整体包在一个匿名函数中，会延迟执行。\n2.下面的代码输出什么，请说明？\ntype Orange struct { Quantity int } func (o *Orange) Increase(n int) { o.Quantity += n } func (o *Orange) Decrease(n int) { o.Quantity -= n } func (o *Orange) String() string { return fmt.Sprintf(\u0026quot;%#v\u0026quot;, o.Quantity) } func main() { var orange Orange orange.Increase(10) orange.Decrease(5) fmt.Println(orange) }  参考答案及解析：{5}。这道题容易忽视的点是，String() 是指针方法，而不是值方法，所以使用 Println() 输出时不会调用到 String() 方法。\n可以这样修复：\nfunc main() { orange := \u0026amp;Orange{} orange.Increase(10) orange.Decrease(5) fmt.Println(orange }  \nDay 73. for, 函数调用 1.下面代码输出什么？\nfunc test() []func() { var funs []func() for i := 0; i \u0026lt; 2; i++ { funs = append(funs, func() { println(\u0026amp;i, i) }) } return funs } func main() { funs := test() for _, f := range funs { f() } }  参考答案及解析：\n0xc000018058 2 0xc000018058 2  知识点：闭包延迟求值。for 循环局部变量 i，匿名函数每一次使用的都是同一个变量。（说明：i 的地址，输出可能与上面的不一样）。\n如果想要匿名函数每一次输出不同，应该怎么修改代码？\n2.下面的代码能编译通过吗？可以的话输出什么，请说明？\nvar f = func(i int) { print(\u0026quot;x\u0026quot;) } func main() { f := func(i int) { print(i) if i \u0026gt; 0 { f(i - 1) } } f(10) }  参考答案及解析：10x。这道题一眼看上去会输出 109876543210，其实这是错误的答案，这里不是递归。假设 main() 函数里为 f2()，外面的为 f1()，当声明 f2() 时，调用的是已经完成声明的 f1()。\n看下面这段代码你应该会更容易理解一点：\nvar x = 23 func main() { x := 2*x - 4 println(x) // 输出:42 }  \nDay 74. GOMAXPROCS, := 1.下面代码有什么问题，请说明？\nfunc main() { runtime.GOMAXPROCS(1) go func() { for i:=0;i\u0026lt;10 ;i++ { fmt.Println(i) } }() for {} }  参考答案及解析：for {} 独占 CPU 资源导致其他 Goroutine 饿死。\n可以通过阻塞的方式避免 CPU 占用，修复代码：\nfunc main() { runtime.GOMAXPROCS(1) go func() { for i:=0;i\u0026lt;10 ;i++ { fmt.Println(i) } os.Exit(0) }() select {} }  引自《Go语言高级编程》\n2.假设 x 已声明，y 未声明，下面 4 行代码哪些是正确的。错误的请说明原因？\nx, _ := f() // 1 x, _ = f() // 2 x, y := f() // 3 x, y = f() // 4  参考答案及解析：2、3正确。知识点：简短变量声明。使用简短变量声明有几个需要注意的地方：\n 只能用于函数内部； 短变量声明语句中至少要声明一个新的变量；  \nDay 75. panic、recover 1.下面的代码有什么问题，请说明？\nfunc main() { f, err := os.Open(\u0026quot;file\u0026quot;) defer f.Close() if err != nil { return } b, err := ioutil.ReadAll(f) println(string(b)) }  参考答案及解析：defer 语句应该放在 if() 语句后面，先判断 err，再 defer 关闭文件句柄。\n修复代码：\nfunc main() { f, err := os.Open(\u0026quot;file\u0026quot;) if err != nil { return } defer f.Close() b, err := ioutil.ReadAll(f) println(string(b)) }  2.下面代码输出什么，为什么？\nfunc f() { defer func() { if r := recover(); r != nil { fmt.Printf(\u0026quot;recover:%#v\u0026quot;, r) } }() panic(1) panic(2) } func main() { f() }  参考答案及解析：recover:1。知识点：panic、recover()。当程序 panic 时就不会往下执行，可以使用 recover() 捕获 panic 的内容。\n\nDay 76. 类型断言，结构体嵌套, 协程 1.下面这段代码输出什么？\ntype S1 struct{} func (s1 S1) f() { fmt.Println(\u0026quot;S1.f()\u0026quot;) } func (s1 S1) g() { fmt.Println(\u0026quot;S1.g()\u0026quot;) } type S2 struct { S1 } func (s2 S2) f() { fmt.Println(\u0026quot;S2.f()\u0026quot;) } type I interface { f() } func printType(i I) { fmt.Printf(\u0026quot;%T\\n\u0026quot;, i) if s1, ok := i.(S1); ok { s1.f() s1.g() } if s2, ok := i.(S2); ok { s2.f() s2.g() } } func main() { printType(S1{}) printType(S2{}) }  参考答案及解析：\nmain.S1 S1.f() S1.g() main.S2 S2.f() S1.g()  知识点：类型断言，结构体嵌套。结构体 S2 嵌套了结构体 S1，S2 自己没有实现 g() ，调用的是 S1 的 g()。详细的解析请看《Go 语言接口详解（二）》\n2.下面的代码有什么问题？\nfunc main() { var wg sync.WaitGroup wg.Add(1) go func() { fmt.Println(\u0026quot;1\u0026quot;) wg.Done() wg.Add(1) }() wg.Wait() }  参考答案及解析：协程里面，使用 wg.Add(1) 但是没有 wg.Done()，导致 panic()。\n\nDay 77. cap, 可变函数 1.关于 cap 函数适用下面哪些类型？\n A. 数组； B. channel; C. map； D. slice；  参考答案即解析：ABD。cap() 函数的作用：\n arry 返回数组的元素个数； slice 返回 slice 的最大容量； channel 返回 channel 的容量；  2.下面代码输出什么？\nfunc hello(num ...int) { num[0] = 18 } func Test13(t *testing.T) { i := []int{5, 6, 7} hello(i...) fmt.Println(i[0]) } func main() { t := \u0026amp;testing.T{} Test13(t) }   A. 18 B. 5 C. Compilation error  参考答案及解析：A。可变函数是指针传递。\n\nDay 78. switch 1.关于 switch 语句，下面说法正确的是？\n A. 单个 case 中，可以出现多个结果选项； B. 需要使用 break 来明确退出一个 case; C. 只有在 case 中明确添加 fallthrought 关键字，才会继续执行紧跟的下一个 case; D. 条件表达式必须为常量或者整数；  参考答案及解析：AC。\n2.下面代码能编译通过吗？可以的话，输出什么？\nfunc alwaysFalse() bool { return false } func main() { switch alwaysFalse() { case true: println(true) case false: println(false) } }  参考答案及解析：可以编译通过，输出：true。知识点：Go 代码断行规则。\n详情请查看：https://gfw.go101.org/article/line-break-rules.html\n\nDay 79. interface, struct 1.interface{} 是可以指向任意对象的 Any 类型，是否正确？\n A. false B. true  参考答案及解析：B。\n2.下面的代码有什么问题？\ntype ConfigOne struct { Daemon string } func (c *ConfigOne) String() string { return fmt.Sprintf(\u0026quot;print: %v\u0026quot;, c) } func main() { c := \u0026amp;ConfigOne{} c.String() }  参考答案及解析：无限递归循环，栈溢出。知识点：类型的 String() 方法。如果类型定义了 String() 方法，使用 Printf()、Print() 、 Println() 、 Sprintf() 等格式化输出时会自动使用 String() 方法。\n\nDay 80. 全局变量,WaitGroup 1.定义一个包内全局字符串变量，下面语法正确的是？\n A. var str string B. str := \u0026ldquo;\u0026rdquo; C. str = \u0026ldquo;\u0026rdquo; D. var str = \u0026ldquo;\u0026rdquo;  参考答案及解析：AD。全局变量要定义在函数之外，而在函数之外定义的变量只能用 var 定义。短变量声明 := 只能用于函数之内。\n2.下面的代码有什么问题？\nfunc main() { wg := sync.WaitGroup{} for i := 0; i \u0026lt; 5; i++ { go func(wg sync.WaitGroup, i int) { wg.Add(1) fmt.Printf(\u0026quot;i:%d\\n\u0026quot;, i) wg.Done() }(wg, i) } wg.Wait() fmt.Println(\u0026quot;exit\u0026quot;) }  参考答案及解析：知识点：WaitGroup 的使用。存在两个问题：\n 在协程中使用 wg.Add()； 使用了 sync.WaitGroup 副本；  修复代码：\nfunc main() { wg := sync.WaitGroup{} for i := 0; i \u0026lt; 5; i++ { wg.Add(1) go func(i int) { fmt.Printf(\u0026quot;i:%d\\n\u0026quot;, i) wg.Done() }(i) } wg.Wait() fmt.Println(\u0026quot;exit\u0026quot;) }  或者：\nfunc main() { wg := \u0026amp;sync.WaitGroup{} for i := 0; i \u0026lt; 5; i++ { wg.Add(1) go func(wg *sync.WaitGroup,i int) { fmt.Printf(\u0026quot;i:%d\\n\u0026quot;, i) wg.Done() }(wg,i) } wg.Wait() fmt.Println(\u0026quot;exit\u0026quot;) }  \nDay 81. 多重赋值, 野指针 1.下面的代码输出什么？\nfunc main() { var a []int = nil a, a[0] = []int{1, 2}, 9 fmt.Println(a) }  参考答案即解析：运行时错误。知识点：多重赋值。\n多重赋值分为两个步骤，有先后顺序：\n 计算等号左边的索引表达式和取址表达式，接着计算等号右边的表达式； 赋值；  2.下面代码中的指针 p 为野指针，因为返回的栈内存在函数结束时会被释放？\ntype TimesMatcher struct { base int } func NewTimesMatcher(base int) *TimesMatcher { return \u0026amp;TimesMatcher{base:base} } func main() { p := NewTimesMatcher(3) fmt.Println(p) }   A. false B. true  参考答案及解析：A。Go语言的内存回收机制规定，只要有一个指针指向引用一个变量，那么这个变量就不会被释放（内存逃逸），因此在 Go 语言中返回函数参数或临时变量是安全的。\n\nDay 82. iota, 数值溢出 1.下面这段代码输出什么？\nfunc main() { count := 0 for i := range [256]struct{}{} { m, n := byte(i), int8(i) if n == -n { count++ } if m == -m { count++ } } fmt.Println(count) }  参考答案及解析：4。知识点：数值溢出。当 i 的值为 0、128 是会发生相等情况，注意 byte 是 uint8 的别名。\n2.下面代码输出什么？\nconst ( azero = iota aone = iota ) const ( info = \u0026quot;msg\u0026quot; bzero = iota bone = iota ) func main() { fmt.Println(azero, aone) fmt.Println(bzero, bone) }  参考答案及解析：0 1 1 2。知识点：iota 的使用。这道题易错点在 bzero、bone 的值，在一个常量声明代码块中，如果 iota 没出现在第一行，则常量的初始值就是非 0 值。\n\nDay 83. 接口,包 1.同级文件的包名不允许有多个，是否正确？\n A. true B. false  参考答案及解析：A。一个文件夹下只能有一个包，可以多个.go文件，但这些文件必须属于同一个包。\n看昨天答题评论，有个例外，Go test 支持在不同名的 package 属于同一个目录，只要包名是以 package_test 形式命名即可。大家可以看下 strings 包，就是这样子的。\n2.下面的代码有什么问题，请说明。\ntype data struct { name string } func (p *data) print() { fmt.Println(\u0026quot;name:\u0026quot;, p.name) } type printer interface { print() } func main() { d1 := data{\u0026quot;one\u0026quot;} d1.print() var in printer = data{\u0026quot;two\u0026quot;} in.print() }  参考答案及解析：编译报错。\ncannot use data literal (type data) as type printer in assignment: data does not implement printer (print method has pointer receiver)  结构体类型 data 没有实现接口 printer。知识点：接口。\n\nDay 84. panic, 切片 1.函数执行时，如果由于 panic 导致了异常，则延迟函数不会执行。这一说法是否正确？\n A. true B. false  参考答案及解析：B。 由 panic 引发异常以后，程序停止执行，然后调用延迟函数（defer），就像程序正常退出一样。\n2.下面代码输出什么？\nfunc main() { a := [3]int{0, 1, 2} s := a[1:2] s[0] = 11 s = append(s, 12) s = append(s, 13) s[0] = 21 fmt.Println(a) fmt.Println(s) }  参考答案及解析：\n输出：\n[0 11 12] [21 12 13]  详情请参考《非懂不可的Slice（二）》\n\nDay 85. 拷贝切片,append,字符串 1.下面这段代码输出什么？请简要说明。\nfunc main() { fmt.Println(strings.TrimRight(\u0026quot;ABBA\u0026quot;, \u0026quot;BA\u0026quot;)) }  参考答案及解析：输出空字符。这是一个大多数人遇到的坑，TrimRight() 会将第二个参数字符串里面所有的字符拿出来处理，只要与其中任何一个字符相等，便会将其删除。想正确地截取字符串，可以参考 TrimSuffix() 函数。\n2.下面代码输出什么？\nfunc main() { var src, dst []int src = []int{1, 2, 3} copy(dst, src) fmt.Println(dst) }  参考答案及解析：输出 []。知识点：拷贝切片。copy(dst, src) 函数返回 len(dst)、len(src) 之间的最小值。如果想要将 src 完全拷贝至 dst，必须给 dst 分配足够的内存空间。\n修复代码：\nfunc main() { var src, dst []int src = []int{1, 2, 3} dst = make([]int, len(src)) n := copy(dst, src) fmt.Println(n,dst) }  或者直接使用 append()\nfunc main() { var src, dst []int src = []int{1, 2, 3} dst = append(dst, src...) fmt.Println(\u0026quot;dst:\u0026quot;, dst) }  详情请参考《非懂不可的Slice（二）》\n\nDay 86. 进制数,运算符优先级 1.n 是秒数，下面代码输出什么？\nfunc main() { n := 43210 fmt.Println(n/60*60, \u0026quot; hours and \u0026quot;, n%60*60, \u0026quot; seconds\u0026quot;) }  参考答案及解析：43200 hours and 600 seconds。知识点：运算符优先级。算术运算符 *、/ 和 % 的优先级相同，从左向右结合。\n修复代码如下：\nfunc main() { n := 43210 fmt.Println(n/(60*60), \u0026quot;hours and\u0026quot;, n%(60*60), \u0026quot;seconds\u0026quot;) }  2.下面代码输出什么，为什么？\nconst ( Century = 100 Decade = 010 Year = 001 ) func main() { fmt.Println(Century + 2*Decade + 2*Year) }  参考答案及解析：118。知识点：进制数。Go 语言里面，八进制数以 0 开头，十六进制数以 0x 开头，所以 Decade 表示十进制的 8。\n\nDay 87. 协程, 运算符优先级 1.关于协程，下面说法正确是()\n A.协程和线程都可以实现程序的并发执行； B.线程比协程更轻量级； C.协程不存在死锁问题； D.通过 channel 来进行协程间的通信；  参考答案及解析：AD。\n2.在数学里面，有著名的勾股定理：\n例如，有我们熟悉的组合（3，4，5）、（6、8、10）等。在 Go 语言中，下面代码输出 true：\nfmt.Println(3^2+4^2 == 5^2) // true  问题来了，下面代码输出什么，请简要说明。\nfunc main() { fmt.Println(6^2+8^2 == 10^2) }  参考答案及解析：false。在 Go 语言里面，^ 作为二元运算符时表示按位异或：对应位，相同为 0，相异为 1。所以第一段代码输出 true 是因为：\n0011 ^ 0010 == 0001 (3^2 == 1) 0100 ^ 0010 == 0110 (4^2 == 6) 0101 ^ 0010 == 0111 (5^2 == 7)  1+6=7，这当然是相等的。你来试试分解下第二段代码的数学表达式。\n\nDay 88. map,nil 1.下面这段代码能通过编译吗？请简要说明。\nfunc main() { m := make(map[string]int) m[\u0026quot;foo\u0026quot;]++ fmt.Println(m[\u0026quot;foo\u0026quot;]) }  参考答案及解析：能通过编译。\n上面的代码可以理解成：\nfunc main() { m := make(map[string]int) v := m[\u0026quot;foo\u0026quot;] v++ m[\u0026quot;foo\u0026quot;] = v fmt.Println(m[\u0026quot;foo\u0026quot;]) }  2.下面的代码输出什么，请简要说明？\nfunc Foo() error { var err *os.PathError = nil // … return err } func main() { err := Foo() fmt.Println(err) fmt.Println(err == nil) }  参考答案及解析：nil false。知识点：接口值与 nil 值。只有在值和动态类型都为 nil 的情况下，接口值才为 nil。Foo() 函数返回的 err 变量，值为 nil、动态类型为 *os.PathError，与 nil（值为 nil，动态类型为 nil）显然是不相等。我们可以打印下变量 err 的详情：\nfmt.Printf(\u0026quot;%#v\\n\u0026quot;,err) // (*os.PathError)(nil)  一个更合适的解决办法：\nfunc Foo() (err error) { // … return } func main() { err := Foo() fmt.Println(err) fmt.Println(err == nil) }  \nDay 89. 指针 1.下面代码能编译通过吗？请简要说明。\nfunc main() { v := []int{1, 2, 3} for i, n := 0, len(v); i \u0026lt; n; i++ { v = append(v, i) } fmt.Println(v) }  参考答案及解析：能编译通过，输出 [1 2 3 0 1 2]。for 循环开始的时候，终止条件只会计算一次。\n2.下面代码输出什么？\ntype P *int type Q *int func main() { var p P = new(int) *p += 8 var x *int = p var q Q = x *q++ fmt.Println(*p, *q) }   A.8 8 B.8 9 C.9 9  参考答案及解析：C。指针变量指向相同的地址。\n\nDay 90. 类型 1.下面代码能通过编译吗？\ntype T int func F(t T) {} func main() { var q int F(q) }  2.下面代码能通过编译吗？请简要说明。\ntype T []int func F(t T) {} func main() { var q []int F(q) }  我们将这两道题目放到一块做一个解析，第一题不能通过编译，第二题可以通过编译。我们知道不同类型的值是不能相互赋值的，即使底层类型一样，所以第一题编译不通过；对于底层类型相同的变量可以相互赋值还有一个重要的条件，即至少有一个不是有名类型（named type）。\n这是 Go 语言规范手册的原文：\n \u0026ldquo;x\u0026rsquo;s type V and T have identical underlying types and at least one of V or T is not a named type. \u0026ldquo;\n Named Type 有两类：\n 内置类型，比如 int, int64, float, string, bool 等； 使用关键字 type 声明的类型；  Unnamed Type 是基于已有的 Named Type 组合一起的类型，例如：struct{}、[]string、interface{}、map[string]bool 等。\n","date":1595867388,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595867388,"objectID":"e10456b1cd3fdccf72d55d0f83dc4407","permalink":"/go/interview/61-90/","publishdate":"2020-07-28T00:29:48+08:00","relpermalink":"/go/interview/61-90/","section":"go","summary":"Go语言面试题","tags":["Go"],"title":"Go语言中文网面试题 61-90","type":"go"},{"authors":[],"categories":["interview"],"content":" Day 31. 可变函数、append() 1.下面这段代码输出什么？\nfunc change(s ...int) { s = append(s,3) } func main() { slice := make([]int,5,5) slice[0] = 1 slice[1] = 2 change(slice...) fmt.Println(slice) change(slice[0:2]...) fmt.Println(slice) }  参考答案及解析：\n[1 2 0 0 0] [1 2 3 0 0]  知识点：可变函数、append()操作。\nGo 提供的语法糖...，可以将 slice 传进可变函数，不会创建新的切片。\n第一次调用 change() 时，append() 操作使切片底层数组发生了扩容，原 slice 的底层数组不会改变；\n第二次调用change() 函数时，使用了操作符[i,j]获得一个新的切片，假定为 slice1，它的底层数组和原切片底层数组是重合的，不过 slice1 的长度、容量分别是 2、5，所以在 change() 函数中对 slice1 底层数组的修改会影响到原切片。\n可变函数\n非懂不可的Slice（一）\n非懂不可的Slice（二）\n\n2.下面这段代码输出什么？\nfunc main() { var a = []int{1, 2, 3, 4, 5} var r [5]int for i, v := range a { if i == 0 { a[1] = 12 a[2] = 13 } r[i] = v } fmt.Println(\u0026quot;r = \u0026quot;, r) fmt.Println(\u0026quot;a = \u0026quot;, a) }  参考答案及解析：\nr = [1 12 13 4 5] a = [1 12 13 4 5]  这道题是 第30天 的第二题的一个解决办法，这的 a 是一个切片，那切片是怎么实现的呢？切片在 go 的内部结构有一个指向底层数组的指针，当 range 表达式发生复制时，副本的指针依旧指向原底层数组，所以对切片的修改都会反应到底层数组上，所以通过 v 可以获得修改后的数组元素。\n引自：https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/\n\nDay 32. for range ,map 1.下面这段代码输出结果正确吗？\ntype Foo struct { bar string } func main() { s1 := []Foo{ {\u0026quot;A\u0026quot;}, {\u0026quot;B\u0026quot;}, {\u0026quot;C\u0026quot;}, } s2 := make([]*Foo, len(s1)) for i, value := range s1 { s2[i] = \u0026amp;value } fmt.Println(s1[0], s1[1], s1[2]) fmt.Println(s2[0], s2[1], s2[2]) } 输出： {A} {B} {C} \u0026amp;{A} \u0026amp;{B} \u0026amp;{C}  参考答案及解析：s2 的输出结果错误。s2 的输出是 \u0026amp;{C} \u0026amp;{C} \u0026amp;{C}，在 第 30 天 的答案解析第二题，我们提到过，for range 使用短变量声明(:=)的形式迭代变量时，变量 i、value 在每次循环体中都会被重用，而不是重新声明。所以 s2 每次填充的都是临时变量 value 的地址，而在最后一次循环中，value 被赋值为{c}。因此，s2 输出的时候显示出了三个 \u0026amp;{c}。\n可行的解决办法如下：\nfor i := range s1 { s2[i] = \u0026amp;s1[i] }  2.下面代码里的 counter 的输出值？\nfunc main() { var m = map[string]int{ \u0026quot;A\u0026quot;: 21, \u0026quot;B\u0026quot;: 22, \u0026quot;C\u0026quot;: 23, } counter := 0 for k, v := range m { if counter == 0 { delete(m, \u0026quot;A\u0026quot;) } counter++ fmt.Println(k, v) } fmt.Println(\u0026quot;counter is \u0026quot;, counter) }   A. 2 B. 3 C. 2 或 3  参考答案及解析：C。for range map 是无序的，如果第一次循环到 A，则输出 3；否则输出 2。\n\nDay 33. 协程，循环语句，多重赋值 1.关于协程，下面说法正确是（）\n A. 协程和线程都可以实现程序的并发执行； B. 线程比协程更轻量级； C. 协程不存在死锁问题； D. 通过 channel 来进行协程间的通信；  参考答案及解析：AD。\n\n2.关于循环语句，下面说法正确的有（）\n A. 循环语句既支持 for 关键字，也支持 while 和 do-while； B. 关键字 for 的基本使用方法与 C/C++ 中没有任何差异； C. for 循环支持 continue 和 break 来控制循环，但是它提供了一个更高级的 break，可以选择中断哪一个循环； D. for 循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量；  参考答案及解析：CD。\n\n3.下面代码输出正确的是？\nfunc main() { i := 1 s := []string{\u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;C\u0026quot;} i, s[i-1] = 2, \u0026quot;Z\u0026quot; fmt.Printf(\u0026quot;s: %v \\n\u0026quot;, s) }   A. s: [Z,B,C] B. s: [A,Z,C]  参考答案及解析：A。知识点：多重赋值。\n多重赋值分为两个步骤，有先后顺序：\n 计算等号左边的索引表达式和取址表达式，接着计算等号右边的表达式； 赋值；  所以本例，会先计算 s[i-1]，等号右边是两个表达式是常量，所以赋值运算等同于 i, s[0] = 2, \u0026quot;Z\u0026quot;。\n\nDay 34. 强制类型转化,类型断言、方法集 1.关于类型转化，下面选项正确的是？\nA. type MyInt int var i int = 1 var j MyInt = i B. type MyInt int var i int = 1 var j MyInt = (MyInt)i C. type MyInt int var i int = 1 var j MyInt = MyInt(i) D. type MyInt int var i int = 1 var j MyInt = i.(MyInt)  参考答案及解析：C。知识点：强制类型转化。\n\n2.关于switch语句，下面说法正确的有?\n A. 条件表达式必须为常量或者整数； B. 单个case中，可以出现多个结果选项； C. 需要用break来明确退出一个case； D. 只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case；  参考答案及解析：BD。参考文章 条件语句和循环语句\n\n3.如果 Add() 函数的调用代码为：\nfunc main() { var a Integer = 1 var b Integer = 2 var i interface{} = \u0026amp;a sum := i.(*Integer).Add(b) fmt.Println(sum) }  则Add函数定义正确的是()\nA. type Integer int func (a Integer) Add(b Integer) Integer { return a + b } B. type Integer int func (a Integer) Add(b *Integer) Integer { return a + *b } C. type Integer int func (a *Integer) Add(b Integer) Integer { return *a + b } D. type Integer int func (a *Integer) Add(b *Integer) Integer { return *a + *b }  参考答案及解析：AC。知识点：类型断言、方法集。\n\nDay 35. bool, 自增和自减, 接口 1.关于 bool 变量 b 的赋值，下面错误的用法是？\n A. b = true B. b = 1 C. b = bool(1) D. b = (1 == 2)  参考答案及解析：BC。\n\n2.关于变量的自增和自减操作，下面语句正确的是？\nA. i := 1 i++ B. i := 1 j = i++ C. i := 1 ++i D. i := 1 i--  参考答案及解析：AD。知识点：自增自减操作。i++ 和 i\u0026ndash; 在 Go 语言中是语句，不是表达式，因此不能赋值给另外的变量。此外没有 ++i 和 \u0026ndash;i。\n3.关于GetPodAction定义，下面赋值正确的是\ntype Fragment interface { Exec(transInfo *TransInfo) error } type GetPodAction struct { } func (g GetPodAction) Exec(transInfo *TransInfo) error { ... return nil }   A. var fragment Fragment = new(GetPodAction) B. var fragment Fragment = GetPodAction C. var fragment Fragment = \u0026amp;GetPodAction{} D. var fragment Fragment = GetPodAction{}  参考答案及解析：ACD。\n\nDay 36. select, 函数声明，切片初始化 1.关于函数声明，下面语法正确的是？\n A. func f(a, b int) (value int, err error) B. func f(a int, b int) (value int, err error) C. func f(a, b int) (value int, error) D. func f(a int, b int) (int, int, error)  参考答案及解析：ABD。参考文章《函数》\n\n2.关于整型切片的初始化，下面正确的是？\n A. s := make([]int) B. s := make([]int, 0) C. s := make([]int, 5, 10) D. s := []int{1, 2, 3, 4, 5}  参考答案及解析：BCD。参考文章《非懂不可的Slice（一）》\n\n3.下面代码会触发异常吗？请说明。\nfunc main() { runtime.GOMAXPROCS(1) int_chan := make(chan int, 1) string_chan := make(chan string, 1) int_chan \u0026lt;- 1 string_chan \u0026lt;- \u0026quot;hello\u0026quot; select { case value := \u0026lt;-int_chan: fmt.Println(value) case value := \u0026lt;-string_chan: panic(value) } }  参考答案及解析：select 会随机选择一个可用通道做收发操作，所以可能触发异常，也可能不会。具体详看《Go 并发 \u0026ndash; Select》\n\nDay 37. 函数返回值类型, channel, 常量 1.关于channel的特性，下面说法正确的是？\n A. 给一个 nil channel 发送数据，造成永远阻塞 B. 从一个 nil channel 接收数据，造成永远阻塞 C. 给一个已经关闭的 channel 发送数据，引起 panic D. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值  参考答案及解析：ABCD。\n\n2.下面代码有什么问题？\nconst i = 100 var j = 123 func main() { fmt.Println(\u0026amp;j, j) fmt.Println(\u0026amp;i, i) }  参考答案及解析：编译报错cannot take the address of i。知识点：常量。常量不同于变量的在运行期分配内存，常量通常会被编译器在预处理阶段直接展开，作为指令数据使用，所以常量无法寻址。\n\n3.下面代码能否编译通过？如果通过，输出什么？\nfunc GetValue(m map[int]string, id int) (string, bool) { if _, exist := m[id]; exist { return \u0026quot;exist\u0026quot;, true } return nil, false } func main() { intmap := map[int]string{ 1: \u0026quot;a\u0026quot;, 2: \u0026quot;b\u0026quot;, 3: \u0026quot;c\u0026quot;, } v, err := GetValue(intmap, 3) fmt.Println(v, err) }  参考答案及解析：不能通过编译。知识点：函数返回值类型。nil 可以用作 interface、function、pointer、map、slice 和 channel 的“空值”。但是如果不特别指定的话，Go 语言不能识别类型，所以会报错:cannot use nil as type string in return argument.\n\nDay 38. 异常 1.关于异常的触发，下面说法正确的是？\n A. 空指针解析； B. 下标越界； C. 除数为0； D. 调用panic函数；  参考答案及解析：ABCD。\n\n2.下面代码输出什么？\nfunc main() { x := []string{\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;} for v := range x { fmt.Print(v) } }  参考答案及解析：012。注意区别下面代码段：\nfunc main() { x := []string{\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;} for _, v := range x { fmt.Print(v) //输出 abc } }  \n3.下面这段代码能否编译通过？如果通过，输出什么？\ntype User struct{} type User1 User type User2 = User func (i User1) m1() { fmt.Println(\u0026quot;m1\u0026quot;) } func (i User) m2() { fmt.Println(\u0026quot;m2\u0026quot;) } func main() { var i1 User1 var i2 User2 i1.m1() i2.m2() }  参考答案及解析：能，输出m1 m2，第 2 行代码基于类型 User 创建了新类型 User1，第 3 行代码是创建了 User 的类型别名 User2，注意使用 = 定义类型别名。因为 User2 是别名，完全等价于 User，所以 User2 具有 User 所有的方法。但是 i1.m1() 是不能执行的，因为 User1 没有定义该方法。\n\nDay 39. channel, go, interface 1.关于无缓冲和有冲突的channel，下面说法正确的是？\n A. 无缓冲的channel是默认的缓冲为1的channel； B. 无缓冲的channel和有缓冲的channel都是同步的； C. 无缓冲的channel和有缓冲的channel都是非同步的； D. 无缓冲的channel是同步的，而有缓冲的channel是非同步的；  参考答案及解析：D。参考文章《Go 并发 \u0026ndash; 信道》\n\n2.下面代码是否能编译通过？如果通过，输出什么？\nfunc Foo(x interface{}) { if x == nil { fmt.Println(\u0026quot;empty interface\u0026quot;) return } fmt.Println(\u0026quot;non-empty interface\u0026quot;) } func main() { var x *int = nil Foo(x) }  参考答案及解析：non-empty interface 考点：interface 的内部结构，我们知道接口除了有静态类型，还有动态类型和动态值，当且仅当动态值和动态类型都为 nil 时，接口类型值才为 nil。这里的 x 的动态类型是 *int，所以 x 不为 nil。\n\n3.下面代码输出什么？\nfunc main() { ch := make(chan int, 100) // A go func() { for i := 0; i \u0026lt; 10; i++ { ch \u0026lt;- i } }() // B go func() { for { a, ok := \u0026lt;-ch if !ok { fmt.Println(\u0026quot;close\u0026quot;) return } fmt.Println(\u0026quot;a: \u0026quot;, a) } }() close(ch) fmt.Println(\u0026quot;ok\u0026quot;) time.Sleep(time.Second * 10) }  参考答案及解析：程序抛异常。先定义下，第一个协程为 A 协程，第二个协程为 B 协程；当 A 协程还没起时，主协程已经将 channel 关闭了，当 A 协程往关闭的 channel 发送数据时会 panic，panic: send on closed channel。\n\nDay 40. select, channel 1.关于select机制，下面说法正确的是?\n A. select机制用来处理异步IO问题； B. select机制最大的一条限制就是每个case语句里必须是一个IO操作； C. golang在语言级别支持select关键字； D. select关键字的用法与switch语句非常类似，后面要带判断条件；  参考答案及解析：ABC。参考文章《Go 并发 \u0026ndash; Select》\n\n2.下面的代码有什么问题？\nfunc Stop(stop \u0026lt;-chan bool) { close(stop) }  参考答案及解析：有方向的 channel 不可以被关闭。\n\n3.下面这段代码存在什么问题？\ntype Param map[string]interface{} type Show struct { *Param } func main() { s := new(Show) s.Param[\u0026quot;day\u0026quot;] = 2 }  参考答案及解析：存在两个问题：1.map 需要初始化才能使用；2.指针不支持索引。修复代码如下：\nfunc main() { s := new(Show) // 修复代码 p := make(Param) p[\u0026quot;day\u0026quot;] = 2 s.Param = \u0026amp;p tmp := *s.Param fmt.Println(tmp[\u0026quot;day\u0026quot;]) }  \nDay 41. 切片初始化，指针 1.下面代码编译能通过吗？\nfunc main() { fmt.Println(\u0026quot;hello world\u0026quot;) }  参考答案及解析：编译错误。\nsyntax error: unexpected semicolon or newline before {  Go 语言中，大括号不能放在单独的一行。\n正确的代码如下：\nfunc main() { fmt.Println(\u0026quot;works\u0026quot;) }  引自：http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/\n2.下面这段代码输出什么？\nvar x = []int{2: 2, 3, 0: 1} func main() { fmt.Println(x) }  参考答案及解析：输出[1 0 2 3]，字面量初始化切片时候，可以指定索引，没有指定索引的元素会在前一个索引基础之上加一，所以输出[1 0 2 3]，而不是[1 3 2]。\n3.下面这段代码输出什么？\nfunc incr(p *int) int { *p++ return *p } func main() { v := 1 incr(\u0026amp;v) fmt.Println(v) }  参考答案及解析：2。知识点：指针。p 是指针变量，指向变量 v，*p++操作的意思是取出变量 v 的值并执行加一操作，所以 v 的最终值是 2。\n关于指针的使用可以参考文章《800 字彻底理解 Go 指针》。\n\nDay 42. 未使用变量, for range ,string 1.请指出下面代码的错误？\npackage main var gvar int func main() { var one int two := 2 var three int three = 3 func(unused string) { fmt.Println(\u0026quot;Unused arg. No compile error\u0026quot;) }(\u0026quot;what?\u0026quot;) }  参考答案及解析：变量 one、two 和 three 声明未使用。知识点：未使用变量。如果有未使用的变量代码将编译失败。但也有例外，函数中声明的变量必须要使用，但可以有未使用的全局变量。函数的参数未使用也是可以的。\n如果你给未使用的变量分配了一个新值，代码也还是会编译失败。你需要在某个地方使用这个变量，才能让编译器愉快的编译。\n修复代码：\nfunc main() { var one int _ = one two := 2 fmt.Println(two) var three int three = 3 one = three var four int four = four }  另一个选择是注释掉或者移除未使用的变量 。\n引自：http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/\n2.下面代码输出什么？\ntype ConfigOne struct { Daemon string } func (c *ConfigOne) String() string { return fmt.Sprintf(\u0026quot;print: %v\u0026quot;, c) } func main() { c := \u0026amp;ConfigOne{} c.String() }  参考答案及解析：运行时错误。如果类型实现 String() 方法，当格式化输出时会自动使用 String() 方法。上面这段代码是在该类型的 String() 方法内使用格式化输出，导致递归调用，最后抛错。\nruntime: goroutine stack exceeds 1000000000-byte limit fatal error: stack overflow  3.下面代码输出什么？\nfunc main() { var a = []int{1, 2, 3, 4, 5} var r = make([]int, 0) for i, v := range a { if i == 0 { a = append(a, 6, 7) } r = append(r, v) } fmt.Println(r) }  参考答案及解析：[1 2 3 4 5]。a 在 for range 过程中增加了两个元素 ，len 由 5 增加到 7，但 for range 时会使用 a 的副本 a\u0026rsquo; 参与循环，副本的 len 依旧是 5，因此 for range 只会循环 5 次，也就只获取 a 对应的底层数组的前 5 个元素。\n\nDay 43. map 赋值, 未使用包, 类型断言 1.下面的代码有什么问题？\nimport ( \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;time\u0026quot; ) func main() { }  参考答案及解析：导入的包没有被使用。如果引入一个包，但是未使用其中如何函数、接口、结构体或变量的话，代码将编译失败。\n如果你真的需要引入包，可以使用下划线操作符，_，来作为这个包的名字，从而避免失败。下划线操作符用于引入，但不使用。\n我们还可以注释或者移除未使用的包。\n修复代码：\nimport ( _ \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;time\u0026quot; ) var _ = log.Println func main() { _ = time.Now }  引自：http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/\n2.下面代码输出什么？\nfunc main() { x := interface{}(nil) y := (*int)(nil) a := y == x b := y == nil _, c := x.(interface{}) println(a, b, c) }   A. true true true B. false true true C. true true true D. false true false  参考答案及解析：D。知识点：类型断言。类型断言语法：i.(Type)，其中 i 是接口，Type 是类型或接口。编译时会自动检测 i 的动态类型与 Type 是否一致。但是，如果动态类型不存在，则断言总是失败。参考文章《Go 语言接口详解（二）》\n3.下面代码有几处错误的地方？请说明原因。\nfunc main() { var s []int s = append(s,1) var m map[string]int m[\u0026quot;one\u0026quot;] = 1 }  参考答案及解析：有 1 出错误，不能对 nil 的 map 直接赋值，需要使用 make() 初始化。但可以使用 append() 函数对为 nil 的 slice 增加元素。\n修复代码：\nfunc main() { var m map[string]int m = make(map[string]int) m[\u0026quot;one\u0026quot;] = 1 }  \nDay 44. map, nil, := 1.下面代码有什么问题？\nfunc main() { m := make(map[string]int,2) cap(m) }  参考答案及解析：问题：使用 cap() 获取 map 的容量。1.使用 make 创建 map 变量时可以指定第二个参数，不过会被忽略。2.cap() 函数适用于数组、数组指针、slice 和 channel，不适用于 map，可以使用 len() 返回 map 的元素个数。\n引自：http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html\n2.下面的代码有什么问题？\nfunc main() { var x = nil _ = x }  参考答案及解析：nil 用于表示 interface、函数、maps、slices 和 channels 的“零值”。如果不指定变量的类型，编译器猜不出变量的具体类型，导致编译错误。\n修复代码：\nfunc main() { var x interface{} = nil _ = x }  3.下面代码能编译通过吗？\ntype info struct { result int } func work() (int,error) { return 13,nil } func main() { var data info data.result, err := work() fmt.Printf(\u0026quot;info: %+v\\n\u0026quot;,data) }  参考答案及解析：编译失败。\nnon-name data.result on left side of :=  不能使用短变量声明设置结构体字段值，修复代码：\nfunc main() { var data info var err error data.result, err = work() //ok if err != nil { fmt.Println(err) return } fmt.Println(data) }  引自：http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html\n\nDay 45. :=, 类型别名 1.下面代码有什么错误？\nfunc main() { one := 0 one := 1 }  参考答案及解析：变量重复声明。不能在单独的声明中重复声明一个变量，但在多变量声明的时候是可以的，但必须保证至少有一个变量是新声明的。\n修复代码：\nfunc main() { one := 0 one, two := 1,2 one,two = two,one }  引自：http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/\n2.下面代码有什么问题？\nfunc main() { x := []int{ 1, 2 } _ = x }  参考答案及解析：编译错误，第四行代码没有逗号。用字面量初始化数组、slice 和 map 时，最好是在每个元素后面加上逗号，即使是声明在一行或者多行都不会出错。\n修复代码：\nfunc main() { x := []int{ // 多行 1, 2, } x = x y := []int{3,4,} // 一行 no error y = y }  引自：http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html\n3.下面代码输出什么？\nfunc test(x byte) { fmt.Println(x) } func main() { var a byte = 0x11 var b uint8 = a var c uint8 = a + b test(c) }  参考答案及解析：34。与 rune 是 int32 的别名一样，byte 是 uint8 的别名，别名类型无序转换，可直接转换。\n\nDay 46. 常量 1.下面的代码有什么问题？\nfunc main() { const x = 123 const y = 1.23 fmt.Println(x) }  参考答案及解析：编译可以通过。知识点：常量。常量是一个简单值的标识符，在程序运行时，不会被修改的量。不像变量，常量未使用是能编译通过的。\n2.下面代码输出什么？\nconst ( x uint16 = 120 y s = \u0026quot;abc\u0026quot; z ) func main() { fmt.Printf(\u0026quot;%T %v\\n\u0026quot;, y, y) fmt.Printf(\u0026quot;%T %v\\n\u0026quot;, z, z) }  参考答案及解析：知识点：常量。\n输出：\nuint16 120 string abc  常量组中如不指定类型和初始化值，则与上一行非空常量右值相同\n3.下面代码有什么问题？\nfunc main() { var x string = nil if x == nil { x = \u0026quot;default\u0026quot; } }  参考答案及解析：将 nil 分配给 string 类型的变量。这是个大多数新手会犯的错误。修复代码：\nfunc main() { var x string //defaults to \u0026quot;\u0026quot; (zero value) if x == \u0026quot;\u0026quot; { x = \u0026quot;default\u0026quot; } }  引自：http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html\n\nDay 47. 自增、自减 1.下面的代码有什么问题？\nfunc main() { data := []int{1,2,3} i := 0 ++i fmt.Println(data[i++]) }  参考答案及解析：对于自增、自减，需要注意：\n 自增、自减不在是运算符，只能作为独立语句，而不是表达式； 不像其他语言，Go 语言中不支持 ++i 和 \u0026ndash;i 操作；  表达式通常是求值代码，可作为右值或参数使用。而语句表示完成一个任务，比如 if、for 语句等。表达式可作为语句使用，但语句不能当做表达式。\n修复代码：\nfunc main() { data := []int{1,2,3} i := 0 i++ fmt.Println(data[i]) }  2.下面代码最后一行输出什么？请说明原因。\nfunc main() { x := 1 fmt.Println(x) { fmt.Println(x) i,x := 2,2 fmt.Println(i,x) } fmt.Println(x) // print ? }  参考答案及解析：输出1。知识点：变量隐藏。使用变量简短声明符号 := 时，如果符号左边有多个变量，只需要保证至少有一个变量是新声明的，并对已定义的变量尽进行赋值操作。但如果出现作用域之后，就会导致变量隐藏的问题，就像这个例子一样。\n这个坑很容易挖，但又很难发现。即使对于经验丰富的 Go 开发者而言，这也是一个非常常见的陷阱。\n引自：http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/\n\nDay 48. ~ , ^, \u0026amp; 1.下面代码有什么问题？\ntype foo struct { bar int } func main() { var f foo f.bar, tmp := 1, 2 }  参考答案及解析：编译错误：\nnon-name f.bar on left side of :=  := 操作符不能用于结构体字段赋值。\n2.下面的代码输出什么？\nfunc main() { fmt.Println(~2) }  参考答案及解析：编译错误。\ninvalid character U+007E '~'  很多语言都是采用 ~ 作为按位取反运算符，Go 里面采用的是 ^ 。按位取反之后返回一个每个 bit 位都取反的数，对于有符号的整数来说，是按照补码进行取反操作的（快速计算方法：对数 a 取反，结果为 -(a+1) ），对于无符号整数来说就是按位取反。例如：\nfunc main() { var a int8 = 3 var b uint8 = 3 var c int8 = -3 fmt.Printf(\u0026quot;^%b=%b %d\\n\u0026quot;, a, ^a, ^a) // ^11=-100 -4 fmt.Printf(\u0026quot;^%b=%b %d\\n\u0026quot;, b, ^b, ^b) // ^11=11111100 252 fmt.Printf(\u0026quot;^%b=%b %d\\n\u0026quot;, c, ^c, ^c) // ^-11=10 2 }  另外需要注意的是，如果作为二元运算符，^ 表示按位异或，即：对应位相同为 0，相异为 1。例如：\nfunc main() { var a int8 = 3 var c int8 = 5 fmt.Printf(\u0026quot;a: %08b\\n\u0026quot;,a) fmt.Printf(\u0026quot;c: %08b\\n\u0026quot;,c) fmt.Printf(\u0026quot;a^c: %08b\\n\u0026quot;,a ^ c) }  给大家重点介绍下这个操作符 \u0026amp;^，按位置零，例如：z = x \u0026amp;^ y，表示如果 y 中的 bit 位为 1，则 z 对应 bit 位为 0，否则 z 对应 bit 位等于 x 中相应的 bit 位的值。\n不知道大家发现没有，我们还可以这样理解或操作符 | ，表达式 z = x | y，如果 y 中的 bit 位为 1，则 z 对应 bit 位为 1，否则 z 对应 bit 位等于 x 中相应的 bit 位的值，与 \u0026amp;^ 完全相反。\nvar x uint8 = 214 var y uint8 = 92 fmt.Printf(\u0026quot;x: %08b\\n\u0026quot;,x) fmt.Printf(\u0026quot;y: %08b\\n\u0026quot;,y) fmt.Printf(\u0026quot;x | y: %08b\\n\u0026quot;,x | y) fmt.Printf(\u0026quot;x \u0026amp;^ y: %08b\\n\u0026quot;,x \u0026amp;^ y)  输出：\nx: 11010110 y: 01011100 x | y: 11011110 x \u0026amp;^ y: 10000010  \nDay 49. 结构体访问控制,channel 1.下面代码输出什么？\nfunc main() { var ch chan int select { case v, ok := \u0026lt;-ch: println(v, ok) default: println(\u0026quot;default\u0026quot;) } }  参考答案及解析：default。ch 为 nil，读写都会阻塞。\n2.下面这段代码输出什么？\ntype People struct { name string `json:\u0026quot;name\u0026quot;` } func main() { js := `{ \u0026quot;name\u0026quot;:\u0026quot;seekload\u0026quot; }` var p People err := json.Unmarshal([]byte(js), \u0026amp;p) if err != nil { fmt.Println(\u0026quot;err: \u0026quot;, err) return } fmt.Println(p) }  参考答案及解析：输出 {}。知识点：结构体访问控制，因为 name 首字母是小写，导致其他包不能访问，所以输出为空结构体。修复代码：\ntype People struct { Name string `json:\u0026quot;name\u0026quot;` }  \nDay 50. switch 1.下面这段代码输出什么？\ntype T struct { ls []int } func foo(t T) { t.ls[0] = 100 } func main() { var t = T{ ls: []int{1, 2, 3}, } foo(t) fmt.Println(t.ls[0]) }   A. 1 B. 100 C. compilation error  参考答案及解析：B。调用 foo() 函数时虽然是传值，但 foo() 函数中，字段 ls 依旧可以看成是指向底层数组的指针。\n2.下面代码输出什么？\nfunc main() { isMatch := func(i int) bool { switch(i) { case 1: case 2: return true } return false } fmt.Println(isMatch(1)) fmt.Println(isMatch(2)) }  参考答案及解析：false true。Go 语言的 switch 语句虽然没有\u0026rdquo;break\u0026rdquo;，但如果 case 完成程序会默认 break，可以在 case 语句后面加上关键字 fallthrough，这样就会接着走下一个 case 语句（不用匹配后续条件表达式）。或者，利用 case 可以匹配多个值的特性。\n修复代码：\nfunc main() { isMatch := func(i int) bool { switch(i) { case 1: fallthrough case 2: return true } return false } fmt.Println(isMatch(1)) // true fmt.Println(isMatch(2)) // true match := func(i int) bool { switch(i) { case 1,2: return true } return false } fmt.Println(match(1)) // true fmt.Println(match(2)) // true }  \nDay 51. 比较，struct 1.下面的代码能否正确输出？\nfunc main() { var fn1 = func() {} var fn2 = func() {} if fn1 != fn2 { println(\u0026quot;fn1 not equal fn2\u0026quot;) } }  参考答案及解析：编译错误\ninvalid operation: fn1 != fn2 (func can only be compared to nil)  函数只能与 nil 比较。\n2.下面代码输出什么？\ntype T struct { n int } func main() { m := make(map[int]T) m[0].n = 1 fmt.Println(m[0].n) }   A. 1 B. compilation error  参考答案及解析：B。编译错误：\ncannot assign to struct field m[0].n in map  map[key]struct 中 struct 是不可寻址的，所以无法直接赋值。\n修复代码：\ntype T struct { n int } func main() { m := make(map[int]T) t := T{1} m[0] = t fmt.Println(m[0].n) }  \nDay 52. struct寻址, map 1.下面的代码有什么问题？\ntype X struct {} func (x *X) test() { println(x) } func main() { var a *X a.test() X{}.test() }  参考答案及解析：X{} 是不可寻址的，不能直接调用方法。知识点：在方法中，指针类型的接收者必须是合法指针（包括 nil）,或能获取实例地址。\n修复代码：\nfunc main() { var a *X a.test() // 相当于 test(nil) var x = X{} x.test() }  引自：《Go语言学习笔记》· 方法\n2.下面代码有什么不规范的地方吗？\nfunc main() { x := map[string]string{\u0026quot;one\u0026quot;:\u0026quot;a\u0026quot;,\u0026quot;two\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;three\u0026quot;:\u0026quot;c\u0026quot;} if v := x[\u0026quot;two\u0026quot;]; v == \u0026quot;\u0026quot; { fmt.Println(\u0026quot;no entry\u0026quot;) } }  参考答案及解析：检查 map 是否含有某一元素，直接判断元素的值并不是一种合适的方式。最可靠的操作是使用访问 map 时返回的第二个值。\n修复代码如下：\nfunc main() { x := map[string]string{\u0026quot;one\u0026quot;:\u0026quot;a\u0026quot;,\u0026quot;two\u0026quot;:\u0026quot;\u0026quot;,\u0026quot;three\u0026quot;:\u0026quot;c\u0026quot;} if _,ok := x[\u0026quot;two\u0026quot;]; !ok { fmt.Println(\u0026quot;no entry\u0026quot;) } }  引自：http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html\n\nDay 53. channel, struct 寻址， 1.关于 channel 下面描述正确的是？\n A. 向已关闭的通道发送数据会引发 panic； B. 从已关闭的缓冲通道接收数据，返回已缓冲数据或者零值； C. 无论接收还是接收，nil 通道都会阻塞；  参考答案及解析：ABC。\n2.下面的代码有几处问题？请详细说明。\ntype T struct { n int } func (t *T) Set(n int) { t.n = n } func getT() T { return T{} } func main() { getT().Set(1) }  参考答案及解析：有两处问题：\n 1.直接返回的 T{} 不可寻址； 2.不可寻址的结构体不能调用带结构体指针接收者的方法；  修复代码：\ntype T struct { n int } func (t *T) Set(n int) { t.n = n } func getT() T { return T{} } func main() { t := getT() t.Set(2) fmt.Println(t.n) }  \nDay 54. 指针，方法表达式 1.下面的代码有什么问题？\nfunc (n N) value(){ n++ fmt.Printf(\u0026quot;v:%p,%v\\n\u0026quot;,\u0026amp;n,n) } func (n *N) pointer(){ *n++ fmt.Printf(\u0026quot;v:%p,%v\\n\u0026quot;,n,*n) } func main() { var a N = 25 p := \u0026amp;a p1 := \u0026amp;p p1.value() p1.pointer() }  参考答案及解析：编译错误：\ncalling method value with receiver p1 (type **N) requires explicit dereference calling method pointer with receiver p1 (type **N) requires explicit dereference  不能使用多级指针调用方法。\n2.下面的代码输出什么？\ntype N int func (n N) test(){ fmt.Println(n) } func main() { var n N = 10 fmt.Println(n) n++ f1 := N.test f1(n) n++ f2 := (*N).test f2(\u0026amp;n) }  参考答案及解析：10 11 12。知识点：方法表达式。通过类型引用的方法表达式会被还原成普通函数样式，接收者是第一个参数，调用时显示传参。类型可以是 T 或 *T，只要目标方法存在于该类型的方法集中就可以。\n还可以直接使用方法表达式调用：\nfunc main() { var n N = 10 fmt.Println(n) n++ N.test(n) n++ (*N).test(\u0026amp;n) }  \nDay 55. channel, struct 1.关于 channel 下面描述正确的是？\n A. close() 可以用于只接收通道； B. 单向通道可以转换为双向通道； C. 不能在单向通道上做逆向操作（例如：只发送通道用于接收）；  参考答案及解析：C。\n2.下面的代码有什么问题？\ntype T struct { n int } func getT() T { return T{} } func main() { getT().n = 1 }  参考答案及解析：编译错误：\ncannot assign to getT().n  直接返回的 T{} 无法寻址，不可直接赋值。\n修复代码：\ntype T struct { n int } func getT() T { return T{} } func main() { t := getT() p := \u0026amp;t.n // \u0026lt;=\u0026gt; p = \u0026amp;(t.n) *p = 1 fmt.Println(t.n) }  \nDay 56. 切片，方法值 1.下面的代码有什么问题？\npackage main import \u0026quot;fmt\u0026quot; func main() { s := make([]int, 3, 9) fmt.Println(len(s)) s2 := s[4:8] fmt.Println(len(s2)) }  参考答案及解析：代码没问题，输出 3 4。从一个基础切片派生出的子切片的长度可能大于基础切片的长度。假设基础切片是 baseSlice，使用操作符 [low,high]，有如下规则：0 \u0026lt;= low \u0026lt;= high \u0026lt;= cap(baseSlice)，只要上述满足这个关系，下标 low 和 high 都可以大于 len(baseSlice)。\n2.下面代码输出什么？\ntype N int func (n N) test(){ fmt.Println(n) } func main() { var n N = 10 p := \u0026amp;n n++ f1 := n.test n++ f2 := p.test n++ fmt.Println(n) f1() f2() }  参考答案及解析：13 11 12。知识点：方法值。当指针值赋值给变量或者作为函数参数传递时，会立即计算并复制该方法执行所需的接收者对象，与其绑定，以便在稍后执行时，能隐式第传入接收者参数。\n\nDay 57. panic,select 1.下面哪一行代码会 panic，请说明原因？\npackage main func main() { var x interface{} var y interface{} = []int{3, 5} _ = x == x _ = x == y _ = y == y }  参考答案及解析：第 8 行。因为两个比较值的动态类型为同一个不可比较类型。\n2.下面的代码输出什么？\nvar o = fmt.Print func main() { c := make(chan int, 1) for range [3]struct{}{} { select { default: o(1) case \u0026lt;-c: o(2) c = nil case c \u0026lt;- 1: o(3) } } }  参考答案及解析：321。第一次循环，写操作已经准备好，执行 o(3)，输出 3；第二次，读操作准备好，执行 o(2)，输出 2 并将 c 赋值为 nil；第三次，由于 c 为 nil，走的是 default 分支，输出 1。\n\nDay 58. 运算符优先级, panic 1.下面的代码输出什么？\ntype T struct { x int y *int } func main() { i := 20 t := T{10,\u0026amp;i} p := \u0026amp;t.x *p++ *p-- t.y = p fmt.Println(*t.y) }  参考答案及解析：10。知识点：运算符优先级。如下规则：递增运算符 ++ 和递减运算符 \u0026ndash; 的优先级低于解引用运算符 * 和取址运算符 \u0026amp;，解引用运算符和取址运算符的优先级低于选择器 . 中的属性选择操作符。\n2.下面哪一行代码会 panic，请说明原因？\npackage main func main() { x := make([]int, 2, 10) _ = x[6:10] _ = x[6:] _ = x[2:] }  参考答案：第 6 行，截取符号 [i:j]，如果 j 省略，默认是原切片或者数组的长度，x 的长度是 2，小于起始下标 6 ，所以 panic。\n\nDay 59. panic, 方法值 1.下面的代码输出什么？\ntype N int func (n *N) test(){ fmt.Println(*n) } func main() { var n N = 10 p := \u0026amp;n n++ f1 := n.test n++ f2 := p.test n++ fmt.Println(n) f1() f2() }  参考答案及解析：13 13 13。知识点：方法值。当目标方法的接收者是指针类型时，那么被复制的就是指针。\n引自：《Go语言学习笔记》· 方法\n2.下面哪一行代码会 panic，请说明原因？\npackage main func main() { var m map[int]bool // nil _ = m[123] var p *[5]string // nil for range p { _ = len(p) } var s []int // nil _ = s[:] s, s[0] = []int{1, 2}, 9 }  参考答案及解析：第 12 行。因为左侧的 s[0] 中的 s 为 nil。\n\nDay 60. panic,mutex 1.下面哪一行代码会 panic，请说明原因？\npackage main type T struct{} func (*T) foo() { } func (T) bar() { } type S struct { *T } func main() { s := S{} _ = s.foo s.foo() _ = s.bar 20}  参考答案及解析：第 19 行，因为 s.bar 将被展开为 (*s.T).bar，而 s.T 是个空指针，解引用会 panic。\n可以使用下面代码输出 s：\nfunc main() { s := S{} fmt.Printf(\u0026quot;%#v\u0026quot;,s) // 输出：main.S{T:(*main.T)(nil)} }  引自：《Go语言101》\n2.下面的代码有什么问题？\ntype data struct { sync.Mutex } func (d data) test(s string) { d.Lock() defer d.Unlock() for i:=0;i\u0026lt;5 ;i++ { fmt.Println(s,i) time.Sleep(time.Second) } } func main() { var wg sync.WaitGroup wg.Add(2) var d data go func() { defer wg.Done() d.test(\u0026quot;read\u0026quot;) }() go func() { defer wg.Done() d.test(\u0026quot;write\u0026quot;) }() wg.Wait() }  参考答案及解析：锁失效。将 Mutex 作为匿名字段时，相关的方法必须使用指针接收者，否则会导致锁机制失效。\n修复代码：\nfunc (d *data) test(s string) { // 指针接收者 d.Lock() defer d.Unlock() for i:=0;i\u0026lt;5 ;i++ { fmt.Println(s,i) time.Sleep(time.Second) } }  或者可以通过嵌入 *Mutex 来避免复制的问题，但需要初始化。\ntype data struct { *sync.Mutex // *Mutex } func (d data) test(s string) { // 值方法 d.Lock() defer d.Unlock() for i := 0; i \u0026lt; 5; i++ { fmt.Println(s, i) time.Sleep(time.Second) } } func main() { var wg sync.WaitGroup wg.Add(2) d := data{new(sync.Mutex)} // 初始化 go func() { defer wg.Done() d.test(\u0026quot;read\u0026quot;) }() go func() { defer wg.Done() d.test(\u0026quot;write\u0026quot;) }() wg.Wait() }  引自：《Go 语言学习笔记》· 同步\n","date":1595858876,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595858876,"objectID":"cd8a5ab9eef850e0b4bc0de4aa652e75","permalink":"/go/interview/31-60/","publishdate":"2020-07-27T22:07:56+08:00","relpermalink":"/go/interview/31-60/","section":"go","summary":"Go语言面试题","tags":["Go"],"title":"Go语言中文网面试题 31-60","type":"go"},{"authors":[],"categories":["Dynamic Programming"],"content":" 1. longest common substring  求最长公共子串的长度\n input:\ts1=\u0026quot;abdca\u0026quot;, s2=\u0026quot;cbda\u0026quot; ouput:\t2 explanation: \u0026quot;bd\u0026quot;  input:\ts1=\u0026quot;passport\u0026quot;, s2=\u0026quot;ppsspt\u0026quot; ouput:\t3 explanation: \u0026quot;ssp\u0026quot;  brute-force int LCSRecursive(string \u0026amp;s1, string \u0026amp;s2, int s1CurrentIndex, int s2CurrentIndex, int count) { if (s1CurrentIndex \u0026gt;= s1.length() || s2CurrentIndex \u0026gt;= s2.length()) { return count; } if (s1[s1CurrentIndex] == s2[s2CurrentIndex]) { count = LCSRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex + 1, count+1); } //count清零 int c1 = LCSRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex, 0); int c2 = LCSRecursive(s1, s2, s1CurrentIndex, s2CurrentIndex + 1, 0); return max(count, max(c1, c2)); } int LCS(string s1, string s2) { return LCSRecursive(s1, s2, 0, 0, 0); }  Time Complexity : O(3^(M+N) )\nSpace Complexity : O(N+M)\nint LCS2(string s1, string s2) { int len1 = s1.length(); int len2 = s2.length(); int maxlen = 0; for (int i = 0; i \u0026lt; len1; i++) { for (int j = 0; j \u0026lt; len2; j++) { int len = 0; while (i + len \u0026lt; len1 \u0026amp;\u0026amp; j + len \u0026lt; len2 \u0026amp;\u0026amp; s1[i + len] == s2[j + len]) { len++;//暴力匹配 } if (len \u0026gt; maxlen) { maxlen = len; } } } return maxlen; }  bottom-up int LCSLength(string s1, string s2) { int len1 = s1.length(); int len2 = s2.length(); int maxLength = 0; //使用 d[i][j] 表示以 X[0,i-1]长度为i 与Y[0,j-1] 长度为j 最长公共子串的长度 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(len1 + 1, vector\u0026lt;int\u0026gt;(len2 + 1)); for (int i = 0; i \u0026lt;= len1; i++) { //可不要 dp[0][i] = 0; dp[i][0] = 0; } for (int i = 1; i \u0026lt;= len1; i++) { for (int j = 1; j \u0026lt;= len2; j++) { if (s1[i - 1] == s2[j - 1]) { dp[i][j] = 1 + dp[i - 1][j - 1]; maxLength = max(maxLength, dp[i][j]); } } } return maxLength; }  Time Complexity : O(M * N)\nSpace Complexity : O(N * M)\n2. longest common subsequence  求最长公共子序列\n input:\ts1=\u0026quot;abdca\u0026quot;, s2=\u0026quot;cbda\u0026quot; ouput:\t3 explanation: \u0026quot;bda\u0026quot;  input:\ts1=\u0026quot;passport\u0026quot;, s2=\u0026quot;ppsspt\u0026quot; ouput:\t3 explanation: \u0026quot;ssp\u0026quot;  brute-force int LCSRecursive(string \u0026amp;s1, string \u0026amp;s2, int s1CurrentIndex, int s2CurrentIndex) { if (s1CurrentIndex \u0026gt;= s1.length() || s2CurrentIndex \u0026gt;= s2.length()) { return 0; } if (s1[s1CurrentIndex] == s2[s2CurrentIndex]) { return 1 + LCSRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex + 1); } //count清零 int c1 = LCSRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex); int c2 = LCSRecursive(s1, s2, s1CurrentIndex, s2CurrentIndex + 1); return max(c1, c2); }  Time Complexity : O(2^(M+N) )\nSpace Complexity : O(N+M)\ntop-down int LCS(string s1, string s2) { return LCSRecursive(s1, s2, 0, 0); } int LCSRecursive2(string \u0026amp;s1, string \u0026amp;s2, int s1CurrentIndex, int s2CurrentIndex, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;dp) { if (s1CurrentIndex \u0026gt;= s1.length() || s2CurrentIndex \u0026gt;= s2.length()) { return 0; } if (dp[s1CurrentIndex][s2CurrentIndex] == -1) { if (s1[s1CurrentIndex] == s2[s2CurrentIndex]) { dp[s1CurrentIndex][s2CurrentIndex] = 1 + LCSRecursive2(s1, s2, s1CurrentIndex + 1, s2CurrentIndex + 1, dp); } else { int c1 = LCSRecursive2(s1, s2, s1CurrentIndex + 1, s2CurrentIndex, dp); int c2 = LCSRecursive2(s1, s2, s1CurrentIndex, s2CurrentIndex + 1, dp); dp[s1CurrentIndex][s2CurrentIndex] = max(c1, c2); } } return dp[s1CurrentIndex][s2CurrentIndex]; } int LCS2(string s1, string s2) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(s1.length(), vector\u0026lt;int\u0026gt;(s2.length(), -1)); return LCSRecursive2(s1, s2, 0, 0, dp); }  Time Complexity : O(M * N)\nSpace Complexity : O(N * M)\nbottom-up int LCS3(string s1, string s2) { int len1 = s1.length(); int len2 = s2.length(); int maxLength = 0; //使用 d[i][j] 表示以 X[0,i-1]长度为i 与Y[0,j-1] 长度为j 最长公共子序列的长度 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(len1 + 1, vector\u0026lt;int\u0026gt;(len2 + 1)); for (int i = 0; i \u0026lt;= len1; i++) { //可不要 dp[0][i] = 0; dp[i][0] = 0; } for (int i = 1; i \u0026lt;= len1; i++) { for (int j = 1; j \u0026lt;= len2; j++) { if (s1[i - 1] == s2[j - 1]) { dp[i][j] = 1 + dp[i - 1][j - 1]; } else { dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } maxLength = max(maxLength, dp[i][j]); } } return maxLength; }  Time Complexity : O(M * N)\nSpace Complexity : O(N * M)\n3. minimum deletions or insertions to transform a string into another  给定字符串S1,S2,通过删除插入字符使得S1变成S2，求最小的删除插入数\n input:\ts1=\u0026quot;abc\u0026quot;,s2=\u0026quot;fbc\u0026quot; output:\t1 deletions ,1 insertions explanation: s1:delete(a),insert(f) -\u0026gt;s2  input:\ts1=\u0026quot;abdca\u0026quot;,s2=\u0026quot;cbda\u0026quot; output:\t2 deletions ,1 insertions explanation: s1:delete(a,c),insert(c) -\u0026gt;s2  bottom-up int LCS3(string s1, string s2) { int len1 = s1.length(); int len2 = s2.length(); int maxLength = 0; //使用 d[i][j] 表示以 X[0,i-1]长度为i 与Y[0,j-1] 长度为j 最长公共子序列的长度 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(len1 + 1, vector\u0026lt;int\u0026gt;(len2 + 1)); for (int i = 0; i \u0026lt;= len1; i++) { //可不要 dp[0][i] = 0; dp[i][0] = 0; } for (int i = 1; i \u0026lt;= len1; i++) { for (int j = 1; j \u0026lt;= len2; j++) { if (s1[i - 1] == s2[j - 1]) { dp[i][j] = 1 + dp[i - 1][j - 1]; } else { dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } maxLength = max(maxLength, dp[i][j]); } } return maxLength; } pair\u0026lt;int, int\u0026gt; minDeleteInsert(string s1, string s2) { int len1 = s1.length(); int len2 = s2.length(); int c = LCS3(s1, s2); return make_pair(len1 - c, len2 - c); }  Time Complexity : O(M * N)\nSpace Complexity : O(N * M)\n4. longest increasing subsequence  求最长递增子序列的长度\n input:\t[4, 2, 3, 6, 10, 1, 12] output:\t5 explanation:[2, 3, 6, 10, 12]  input:\t[-4, 10, 3, 7, 15] output:\t4 explanation:[-4, 3, 7, 15]  brute-force int LISLengthRecursive(vector\u0026lt;int\u0026gt; \u0026amp;nums, int currentIndex, int previousIndex) { if (currentIndex \u0026gt;= nums.size()) { return 0; } int c1 = 0; //大于先前元素，包含在内 if (previousIndex == -1 || nums[currentIndex] \u0026gt; nums[previousIndex]) { c1 = 1 + LISLengthRecursive(nums, currentIndex + 1, currentIndex); } //不包含 int c2 = LISLengthRecursive(nums, currentIndex + 1, previousIndex); return max(c1, c2); } int LIS(vector\u0026lt;int\u0026gt; nums) { return LISLengthRecursive(nums, 0, -1); }  Time Complexity : O(2^N )\nSpace Complexity : O(N)\ntop-down int LISLengthRecursive2(vector\u0026lt;int\u0026gt; \u0026amp;nums, int currentIndex, int previousIndex, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;dp) { if (currentIndex \u0026gt;= nums.size()) { return 0; } //previousIndex的取值范围为[-1,n-1]转变为[0,n] if (dp[currentIndex][previousIndex + 1] == -1) { int c1 = 0; //大于先前元素，包含在内 if (previousIndex == -1 || nums[currentIndex] \u0026gt; nums[previousIndex]) { c1 = 1 + LISLengthRecursive2(nums, currentIndex + 1, currentIndex, dp); } //不包含 int c2 = LISLengthRecursive2(nums, currentIndex + 1, previousIndex, dp); dp[currentIndex][previousIndex + 1] = max(c1, c2); } return dp[currentIndex][previousIndex + 1]; } int LIS2(vector\u0026lt;int\u0026gt; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(nums.size(), vector\u0026lt;int\u0026gt;(nums.size() + 1, -1)); return LISLengthRecursive2(nums, 0, -1, dp); }  Time Complexity : O(N^2 )\nSpace Complexity : O(N^2)\nbottom-up int LIS3(vector\u0026lt;int\u0026gt; nums) { vector\u0026lt;int\u0026gt; dp(nums.size()); dp[0] = 1; int maxLength = 1; for (int i = 0; i \u0026lt; nums.size(); i++) { dp[i] = 1; for (int j = 0; j \u0026lt; i; j++) { if (nums[i] \u0026gt; nums[j] \u0026amp;\u0026amp; dp[i] \u0026lt;= dp[j]) { dp[i] = dp[j] + 1; maxLength = max(maxLength, dp[i]); } } } return maxLength; }  Time Complexity : O(N^2 )\nSpace Complexity : O(N)\n5. max sum increasing subsequence  求 和最大的递增子序列\n不同于题4\n input:\t[4, 1, 2, 6, 10, 1, 12] output:\t32 explanation:sum[4, 6, 10, 12]=32 LIS：sum[1,2,6,10,12]=31,两者和不同  input:\t[-4, 10, 3, 7, 15] output:\t25 explanation:sum[10, 15]=sum[3,7,5]=25  brute-force int maxSumISRecursive(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int currentIndex, int previousIndex, int sum) { if (currentIndex \u0026gt;= nums.size()) { return sum; } int s1 = sum; if (previousIndex == -1 || nums[currentIndex] \u0026gt; nums[previousIndex]) { s1 = maxSumISRecursive(nums, currentIndex + 1, currentIndex, sum + nums[currentIndex]); } int s2 = maxSumISRecursive(nums, currentIndex + 1, previousIndex, sum); return max(s1, s2); } int maxSumIS(const vector\u0026lt;int\u0026gt; \u0026amp;nums) { return maxSumISRecursive(nums, 0, -1, 0); }  Time Complexity : O(2^N )\nSpace Complexity : O(N)\ntop-down  三维表或哈希表\n bottom-up int maxSumIS2(const vector\u0026lt;int\u0026gt; \u0026amp;nums) { vector\u0026lt;int\u0026gt; dp(nums.size()); dp[0] = nums[0]; int maxSum = nums[0]; for (int i = 0; i \u0026lt; nums.size(); i++) { dp[i] = nums[i]; for (int j = 0; j \u0026lt; i; j++) { if (nums[i] \u0026gt; nums[j] \u0026amp;\u0026amp; dp[i] \u0026lt; nums[j] + dp[j]) { dp[i] = dp[j] + nums[i]; maxSum = max(maxSum, dp[i]); } } } return maxSum; }  Time Complexity : O(N^2 )\nSpace Complexity : O(N)\n6. shortest common super-sequence  给定字符串S1,S2,求最短的公共超级序列的长度，使得S1和S2都是其子序列\n input:\ts1=\u0026quot;abcf\u0026quot; ,s2=\u0026quot;bdcf\u0026quot; output:\t5 explanation: \u0026quot;abdcf\u0026quot;  input:\ts1=\u0026quot;dynamic\u0026quot;, s2=\u0026quot;programming\u0026quot; output: 15 explanation: \u0026quot;dynprogramming\u0026quot;  brute-force int SCSLengthRecursive(const string \u0026amp;s1, const string \u0026amp;s2, int s1CurrentIndex, int s2CurrentIndex) { if (s1CurrentIndex \u0026gt;= s1.length()) { return s2.length() - s2CurrentIndex; } if (s2CurrentIndex \u0026gt;= s2.length()) { return s1.length() - s1CurrentIndex; } if (s1[s1CurrentIndex] == s2[s2CurrentIndex]) { return 1 + SCSLengthRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex + 1); } int length1 = 1 + SCSLengthRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex); int length2 = 1 + SCSLengthRecursive(s1, s2, s1CurrentIndex, s2CurrentIndex + 1); return min(length1, length2); } int SCSLength(const string \u0026amp;s1, const string \u0026amp;s2) { return SCSLengthRecursive(s1, s2, 0, 0); }  Time Complexity : O(2^(M+N) )\nSpace Complexity : O(N+M)\ntop-down int SCSLengthRecursive2(const string \u0026amp;s1, const string \u0026amp;s2, int s1CurrentIndex, int s2CurrentIndex, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;dp) { if (s1CurrentIndex \u0026gt;= s1.length()) { return s2.length() - s2CurrentIndex; } if (s2CurrentIndex \u0026gt;= s2.length()) { return s1.length() - s1CurrentIndex; } if (dp[s1CurrentIndex][s2CurrentIndex] == -1) { if (s1[s1CurrentIndex] == s2[s2CurrentIndex]) { dp[s1CurrentIndex][s2CurrentIndex] = 1 + SCSLengthRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex + 1); } int length1 = 1 + SCSLengthRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex); int length2 = 1 + SCSLengthRecursive(s1, s2, s1CurrentIndex, s2CurrentIndex + 1); dp[s1CurrentIndex][s2CurrentIndex] = min(length1, length2); } return dp[s1CurrentIndex][s2CurrentIndex]; } int SCSLength2(const string \u0026amp;s1, const string \u0026amp;s2) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(s1.length(), vector\u0026lt;int\u0026gt;(s2.length(), -1)); return SCSLengthRecursive2(s1, s2, 0, 0, dp); }  Time Complexity : O(M * N)\nSpace Complexity : O(N * M)\nbottom-up int SCSLength3(const string \u0026amp;s1, const string \u0026amp;s2) { //长度 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(s1.length() + 1, vector\u0026lt;int\u0026gt;(s2.length() + 1)); for (int i = 0; i \u0026lt;= s1.length(); i++) { dp[i][0] = i; } for (int j = 1; j \u0026lt;= s2.length(); j++) { dp[0][j] = j; } for (int i = 1; i \u0026lt;= s1.length(); i++) { for (int j = 1; j \u0026lt;= s2.length(); j++) { //长度为i，索引为i-1 if (s1[i - 1] == s2[j - 1]) { dp[i][j] = 1 + dp[i - 1][j - 1]; } else { dp[i][j] = min(1 + dp[i - 1][j], 1 + dp[i][j - 1]); } } } return dp[s1.length()][s2.length()]; }  Time Complexity : O(M * N)\nSpace Complexity : O(N * M)\n7. minimum deletions to make a sequence sorted  给定数字序列，删除一些数，使得剩下的增序，求最小的删除数\n同题4\n input:\t[4, 2, 3, 6, 10, 1, 12] output: 2 explanation: delete [4,1]  input:\t[-4, 10, 3, 7, 15] output: 1 explanation: delete [10]  input:\t[3, 2, 1, 0] output: 3 explanation: 只剩下一个即可  brute-force int LIS(vector\u0026lt;int\u0026gt; nums) { vector\u0026lt;int\u0026gt; dp(nums.size()); dp[0] = 1; int maxLength = 1; for (int i = 0; i \u0026lt; nums.size(); i++) { dp[i] = 1; for (int j = 0; j \u0026lt; i; j++) { if (nums[i] \u0026gt; nums[j] \u0026amp;\u0026amp; dp[i] \u0026lt;= dp[j]) { dp[i] = dp[j] + 1; maxLength = max(maxLength, dp[i]); } } } return maxLength; } int minDelete(vector\u0026lt;int\u0026gt; \u0026amp;nums){ return nums.size() - LIS(nums); }  Time Complexity : O(N^2 )\nSpace Complexity : O(N)\n8. longest repeating subsequence  求最长重复子序列，此子序列出现超过两次，索引位置不重复\n input:\t\u0026quot;tomorrow\u0026quot; output:\t2 explanation: or,or  input:\t\u0026quot;aabdbcec\u0026quot; output:\t3 explanation: abc, abc  input: \u0026quot;fmff\u0026quot; output: 2 explanation: ff,ff,索引不重复  brute-force int LRSRecursive(const string \u0026amp;s, int i1, int i2) { if (i1 \u0026gt;= s.length() || i2 \u0026gt;= s.length()) { return 0; } if (i1 != i2 \u0026amp;\u0026amp; s[i1] == s[i2]) { return 1 + LRSRecursive(s, i1 + 1, i2 + 1); } int c1 = LRSRecursive(s, i1 + 1, i2); int c2 = LRSRecursive(s, i1, i2 + 1); return max(c1, c2); } int LRSLength(const string \u0026amp;s) { return LRSRecursive(s, 0, 0); }  Time Complexity : O(2^N )\nSpace Complexity : O(N)\ntop-down int LRSRecursive2(const string \u0026amp;s, int i1, int i2, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;dp) { if (i1 \u0026gt;= s.length() || i2 \u0026gt;= s.length()) { return 0; } if (dp[i1][i2] == -1) { if (i1 != i2 \u0026amp;\u0026amp; s[i1] == s[i2]) { dp[i1][i2] = 1 + LRSRecursive2(s, i1 + 1, i2 + 1, dp); } else { int c1 = LRSRecursive2(s, i1 + 1, i2, dp); int c2 = LRSRecursive2(s, i1, i2 + 1, dp); dp[i1][i2] = max(c1, c2); } } return dp[i1][i2]; } int LRSLength2(const string \u0026amp;s) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(s.length(), vector\u0026lt;int\u0026gt;(s.length(), -1)); return LRSRecursive2(s, 0, 0, dp); }  Time Complexity : O(N^2 )\nSpace Complexity : O(N^2)\nbottom-up int LRSLength3(const string \u0026amp;s) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(s.length() + 1, vector\u0026lt;int\u0026gt;(s.length() + 1)); for (int i = 0; i \u0026lt;= s.length(); i++) { dp[i][0] = 0; dp[0][i] = 0; } int maxLen = 0; for (int i1 = 1; i1 \u0026lt;= s.length(); i1++) { for (int i2 = 1; i2 \u0026lt;= s.length(); i2++) { //长度为i，索引为i-1 if (i1 != i2 \u0026amp;\u0026amp; s[i1 - 1] == s[i2 - 1]) { dp[i1][i2] = 1 + dp[i1 - 1][i2 - 1]; } else { dp[i1][i2] = max(dp[i1 - 1][i2], dp[i1][i2 - 1]); } //没必要maxlen，就是右下角 maxLen = max(maxLen, dp[i1][i2]); } } //return dp[i1][i2] return maxLen; }  Time Complexity : O(N^2 )\nSpace Complexity : O(N^2)\n9. subsequence pattern matching  给定字符串S1，模式串S2，求S1中出现S2(作为序列)的次数\n input:\ts=\u0026quot;baxmx\u0026quot; p=\u0026quot;ax\u0026quot; output:\t2 explanation: bAXmx, bAxmX  input: s=\u0026quot;tomorrow\u0026quot; ,p=\u0026quot;tor\u0026quot; output:4 explanation: TOmoRrow ,TomORrow,TOmorRow ,TomOrRow,  brute-force int countPatternMatchRecursive(const string \u0026amp;s, const string \u0026amp;p, int sCurrentIndex, int pCurrentIndex) { //模式串比完 if (pCurrentIndex \u0026gt;= p.length()) { return 1; } if (sCurrentIndex \u0026gt;= s.length()) { return 0; } int c1 = 0; if (s[sCurrentIndex] == p[pCurrentIndex]) { c1 = countPatternMatchRecursive(s, p, sCurrentIndex + 1, pCurrentIndex + 1); } //只有s索引增加 int c2 = countPatternMatchRecursive(s, p, sCurrentIndex + 1, pCurrentIndex); return c1 + c2; } int patternMatch(const string \u0026amp;s, const string \u0026amp;p) { return countPatternMatchRecursive(s, p, 0, 0); }  Time Complexity : O(2^N ) ,N为S的长度\nSpace Complexity : O(N)\ntop-down int countPatternMatchRecursive2(const string \u0026amp;s, const string \u0026amp;p, int sCurrentIndex, int pCurrentIndex, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;dp) { //模式串比完 if (pCurrentIndex \u0026gt;= p.length()) { return 1; } if (sCurrentIndex \u0026gt;= s.length()) { return 0; } if (dp[sCurrentIndex][pCurrentIndex] == -1) { int c1 = 0; if (s[sCurrentIndex] == p[pCurrentIndex]) { c1 = countPatternMatchRecursive2(s, p, sCurrentIndex + 1, pCurrentIndex + 1, dp); } //只有s索引增加 int c2 = countPatternMatchRecursive2(s, p, sCurrentIndex + 1, pCurrentIndex, dp); dp[sCurrentIndex][pCurrentIndex] = c1 + c2; } return dp[sCurrentIndex][pCurrentIndex]; } int patternMatch2(const string \u0026amp;s, const string \u0026amp;p) { vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; dp(s.length(), vector\u0026lt;int\u0026gt;(p.length(), -1)); return countPatternMatchRecursive2(s, p, 0, 0, dp); }  bottom-up int patternMatch3(const string \u0026amp;s, const string \u0026amp;p) { vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; dp(s.length() + 1, vector\u0026lt;int\u0026gt;(p.length() + 1)); //模式串为0，有一个 for (int i = 0; i \u0026lt;= s.length(); i++) { dp[i][0] = 1; } //第一行为0 for (int i = 1; i \u0026lt;= s.length(); i++) { for (int j = 1; j \u0026lt;= p.length(); j++) { if (s[i - 1] == p[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; } else { dp[i][j] = dp[i - 1][j]; } } } return dp[s.length()][p.length()]; }  Time Complexity : O(M * N)\nSpace Complexity : O(N * M)\n10. longest bitonic subsequence  求最长的双调子序列的长度\n双调：先单调递增，再单调递减\n input: [4, 2, 3, 6, 10, 1, 12] output:\t5 explanation: [2, 3, 6, 10, 1]  input: [4, 2, 5, 9, 7, 6, 10, 3, 1] output:\t7 explanation: [4, 5, 9, 7, 6, 3, 1]  brute-force //从currentIndex到end最长递减序列 int LISLengthRecursive(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int currentIndex, int previousIndex) { if (currentIndex \u0026gt;= nums.size()) { return 0; } int c1 = 0; //大于先前元素，包含在内 if (previousIndex == -1 || nums[currentIndex] \u0026lt; nums[previousIndex]) { c1 = 1 + LISLengthRecursive(nums, currentIndex + 1, currentIndex); } //不包含 int c2 = LISLengthRecursive(nums, currentIndex + 1, previousIndex); return max(c1, c2); } //从currentIndex到start最长递减序列 int LISLengthRecursiveReverse(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int currentIndex, int previousIndex) { if (currentIndex \u0026lt; 0) { return 0; } int c1 = 0; //大于先前元素，包含在内 if (previousIndex == -1 || nums[currentIndex] \u0026lt; nums[previousIndex]) { c1 = 1 + LISLengthRecursiveReverse(nums, currentIndex - 1, currentIndex); } //不包含 int c2 = LISLengthRecursiveReverse(nums, currentIndex - 1, previousIndex); return max(c1, c2); } int LBSLength(const vector\u0026lt;int\u0026gt; \u0026amp;nums) { int maxLen = 0; for (int i = 0; i \u0026lt; nums.size(); i++) { int length1 = LISLengthRecursive(nums, i, -1); int length2 = LISLengthRecursiveReverse(nums, i, -1); maxLen = max(maxLen, length1 + length2 - 1); } return maxLen; }  Time Complexity : O(2^N )\nSpace Complexity : O(N)\nbottom-up 有误，待看  Time Complexity : O(N^2 )\nSpace Complexity : O(N)\n11. longest alternating subsequence  求最长交替子序列的长度\n模式：a\u0026gt; b c\n input:\t[1, 2 ,3 , 4] output: 2 explanation: [1,2] [3,4],[1,3],[1,4]  input: [3, 2, 1, 4] output: 3 explanation: [3, 2, 4] [2,1,4]  input: [1, 3, 2, 4] output: 4 explanation: [1, 3, 2, 4]  待看 12. edit distance  给定字符串S1,S2,通过删除,插入,替换字符使得S1变成S2，求最小的操作数\n input: s1=\u0026quot;bat\u0026quot;,s2=\u0026quot;but\u0026quot; output: 1 explanation : replace a-\u0026gt;u  input: s1=\u0026quot;abdca\u0026quot;,s2=\u0026quot;cbda\u0026quot; output: 2 explanation : replace a-\u0026gt;c,delete second c  input: s1=\u0026quot;passpot\u0026quot;,s2=\u0026quot;ppsspqrt\u0026quot; output: 3 explanation : replace a-\u0026gt;p,o-\u0026gt;q,insert r  brute-force int minOperationRecursive(const string \u0026amp;s1, const string \u0026amp;s2, int s1CurrentIndex, int s2CurrentIndex) { if (s1CurrentIndex \u0026gt;= s1.length()) { return s2.length() - s2CurrentIndex; } if (s2CurrentIndex \u0026gt;= s2.length()) { return s1.length() - s1CurrentIndex; } if (s1[s1CurrentIndex] == s2[s2CurrentIndex]) { return minOperationRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex + 1); } //分别为删除，插入，取代 int length1 = 1 + minOperationRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex); int length2 = 1 + minOperationRecursive(s1, s2, s1CurrentIndex, s2CurrentIndex + 1); int length3 = 1 + minOperationRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex + 1); return min(length1, min(length2, length3)); } int minOperation(const string \u0026amp;s1, const string \u0026amp;s2) { return minOperationRecursive(s1, s2, 0, 0); }  Time Complexity : O(3^(N+M) )\nSpace Complexity : O(N+M)\ntop-down int minOperationRecursive2(const string \u0026amp;s1, const string \u0026amp;s2, int s1CurrentIndex, int s2CurrentIndex, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp) { if (s1CurrentIndex \u0026gt;= s1.length()) { return s2.length() - s2CurrentIndex; } if (s2CurrentIndex \u0026gt;= s2.length()) { return s1.length() - s1CurrentIndex; } if (dp[s1CurrentIndex][s2CurrentIndex] == -1) { if (s1[s1CurrentIndex] == s2[s2CurrentIndex]) { dp[s1CurrentIndex][s2CurrentIndex] = minOperationRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex + 1); } else { int length1 = 1 + minOperationRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex); int length2 = 1 + minOperationRecursive(s1, s2, s1CurrentIndex, s2CurrentIndex + 1); int length3 = 1 + minOperationRecursive(s1, s2, s1CurrentIndex + 1, s2CurrentIndex + 1); dp[s1CurrentIndex][s2CurrentIndex] = min(length1, min(length2, length3)); } } return dp[s1CurrentIndex][s2CurrentIndex]; } int minOperation(const string \u0026amp;s1, const string \u0026amp;s2) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(s1.length(), vector\u0026lt;int\u0026gt;(s2.length(), -1)); return minOperationRecursive2(s1, s2, 0, 0, dp); }  Time Complexity : O(N * M )\nSpace Complexity : O(N * M )\nbottom-up int minOperation(const string \u0026amp;s1, const string \u0026amp;s2) { //长度 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(s1.length() + 1, vector\u0026lt;int\u0026gt;(s2.length() + 1)); for (int i = 0; i \u0026lt;= s1.length(); i++) { dp[i][0] = i; } for (int j = 1; j \u0026lt;= s2.length(); j++) { dp[0][j] = j; } for (int i = 1; i \u0026lt;= s1.length(); i++) { for (int j = 1; j \u0026lt;= s2.length(); j++) { //长度为i，索引为i-1 if (s1[i - 1] == s2[j - 1]) { dp[i][j] = dp[i - 1][j - 1]; } else { dp[i][j] = min(1 + dp[i - 1][j], min(1 + dp[i][j - 1], 1 + dp[i - 1][j - 1])); } } } return dp[s1.length()][s2.length()]; }  Time Complexity : O(N * M )\nSpace Complexity : O(N * M )\n13. strings interleaving 待看待看 ","date":1593592582,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593592582,"objectID":"994bc5ac6a092d257b562ed3c5167864","permalink":"/code/dynamic-progamming/6-longest-common-substring/","publishdate":"2020-07-01T16:36:22+08:00","relpermalink":"/code/dynamic-progamming/6-longest-common-substring/","section":"code","summary":"最长公共子序列","tags":["Longest Common Substring"],"title":"Dynamic Programming-6 Longest Common Substring","type":"code"},{"authors":[],"categories":["Dynamic Programming"],"content":" 1. longest Palindromic Subsequence  求最长回文子序列(不连续)的长度\n input:\t\u0026quot;bbbab\u0026quot; output:\t4 explanation: \u0026quot;bbbb\u0026quot;  input:\t\u0026quot;cbbd\u0026quot; output:\t2 explanation: \u0026quot;bb\u0026quot;  Brute-force int longestPalindromicSubsequenceRecursive(const string \u0026amp;s, int startIndex, int endIndex) { if (startIndex \u0026gt; endIndex) { return 0; } //只有一个字符 if (startIndex == endIndex) { return 1; } if (s[startIndex] == s[endIndex]) { return 2 + longestPalindromicSubsequenceRecursive(s, startIndex + 1, endIndex - 1); } //从头或尾跳过一个字符 int c1 = longestPalindromicSubsequenceRecursive(s, startIndex + 1, endIndex); int c2 = longestPalindromicSubsequenceRecursive(s, startIndex, endIndex - 1); return max(c1, c2); } int LPS(string s) { return longestPalindromicSubsequenceRecursive(s, 0, s.size() - 1); }  Time Complexity : O(2^N )\nSpace Complexity : O(N)\nTop-down int LPSRecursive2(const string \u0026amp;s, int startIndex, int endIndex, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp) { if (startIndex \u0026gt; endIndex) { return 0; } //只有一个字符 if (startIndex == endIndex) { return 1; } if (dp[startIndex][endIndex] == -1) { if (s[startIndex] == s[endIndex]) { dp[startIndex][endIndex] = 2 + LPSRecursive2(s, startIndex + 1, endIndex - 1, dp); } else { //从头或尾跳过一个字符 int c1 = LPSRecursive2(s, startIndex + 1, endIndex, dp); int c2 = LPSRecursive2(s, startIndex, endIndex - 1, dp); dp[startIndex][endIndex] = max(c1, c2); } } return dp[startIndex][endIndex]; } int LPS2(string s) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(s.length(), vector\u0026lt;int\u0026gt;(s.length(), -1)); return LPSRecursive2(s, 0, s.size() - 1, dp); }  Time Complexity : O(N ^ 2)\nSpace Complexity : O(N ^ 2)\nbottom-up int LPS3(string s) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(s.length(), vector\u0026lt;int\u0026gt;(s.length())); for (int i = 0; i \u0026lt; s.length(); i++) { dp[i][i] = 1; } //dp[i][j]表示[i,j]区间内的字符串的最长回文子序列,上三角有效 //从下往上，从做往右处理。 for (int startIndex = s.length() - 1; startIndex \u0026gt;= 0; startIndex--) { for (int endIndex = startIndex + 1; endIndex \u0026lt; s.length(); endIndex++) { if (s[startIndex] == s[endIndex]) { dp[startIndex][endIndex] = 2 + dp[startIndex + 1][endIndex - 1]; } else { dp[startIndex][endIndex] = max(dp[startIndex + 1][endIndex], dp[startIndex][endIndex - 1]); } } } return dp[0][s.length() - 1]; }  Time Complexity : O(N ^ 2)\nSpace Complexity : O(N ^ 2)\nbottom-up 优化 int lps(string s) { int n = s.length(); // dp[i] is going to store length of longest // palindromic subsequence of substring s[0..i] int dp[n]; // Pick starting point for (int i = n - 1; i \u0026gt;= 0; i--) { int back_up = 0; // Pick ending points and see if s[i] // increases length of longest common // subsequence ending with s[j]. for (int j = i; j \u0026lt; n; j++) { // similar to 2D array L[i][j] == 1 // i.e., handling substrings of length // one. if (j == i) dp[j] = 1; // Similar to 2D array L[i][j] = L[i+1][j-1]+2 // i.e., handling case when corner characters // are same. else if (s[i] == s[j]){ // value a[j] is depend upon previous // unupdated value of a[j-1] but in // previous loop value of a[j-1] is // changed. To store the unupdated // value of a[j-1] back_up variable // is used. int temp = dp[j]; dp[j] = back_up + 2; back_up = temp; }else{ // similar to 2D array L[i][j] = max(L[i][j-1], // a[i+1][j]) back_up = dp[j]; dp[j] = max(dp[j - 1], dp[j]); } } } return dp[n - 1]; }  Time Complexity : O(N ^ 2)\nSpace Complexity : O(N)\n2. longest Palindromic Substring  求最长回文串\n input:\t\u0026quot;abdbca\u0026quot; output:\tbdb  input:\t\u0026quot;abbc\u0026quot; output:\tbb  input:\t\u0026quot;abc\u0026quot; output:\ta  Brute-force string LPS(string s) { int len = s.length(); int maxLen = 1;//任意字符都是回文 int startIndex = 0; for (int i = 0; i \u0026lt; len; i++) { for (int j = i + 1; j \u0026lt; len; j++) { int low = i; int high = j; while (low \u0026lt; high \u0026amp;\u0026amp; s[low] == s[high]) { low++; high--; } //\u0026quot;abbc\u0026quot;模式，跳出循环low\u0026gt;high //\u0026quot;abbtbbc\u0026quot;模式，跳出循环low=high //j - i + 1 \u0026gt; maxLen,判断长度是否大于1 if (low \u0026gt;= high \u0026amp;\u0026amp; j - i + 1 \u0026gt; maxLen) { maxLen = j - i + 1; startIndex = i; } } } return s.substr(startIndex, maxLen); }  Time Complexity : O(N^3 )\nSpace Complexity : O(1)\nBottom-up string LPS2(string s) { int len = s.length(); int maxLen = 1; int startIndex = 0; //dp[i][j]代表[i,j]位置的字符串是否回文 //当 i == j，dp[i][j] 是回文子串（单字符都是回文子串）； //当 j - i \u0026lt; 3，只要 S[i] == S[j]，则 dp[i][j] 是回文子串（如\u0026quot;aa\u0026quot;，“aba”），否则不是； //当 j - i \u0026gt;= 3，如果 S[i] == S[j] \u0026amp;\u0026amp; dp[i+1][j-1] ，则 dp[i][j] 是回文子串，否则不是 。 vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(len, vector\u0026lt;bool\u0026gt;(len, false)); //for循环顺序变化，左侧列-\u0026gt;右侧列，每列从上到下 //dp[i + 1][j - 1]在dp[i][j]的前一列，下一行，已经生成 for (int j = 0; j \u0026lt; len; j++) { for (int i = 0; i \u0026lt;= j; i++) { //小于3也行 if (j - i \u0026lt; 2) { dp[i][j] = (s[i] == s[j]); } else { dp[i][j] = (s[i] == s[j] \u0026amp;\u0026amp; dp[i + 1][j - 1]); } if (dp[i][j] \u0026amp;\u0026amp; j - i + 1 \u0026gt; maxLen) { maxLen = j - i + 1; startIndex = i; } } } // //另一种解法 // for (int i = 0;i \u0026lt; len; i++) { // dp[i][i] = true; // } // for (int i = len - 1; i \u0026gt;= 0; i--) { // //可以放在外面赋值 // for (int j = i; j \u0026lt; len; j++) { // //小于3也行 // if (j - i \u0026lt; 2) { // dp[i][j] = (s[i] == s[j]); // } else { // //要访问dp[i+1][j-1]，i从大到小，j从小到大 // dp[i][j] = (s[i] == s[j] \u0026amp;\u0026amp; dp[i + 1][j - 1]); // } // // if (dp[i][j] \u0026amp;\u0026amp; j - i + 1 \u0026gt; maxLen) { // maxLen = j - i + 1; // startIndex = i; // } // } // } return s.substr(startIndex, maxLen); }  Time Complexity : O(N^2 )\nSpace Complexity : O(N^2)\n3. count of Palindromic Substring  求最长回文串的个数\n input:\t\u0026quot;abdbca\u0026quot; output:\t7 explanation :\u0026quot;a\u0026quot;,\u0026quot;b\u0026quot;, \u0026quot;d\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;c\u0026quot;,\u0026quot;a\u0026quot;,\u0026quot;bdb\u0026quot;  Bottom-up int countLPS(string s) { int count = 0; int len = s.length(); vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(len, vector\u0026lt;bool\u0026gt;(len)); for (int j = 0; j \u0026lt; len; j++) { for (int i = 0; i \u0026lt;= j; i++) { //小于3也行 if (j - i \u0026lt; 3) { dp[i][j] = (s[i] == s[j]); } else { dp[i][j] = (s[i] == s[j] \u0026amp;\u0026amp; dp[i + 1][j - 1]); } if (dp[i][j]) { count++; } } } return count; }  Time Complexity : O(N^2 )\nSpace Complexity : O(N^2)\n4. minimum deletions in a string to make it a palindrome  删除字符串的一些字符，使得其成为回文字符串，求最小的删除数\n=len(s) - len(longest Palindromic Subsequence),字符串长度减去最长回文序列长度\n input:\t\u0026quot;abdbca\u0026quot; output:\t1 explanation: remove \u0026quot;c\u0026quot; -\u0026gt; \u0026quot;abdba\u0026quot;  input:\t\u0026quot;cddpd\u0026quot; output:\t2 explanation: remove \u0026quot;c\u0026quot;,\u0026quot;p\u0026quot; -\u0026gt; \u0026quot;ddd\u0026quot;  Bottom-up int LPS3(string s) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(s.length(), vector\u0026lt;int\u0026gt;(s.length())); for (int i = 0; i \u0026lt; s.length(); i++) { dp[i][i] = 1; } //dp[i][j]表示[i,j]区间内的字符串的最长回文子序列,上三角有效 //从下往上，从左往右处理。 //startIndex从大变小，endIndex从小变大 for (int startIndex = s.length() - 1; startIndex \u0026gt;= 0; startIndex--) { for (int endIndex = startIndex + 1; endIndex \u0026lt; s.length(); endIndex++) { if (s[startIndex] == s[endIndex]) { dp[startIndex][endIndex] = 2 + dp[startIndex + 1][endIndex - 1]; } else { dp[startIndex][endIndex] = max(dp[startIndex + 1][endIndex], dp[startIndex][endIndex - 1]); } } } return dp[0][s.length() - 1]; } int countRemove(string s) { return s.length() - LPS3(s); }  Time Complexity : O(N^2 )\nSpace Complexity : O(N^2)\n相似问题  插入一些字符，使得字符串成为回文字符串，求最小的插入数\n同上\n 5. palindromic partitioning  给定字符串，分割成子串，使得子串都是回文字符串，求最小切割几刀\n input:\t\u0026quot;abdbca\u0026quot; output:\t3 explanation: \u0026quot;a\u0026quot;,\u0026quot;bdb\u0026quot;,\u0026quot;c\u0026quot;,\u0026quot;a\u0026quot;  input:\t\u0026quot;pqr\u0026quot; output:\t3 explanation: \u0026quot;p\u0026quot;,\u0026quot;q\u0026quot;,\u0026quot;r\u0026quot;  input:\t\u0026quot;pp\u0026quot; output:\t0  Brute-force bool isPalindrome(string s, int start, int end) { while (start \u0026lt; end) { if (s[start] == s[end]) { start++; end--; } else { return false; } } return true; } int minCutRecursive(string s, int startIndex, int endIndex) { if (startIndex \u0026gt;= endIndex || isPalindrome(s, startIndex, endIndex)) { return 0; } //[startIndex,endIndex],的最大切值 int minCuts = endIndex - startIndex; for (int i = startIndex; i \u0026lt;= endIndex; i++) { if (isPalindrome(s, startIndex, i)) { minCuts = min(minCuts, 1 + minCutRecursive(s, i + 1, endIndex)); } } return minCuts; } int minCutLPS(string s) { return minCutRecursive(s, 0, s.length() - 1); }  Time Complexity : O(2^N )\nSpace Complexity : O(N)\nBottom-up 待看  ","date":1593592547,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593592547,"objectID":"f7024c7196ff83242ac552f1b2ba1c5f","permalink":"/code/dynamic-progamming/5-palindromic-subsequence/","publishdate":"2020-07-01T16:35:47+08:00","relpermalink":"/code/dynamic-progamming/5-palindromic-subsequence/","section":"code","summary":"回文子序列","tags":["Palindromic Subsequence"],"title":"Dynamic Programming-5 Palindromic Subsequence","type":"code"},{"authors":[],"categories":["Dynamic Programming"],"content":" 1. fibonacci numbers  斐波那契数列\n Brute-force int fib(int n) { if (n \u0026lt; 2) { return n; } return fib(n - 1) + fib(n - 2); }  Time Complexity : O(2^N )\nSpace Complexity : O(N)\nTop-down int fibRecursive(vector\u0026lt;int\u0026gt; \u0026amp;memoize, int n) { if (n \u0026lt; 2) return n; if (memoize[n] == -1) { memoize[n] = fibRecursive(memoize, n - 1) + fibRecursive(memoize, n - 2); return memoize[n]; } return memoize[n]; } int fib2(int n) { vector\u0026lt;int\u0026gt; memoize(n + 1, -1); return fibRecursive(memoize, n ); }  Time Complexity : O(N)\nSpace Complexity : O(N)\nBottom-up int fib3(int n) { if (n == 0) return 0; vector\u0026lt;int\u0026gt; dp(n + 1); dp[0] = 0; dp[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; }  Time Complexity : O(N)\nSpace Complexity : O(N)\n2. staircase  n阶台阶，每次只允许走1步、2步或3步，求有多少种方式\n intput:\tn=3 output:\t4 explanation:{1,1,1},{1,2},{2,1},{3}  intput:\tn=4 output:\t7 explanation:{1,1,1,1},{1,2,1},{2,1,1},{1,1,2},{3,1},{1,3},{2,2}  Brute-force int staircase(int n) { //可以往后推到n=3,结果：4 if (n == 0) { return 1; } if (n == 1) { return 1; } if (n == 2) { return 2; } return staircase(n - 1) + staircase(n - 2) + staircase(n - 3); }  Time Complexity : O(3^N )\nSpace Complexity : O(N)\nTop-down int staircaseRecursive2(vector\u0026lt;int\u0026gt; \u0026amp;dp, int n) { if (n == 0) { return 1; } if (n == 1) { return 1; } if (n == 2) { return 2; } if (dp[n] == -1) { dp[n] = staircaseRecursive2(dp, n - 1) + staircaseRecursive2(dp, n - 2) + staircaseRecursive2(dp, n - 3);; return dp[n]; } return dp[n]; } int staircase2(int n) { vector\u0026lt;int\u0026gt; dp(n + 1, -1); return staircaseRecursive2(dp, n); }  Time Complexity : O(N)\nSpace Complexity : O(N)\nBottom-up int staircase3(int n) { vector\u0026lt;int\u0026gt; dp(n + 1); dp[0] = 1; dp[1] = 1; dp[2] = 2; for (int i = 3; i \u0026lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]; } return dp[n]; }  Time Complexity : O(N)\nSpace Complexity : O(N)\n3. number factor  给定n,求有多少方式使得n等于{1,3,4}的和\n intput:\tn=4 output:\t4 explanation:{1,1,1,1},{1,3},{4},{3,1}  intput:\tn=5 output:\t6 explanation:{1,1,1,1,1},{1,1,3},{4,1},{1,4},{1,3,1},{3,1,1}  Brute-force int fib(int n) { if (n == 0) { return 1; } if (n == 1) { return 1; } if (n == 2) { return 1; } if (n == 3) { return 2; } return fib(n - 1) + fib(n - 3) + fib(n - 4); }  Time Complexity : O(3^N )\nSpace Complexity : O(N)\nTop-down int fibRecursive(vector\u0026lt;int\u0026gt; \u0026amp;dp, int n) { if (n == 0) { return 1; } if (n == 1) { return 1; } if (n == 2) { return 1; } if (n == 3) { return 2; } if (dp[n] == -1) { dp[n] = fibRecursive(dp, n - 1) + fibRecursive(dp, n - 3) + fibRecursive(dp, n - 4); return dp[n]; } return dp[n]; } int fib2(int n) { vector\u0026lt;int\u0026gt; dp(n + 1, -1); return fibRecursive(dp, n); }  Time Complexity : O(N)\nSpace Complexity : O(N)\nBottom-up int fib3(int n) { vector\u0026lt;int\u0026gt; dp(n + 1); dp[0] = 1; dp[1] = 1; dp[2] = 1; dp[3] = 2; for (int i = 4; i \u0026lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 3] + dp[i - 4]; } return dp[n]; }  Time Complexity : O(N)\nSpace Complexity : O(N)\n4. minimum jumps to reach the end  给定一组整数（\u0026gt;=0）,每个数代表可以往右跳的最大步数，求最小跳几次到达数组最后\n元素为0时，不能跳\n input:\t[2, 1, 1, 1, 4] output:\t3 explanation:0-index(2) -\u0026gt; 2-index(1) -\u0026gt; 3-index(1) -\u0026gt; 4-index  input:\t[ 1,1, 3, 6, 9, 3, 0, 1, 3] output:\t4 explanation:0-index(1) -\u0026gt; 1-index(1) -\u0026gt; 2-index(1) -\u0026gt; 3-index(6)-\u0026gt;8-index  Brute-force int countMinJumpsRecursive(const vector\u0026lt;int\u0026gt; \u0026amp;jumps, int currentIndex) { if (currentIndex == jumps.size() - 1) { return 0; } if (jumps[currentIndex] == 0) { return INT_MAX; } int totalJumps = INT_MAX; int start = currentIndex + 1; int end = currentIndex + jumps[currentIndex]; while (start \u0026lt; jumps.size() \u0026amp;\u0026amp; start \u0026lt;= end) { int minJumps = countMinJumpsRecursive(jumps, start); start++; if (minJumps != INT_MAX) { totalJumps = min(totalJumps, minJumps + 1); } } return totalJumps; } int countJumps(const vector\u0026lt;int\u0026gt; \u0026amp;jumps) { return countMinJumpsRecursive(jumps, 0); }  Time Complexity : O(2^N )\nSpace Complexity : O(N)\nTop-down int countMinJumpsRecursive2(const vector\u0026lt;int\u0026gt; \u0026amp;jumps, int currentIndex, vector\u0026lt;int\u0026gt; \u0026amp;dp) { if (currentIndex == jumps.size() - 1) { return 0; } if (jumps[currentIndex] == 0) { return INT_MAX; } if (dp[currentIndex] == INT_MAX) { int totalJumps = INT_MAX; int start = currentIndex + 1; int end = currentIndex + jumps[currentIndex]; while (start \u0026lt; jumps.size() \u0026amp;\u0026amp; start \u0026lt;= end) { int minJumps = countMinJumpsRecursive2(jumps, start, dp); start++; if (minJumps != INT_MAX) { totalJumps = min(totalJumps, minJumps + 1); } } dp[currentIndex] = totalJumps; } return dp[currentIndex]; } int countJumps2(const vector\u0026lt;int\u0026gt; \u0026amp;jumps) { vector\u0026lt;int\u0026gt; dp(jumps.size(), INT_MAX); return countMinJumpsRecursive2(jumps, 0, dp); }  Time Complexity : O(N^2)\nSpace Complexity : O(N)\nBottom-up //dp[currenIndex]代表以当前位置为起点到达终点的最小跳 int countJumps3(const vector\u0026lt;int\u0026gt; \u0026amp;jumps) { vector\u0026lt;int\u0026gt; dp(jumps.size()); //除了jumps[0]都为INT_MAX for (int i = 1; i \u0026lt; jumps.size(); i++) { dp[i] = INT_MAX; } for (int start = 0; start \u0026lt; jumps.size() - 1; start++) { for (int end = start + 1; end \u0026lt;= start + jumps[start] \u0026amp;\u0026amp; end \u0026lt; jumps.size(); end++) { //dp[start]到达 其能达到 的范围内的跳数 等于dp[start]+1 //比较这俩值 dp[end] = min(dp[end], dp[start] + 1); } } return dp[jumps.size() - 1]; }  Time Complexity : O(N^2)\nSpace Complexity : O(N)\n5. minimum jumps with fee  给定N，代表n步台阶，N个元素的数组代表上某一台阶的花费，你每次可以走1,2,3步，求最小花费到达终点\n input:\tn=6, fee:[1,2,5,2,1,2] output:\t3 explanation:0-index(1)-\u0026gt;3-index(2)-\u0026gt;top ,1+2=3  input:\tn=4, fee:[2,3,4,5] output:\t5 explanation:0-index(2)-\u0026gt;1-index(3)-\u0026gt;top ,2+3=5  Brute-force int minFeeRecursive(const vector\u0026lt;int\u0026gt; \u0026amp;fees, int currentIndex) { if (currentIndex \u0026gt;= fees.size()) { return 0; } int partFee1 = minFeeRecursive(fees, currentIndex + 1); int partFee2 = minFeeRecursive(fees, currentIndex + 2); int partFee3 = minFeeRecursive(fees, currentIndex + 3); return min(partFee1, min(partFee2, partFee3))+ fees[currentIndex]; } int minFee(const vector\u0026lt;int\u0026gt; \u0026amp;fees) { return minFeeRecursive(fees, 0); }  Time Complexity : O(3^N )\nSpace Complexity : O(N)\nTop-down int minFeeRecursive2(const vector\u0026lt;int\u0026gt; \u0026amp;fees, int currentIndex, vector\u0026lt;int\u0026gt; dp) { if (currentIndex \u0026gt;= fees.size()) { return 0; } if (dp[currentIndex] == -1) { int partFee1 = minFeeRecursive2(fees, currentIndex + 1, dp); int partFee2 = minFeeRecursive2(fees, currentIndex + 2, dp); int partFee3 = minFeeRecursive2(fees, currentIndex + 3, dp); dp[currentIndex] = min(partFee1, min(partFee2, partFee3)) + fees[currentIndex]; } return dp[currentIndex]; }  Time Complexity : O(N)\nSpace Complexity : O(N)\nBottom-up int minFee3(const vector\u0026lt;int\u0026gt; \u0026amp;fees) { //dp[n]代表，n阶台阶时，最小费用 vector\u0026lt;int\u0026gt; dp(fees.size() + 1); //n=0,时不需要，n=1或2时，只需fees[0] dp[0] = 0; dp[1] = fees[0]; dp[2] = fees[0]; //i,i-1,i-2阶台阶可直接到i+1阶台阶 for (int i = 2; i \u0026lt; fees.size(); i++) { dp[i + 1] = min(fees[i] + dp[i], min(fees[i - 1] + dp[i - 1], fees[i - 2] + dp[i - 2])); } return dp[fees.size()]; }  Time Complexity : O(N)\nSpace Complexity : O(N)\n6. house thief  小偷偷房子，n元数组代表n个房子的财富，小偷不能偷连续2个房子，求能偷到的最大财富\n input:\t[2,5,1,3,6,2,4] output:\t15 expalanation:5 + 6 + 4 = 15  input:\t[2, 10, 14, 8, 1] output:\t18 expalanation:10 + 8 = 18  Brute-force int maxWealthRecursive(const vector\u0026lt;int\u0026gt; \u0026amp;wealth, int currentIndex) { if (currentIndex \u0026gt;= wealth.size()) { return 0; } int part1wealth = maxWealthRecursive(wealth, currentIndex + 2) + wealth[currentIndex]; int part2wealth = maxWealthRecursive(wealth, currentIndex + 1); return max(part1wealth, part2wealth); } int maxWealth(const vector\u0026lt;int\u0026gt; \u0026amp;wealth) { return maxWealthRecursive(wealth, 0); }  Time Complexity : O(2^N )\nSpace Complexity : O(N)\nTop-down int maxWealthRecursive2(const vector\u0026lt;int\u0026gt; \u0026amp;wealth, int currentIndex, vector\u0026lt;int\u0026gt; dp) { if (currentIndex \u0026gt;= wealth.size()) { return 0; } if (dp[currentIndex] == -1) { int part1wealth = maxWealthRecursive2(wealth, currentIndex + 2, dp) + wealth[currentIndex]; int part2wealth = maxWealthRecursive2(wealth, currentIndex + 1, dp); dp[currentIndex] = max(part1wealth, part2wealth); } return dp[currentIndex]; } int maxWealth2(const vector\u0026lt;int\u0026gt; \u0026amp;wealth) { vector\u0026lt;int\u0026gt; dp(wealth.size() + 1, -1); return maxWealthRecursive2(wealth, 0, dp); }  Time Complexity : O(N)\nSpace Complexity : O(N)\nBottom-up int maxWealth3(const vector\u0026lt;int\u0026gt; \u0026amp;wealth) { //dp[n],当物品为n时最大财富 vector\u0026lt;int\u0026gt; dp(wealth.size() + 1); dp[0] = 0; dp[1] = wealth[0]; // dp[2]=max(wealth[0],wealth[1]); for (int i = 1; i \u0026lt; wealth.size(); i++) { //dp[i]:不偷； //dp[i-1]+wealth[i]:偷 i-1个物品最大值，加上第i+1个物品的价值 dp[i + 1] = max(dp[i], dp[i - 1] + wealth[i]); } return dp[wealth.size()]; }  Time Complexity : O(N)\nSpace Complexity : O(N)\n","date":1593592501,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593592501,"objectID":"613f512b4d75ad39fa89a4dafeb7b576","permalink":"/code/dynamic-progamming/4-fibonacci-numbers/","publishdate":"2020-07-01T16:35:01+08:00","relpermalink":"/code/dynamic-progamming/4-fibonacci-numbers/","section":"code","summary":"斐波那契数","tags":["Fibonacci Numbers"],"title":"Dynamic Programming-4 Fibonacci Numbers","type":"code"},{"authors":[],"categories":["Dynamic Programming"],"content":" 1. unbounded knapsack  给定N个物品的价值和重量，一个容量为C的背包。每个物品不限次数且总容量不能超过C，求最大价值\n input:\tweights=[1, 2, 3] profits=[15, 20, 50] C=5 output:\t80 explanations:\t2*15+50=80  input:\tweights=[1, 3, 4, 5] profits=[15, 50, 60, 90] C=8 output:\t140 explanations:\t50+90=140  Brute-force int knapsackRecursive(const vector\u0026lt;int\u0026gt; \u0026amp;weight, const vector\u0026lt;int\u0026gt; \u0026amp;profits, int capacity, int currentIndex) { if (capacity \u0026lt;= 0 || currentIndex \u0026gt;= weight.size() || weight.size() != profits.size()) { return 0; } int profit1 = 0; //选中之后，currentIndex不增加 if (weight[currentIndex] \u0026lt;= capacity) { profit1 = profits[currentIndex] + knapsackRecursive(weight, profits, capacity - weight[currentIndex], currentIndex ); } int profit2 = knapsackRecursive(weight, profits, capacity, currentIndex + 1); return max(profit1, profit2); } int knapsack(const vector\u0026lt;int\u0026gt; \u0026amp;weight, const vector\u0026lt;int\u0026gt; \u0026amp;profits, int capacity) { return knapsackRecursive(weight, profits, capacity, 0); }  Time Complexity : O(2^(N+C) )\nSpace Complexity : O(N + C)\nTop-down int knapsackRecursive2(const vector\u0026lt;int\u0026gt; \u0026amp;weight, const vector\u0026lt;int\u0026gt; \u0026amp;profits, int capacity, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;dp, int currentIndex) { if (capacity \u0026lt;= 0 || currentIndex \u0026gt;= weight.size()) { return 0; } if (dp[currentIndex][capacity] != -1) { return dp[currentIndex][capacity]; } int profit1 = 0; if (weight[currentIndex] \u0026lt;= capacity) { profit1 = profits[currentIndex] + knapsackRecursive2(weight, profits, capacity - weight[currentIndex], dp, currentIndex ); } int profit2 = knapsackRecursive2(weight, profits, capacity, dp, currentIndex + 1); dp[currentIndex][capacity] = max(profit1, profit2); return dp[currentIndex][capacity]; } int knapsack2(const vector\u0026lt;int\u0026gt; \u0026amp;weight, const vector\u0026lt;int\u0026gt; \u0026amp;profits, int capacity) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(weight.size(), vector\u0026lt;int\u0026gt;(capacity + 1, -1)); return knapsackRecursive2(weight, profits, capacity, dp, 0); }  Time Complexity : O(N + C)\nSpace Complexity : O(N + C)\nBottom-up int knapsack3(const vector\u0026lt;int\u0026gt; \u0026amp;weight, const vector\u0026lt;int\u0026gt; \u0026amp;profits, int capacity) { if (capacity \u0026lt;= 0 || profits.empty() || profits.size() != weight.size()) { return 0; } int n = profits.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(capacity + 1)); for (int i = 0; i \u0026lt; n; i++) { dp[i][0] = 0; } //如果第一个物品小于物品重量，放置,可以重复拿 for (int j = 0; j \u0026lt;= capacity; j++) { if (weight[0] \u0026lt;= j) { dp[0][j] = profits[0]+dp[0][j-weight[0]]; } } for (int i = 1; i \u0026lt; n; i++) { for (int c = 1; c \u0026lt;= capacity; c++) { int profit1 = 0, profit2 = 0; if (weight[i] \u0026lt;= c) { profit1 = profits[i] + dp[i][c - weight[i]]; } profit2 = dp[i - 1][c]; dp[i][c] = max(profit1, profit2); } } return dp[n - 1][capacity]; }  Time Complexity : O(N + C)\nSpace Complexity : O(N + C)\nselected item //有选中的项目，有具体选了几次 void printSelectElements(const vector\u0026lt;int\u0026gt; \u0026amp;weight, const vector\u0026lt;int\u0026gt; \u0026amp;profits, int capacity, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;dp) { int n = weight.size(); int totalProfit = dp[n - 1][capacity]; cout \u0026lt;\u0026lt; \u0026quot;--------\u0026quot;\u0026lt;\u0026lt;endl; //不能等于0，会越界 //选中，下一次同行 //未选中，上一行 int row=n-1; while(row\u0026gt;0){ if (totalProfit != dp[row - 1][capacity]) { cout \u0026lt;\u0026lt; weight[row] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; \u0026quot;index=\u0026quot; \u0026lt;\u0026lt; row \u0026lt;\u0026lt; \u0026quot; \u0026quot;\u0026lt;\u0026lt;endl; capacity -= weight[row]; totalProfit -= profits[row]; }else{ row--; } } //判断第一个元素是否被选中,这个时候跳出来循环，第一个元素不止选了一次 while(totalProfit != 0) { cout \u0026lt;\u0026lt; weight[0]\u0026lt;\u0026lt;\u0026quot; \u0026quot;; totalProfit-=profits[0]; cout \u0026lt;\u0026lt; \u0026quot;index=\u0026quot; \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026quot; \u0026quot;\u0026lt;\u0026lt;endl; } cout \u0026lt;\u0026lt; \u0026quot;--------\u0026quot;\u0026lt;\u0026lt;endl; }  2. rod cutting  给定长度为N的杆，切成小段，不同长度有不同的价格，求最大收益\n同上题1\n input:\tlengths= [1, 2, 3, 4, 5] prices= [2, 6, 7, 10, 13] N=5 output:\t14 explanations:2*(length=2)+1*(length=1)=14  Bottom-up int knapsack(const vector\u0026lt;int\u0026gt; \u0026amp;lengths, const vector\u0026lt;int\u0026gt; \u0026amp;prices, int rodLength) { if (rodLength \u0026lt;= 0 || prices.empty() || prices.size() != lengths.size()) { return 0; } int n = prices.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(rodLength + 1)); for (int i = 0; i \u0026lt; n; i++) { dp[i][0] = 0; } //如果第一个物品小于物品重量，放置,可以重复拿 for (int j = 0; j \u0026lt;= rodLength; j++) { if (lengths[0] \u0026lt;= j) { dp[0][j] = prices[0]+dp[0][j-lengths[0]]; } } for (int i = 1; i \u0026lt; n; i++) { for (int r = 1; r \u0026lt;= rodLength; r++) { int profit1 = 0, profit2 = 0; if (lengths[i] \u0026lt;= r) { profit1 = prices[i] + dp[i][r - lengths[i]]; } profit2 = dp[i - 1][r]; dp[i][r] = max(profit1, profit2); } } return dp[n - 1][rodLength]; }  Time Complexity : O(N + C)\nSpace Complexity : O(N + C)\nselected item 3. coin change  无限量不同面值的零钱和要换的钱N，求有多少种换钱的方式\n input: [1, 2, 3] , amount=5 output:\t5 explanation:{1,1,1,1,1},{1,1,1,2},{1,2,2},{1,1,3},{2,3}  Brute-force int coinChangeRecursive(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int total, int currentIndex) { //空集为一种 if (total == 0) { return 1; } if (currentIndex \u0026gt;= nums.size()) { return 0; } int part1 = 0, part2 = 0; if (nums[currentIndex] \u0026lt;= total) { part1 = coinChangeRecursive(nums, total - nums[currentIndex], currentIndex); } part2 = coinChangeRecursive(nums, total, currentIndex + 1); return part1 + part2; } int coinChange(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int total) { if (nums.empty()) { return 0; } return coinChangeRecursive(nums, total, 0); }  Time Complexity : O(2^(N+T) )\nSpace Complexity : O(N + T)\nTop-down int coinChangeRecursive2(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int total, int currentIndex, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp) { if (total == 0) { return 1; } if (currentIndex \u0026gt;= nums.size()) { return 0; } if (dp[currentIndex][total] == -1) { int part1 = 0, part2 = 0; if (nums[currentIndex] \u0026lt;= total) { part1 = coinChangeRecursive2(nums, total - nums[currentIndex], currentIndex, dp); } part2 = coinChangeRecursive2(nums, total, currentIndex + 1, dp); dp[currentIndex][total] = part1 + part2; } return dp[currentIndex][total]; } int coinChange2(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int total) { if (nums.empty()) { return 0; } int n = nums.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(total + 1, -1)); return coinChangeRecursive2(nums, total, 0, dp); }  Time Complexity : O(N * T)\nSpace Complexity : O(N * T)\nBottom-up int coinChange3(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int total) { if (nums.empty()) { return 0; } int n = nums.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(total + 1)); //第一列，空集算一种 for (int i = 0; i \u0026lt; n; i++) { dp[i][0] = 1; } //只有nums[0]一个元素,当t整除nums[0]时，一种 for (int t = 1; t \u0026lt;= total; t++) { dp[0][t] = (t % nums[0] == 0 ? 1 : 0); } for (int i = 1; i \u0026lt; n; i++) { for (int t = 1; t \u0026lt;= total; t++) { dp[i][t] = dp[i - 1][t]; if (nums[i] \u0026lt;= t) { dp[i][t] = dp[i][t] + dp[i][t - nums[i]]; } } } return dp[n - 1][total]; }  Time Complexity : O(N * T)\nSpace Complexity : O(N * T)\n4. minimum coin change  无限量不同面值的硬币和要换的总钱N，求硬币总数最小值\n input: [1, 2, 3] , amount=5 output:\t2 explanation:{2,3}  input: [1, 2, 3] , amount=11 output:\t4 explanation:{2,3,3,3}  Brute-force int countCoinChangeRecursive(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int total, int currentIndex) { if (total == 0) { return 0; } if (currentIndex \u0026gt;= nums.size()) { return -1; } int count1 = INT_MAX; if (nums[currentIndex] \u0026lt;= total) { if (INT_MAX != countCoinChangeRecursive(nums, total - nums[currentIndex], currentIndex)) { count1 = 1 + countCoinChangeRecursive(nums, total - nums[currentIndex], currentIndex); } } int count2 = countCoinChangeRecursive(nums, total, currentIndex + 1); return min(count1, count2); } int countCoinChange(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int total) { if (nums.empty()) { return INT_MAX; } int result = countCoinChangeRecursive(nums, total, 0); return result == INT_MAX ? -1 : result; }  Time Complexity : O(2^(N+T) )\nSpace Complexity : O(N + T)\nTop-down int countCoinChangeRecursive2(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int total, int currentIndex, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp) { if (total == 0) { return 0; } if (currentIndex \u0026gt;= nums.size()) { return INT_MAX; } if (dp[currentIndex][total] != INT_MAX) { int count1 = INT_MAX; if (nums[currentIndex] \u0026lt;= total) { if (INT_MAX != countCoinChangeRecursive2(nums, total - nums[currentIndex], currentIndex, dp)) { count1 = 1 + countCoinChangeRecursive2(nums, total - nums[currentIndex], currentIndex, dp); } } int count2 = countCoinChangeRecursive2(nums, total, currentIndex + 1, dp); dp[currentIndex][total] = min(count1, count2); } return dp[currentIndex][total]; } int countCoinChange2(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int total) { if (nums.empty()) { return -1; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(nums.size(), vector\u0026lt;int\u0026gt;(total + 1, INT_MAX)); int result = countCoinChangeRecursive(nums, total, 0); return result == INT_MAX ? -1 : result; }  Time Complexity : O(N * T)\nSpace Complexity : O(N * T)\nBottom-up int countCoinChange3(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int total) { if (nums.empty()) { return -1; } if (total == 0) { return 0; } int n = nums.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(total + 1)); for (int i = 0; i \u0026lt; n; i++) { dp[i][0] = 0; } //只有nums[0]时，最小个数为t/nums[0]; for (int t = 1; t \u0026lt;= total; t++) { dp[0][t] = (t % nums[0] == 0 ? t / nums[0] : INT_MAX); } for (int i = 1; i \u0026lt; n; i++) { for (int t = 1; t \u0026lt;= total; t++) { dp[i][t] = dp[i - 1][t]; //选中 if (nums[i] \u0026lt;= t) { if (dp[i][t - nums[i]] != INT_MAX) { dp[i][t] = min(dp[i - 1][t], 1 + dp[i][t - nums[i]]); } } } } return (dp[n - 1][total] == INT_MAX) ? -1 : dp[n - 1][total]; }  Time Complexity : O(N * T)\nSpace Complexity : O(N * T)\n5. maximum ribbon cut  相当于：无限量不同面值的硬币和要换的总钱N，求硬币总数最大值\n input:\t[2,3,5] ,total=5 output:\t2 explanation: {2,3}  input:\t[2,3] ,total=7 output:\t3 explanation: {2,2,3}  input:\t[3, 5,7] ,total=13 output:\t3 explanation: {3,3,7}  Brute-force int countCoinChangeRecursive(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int total, int currentIndex) { if (total == 0) { return 0; } if (currentIndex \u0026gt;= nums.size()) { return INT_MIN; } int count1 = INT_MIN; if (nums[currentIndex] \u0026lt;= total) { if (INT_MIN != countCoinChangeRecursive(nums, total - nums[currentIndex], currentIndex)) { count1 = 1 + countCoinChangeRecursive(nums, total - nums[currentIndex], currentIndex); } } int count2 = countCoinChangeRecursive(nums, total, currentIndex + 1); return max(count1, count2); } int countCoinChange(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int total) { if (nums.empty()) { return -1; } int result = countCoinChangeRecursive(nums, total, 0); return result == INT_MIN ? -1 : result; }  Time Complexity : O(2^(N+T) )\nSpace Complexity : O(N + T)\nBottom-up int countCoinChange3(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int total) { if (nums.empty()) { return -1; } if (total == 0) { return 0; } int n = nums.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(total + 1)); for (int i = 0; i \u0026lt; n; i++) { dp[i][0] = 0; } //只有nums[0]时，最小个数为t/nums[0]; for (int t = 1; t \u0026lt;= total; t++) { dp[0][t] = (t % nums[0] == 0 ? t / nums[0] : INT_MIN); } for (int i = 1; i \u0026lt; n; i++) { for (int t = 1; t \u0026lt;= total; t++) { dp[i][t] = dp[i - 1][t]; //选中 if (nums[i] \u0026lt;= t) { if (dp[i][t - nums[i]] != INT_MIN) { dp[i][t] = max(dp[i - 1][t], 1 + dp[i][t - nums[i]]); } } } } return (dp[n - 1][total] == INT_MIN) ? -1 : dp[n - 1][total]; }  Time Complexity : O(N * T)\nSpace Complexity : O(N * T)\n","date":1593592452,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593592452,"objectID":"585272bee31223b080e766dc754766c5","permalink":"/code/dynamic-progamming/3-unbounded-knapsack/","publishdate":"2020-07-01T16:34:12+08:00","relpermalink":"/code/dynamic-progamming/3-unbounded-knapsack/","section":"code","summary":"无界限背包","tags":["Unbounded Knapsack"],"title":"Dynamic Programming-3 Unbounded Knapsack","type":"code"},{"authors":[],"categories":["Dynamic Programming"],"content":" 1、0-1 Knapsack  给定N个物品的价值和重量，一个容量为C的背包。每个物品只能挑选一次且总容量不能超过C，求最大价值\n input:\tweights=[2, 3, 1, 4] profits=[4, 5, 3, 7] C=5 output:\t10 explanations:\t1+4=5,3+7=10  暴力法 int knapsackRecursive(const vector\u0026lt;int\u0026gt; \u0026amp;weight, const vector\u0026lt;int\u0026gt; \u0026amp;profits, int capacity, int currentIndex) { if (capacity \u0026lt;= 0 || currentIndex \u0026gt;= weight.size() || weight.size() != profits.size()) { return 0; } int profit1 = 0; if (weight[currentIndex] \u0026lt;= capacity) { profit1 = profits[currentIndex] + knapsackRecursive(weight, profits, capacity - weight[currentIndex], currentIndex + 1); } int profit2 = knapsackRecursive(weight, profits, capacity, currentIndex + 1); return max(profit1, profit2); } int knapsack(const vector\u0026lt;int\u0026gt; \u0026amp;weight, const vector\u0026lt;int\u0026gt; \u0026amp;profits, int capacity) { return knapsackRecursive(weight, profits, capacity, 0); }  Time Complexity : O(2^N )\nSpace Complexity : O(N)\n自顶向下 有重复\nint knapsackRecursive(const vector\u0026lt;int\u0026gt; \u0026amp;weight, const vector\u0026lt;int\u0026gt; \u0026amp;profits, int capacity, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;dp, int currentIndex) { if (capacity \u0026lt;= 0 || currentIndex \u0026gt;= weight.size()) { return 0; } if (dp[currentIndex][capacity] != -1) { return dp[currentIndex][capacity]; } int profit1 = 0; if (weight[currentIndex] \u0026lt;= capacity) { profit1 = profits[currentIndex] + knapsackRecursive(weight, profits, capacity - weight[currentIndex], dp, currentIndex + 1); } int profit2 = knapsackRecursive(weight, profits, capacity, dp, currentIndex + 1); dp[currentIndex][capacity] = max(profit1, profit2); return dp[currentIndex][capacity]; } int knapsack(const vector\u0026lt;int\u0026gt; \u0026amp;weight, const vector\u0026lt;int\u0026gt; \u0026amp;profits, int capacity) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(weight.size(), vector\u0026lt;int\u0026gt;(capacity + 1, -1)); return knapsackRecursive(weight, profits, capacity, dp, 0); }  Time Complexity : O(N * C)\nSpace Complexity : O(N * C)\n自底向上 int knapsack3(const vector\u0026lt;int\u0026gt; \u0026amp;weight, const vector\u0026lt;int\u0026gt; \u0026amp;profits, int capacity) { if (capacity \u0026lt;= 0 || profits.empty() || profits.size() != weight.size()) { return 0; } int n = profits.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(capacity + 1)); for (int i = 0; i \u0026lt; n; i++) { dp[i][0] = 0; } //如果第一个物品小于物品重量，放置 for (int j = 0; j \u0026lt;= capacity; j++) { if (weight[0] \u0026lt;= j) { dp[0][j] = profits[0]; } } //之后的物品 for (int i = 1; i \u0026lt; n; i++) { for (int j = 1; j \u0026lt;= capacity; j++) { int profit1 = 0, profit2 = 0; if (weight[i] \u0026lt;= j) { profit1 = profits[i] + dp[i - 1][j - weight[i]]; } profit2 = dp[i - 1][j]; dp[i][j] = max(profit1, profit2); } } return dp[n - 1][capacity]; }  Time Complexity : O(N * C)\nSpace Complexity : O(N * C)\n输出选择的物品：\n 当某个物品不选择时，dp的值来源于正上方，且相等。若不相等，则此物品被选中。\n void printSelectElements(const vector\u0026lt;int\u0026gt; \u0026amp;weight, const vector\u0026lt;int\u0026gt; \u0026amp;profits, int capacity, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;dp) { int n = weight.size(); int totalProfit = dp[n - 1][capacity]; cout \u0026lt;\u0026lt; \u0026quot;--------\u0026quot;; //不能等于0，会越界 for (int i = n - 1; i \u0026gt; 0; i--) { //最值与正上方比较,选中 if (totalProfit != dp[i - 1][capacity]) { cout \u0026lt;\u0026lt; weight[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; \u0026quot;index=\u0026quot; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;; capacity -= weight[i]; totalProfit -= profits[i]; } } //判断第一个元素是否被选中 if (totalProfit != 0) { cout \u0026lt;\u0026lt; weight[0]; cout \u0026lt;\u0026lt; \u0026quot;index=\u0026quot; \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026quot; \u0026quot;; } cout \u0026lt;\u0026lt; \u0026quot;--------\u0026quot;; }  优化一：\nint knapsack4(const vector\u0026lt;int\u0026gt; \u0026amp;weight, const vector\u0026lt;int\u0026gt; \u0026amp;profits, int capacity) { if (capacity \u0026lt;= 0 || profits.empty() || profits.size() != weight.size()) { return 0; } int n = profits.size(); //当前dp的值，只与上一行有关，两行就行，覆盖即可， vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(2, vector\u0026lt;int\u0026gt;(capacity + 1)); //如果第一个物品小于物品重量，放置 for (int j = 0; j \u0026lt;= capacity; j++) { if (weight[0] \u0026lt;= j) { dp[0][j] = dp[1][j] = profits[0]; } } //之后的物品 for (int i = 1; i \u0026lt; n; i++) { for (int j = 1; j \u0026lt;= capacity; j++) { int profit1 = 0, profit2 = 0; if (weight[i] \u0026lt;= j) { profit1 = profits[i] + dp[(i - 1) % 2][j - weight[i]]; } profit2 = dp[(i - 1) % 2][j]; dp[i % 2][j] = max(profit1, profit2); } } return dp[(n - 1) % 2][capacity]; }  Time Complexity : O(N * C)\nSpace Complexity : O(C)\n优化二：\nint knapsack5(const vector\u0026lt;int\u0026gt; \u0026amp;weight, const vector\u0026lt;int\u0026gt; \u0026amp;profits, int capacity) { if (capacity \u0026lt;= 0 || profits.empty() || profits.size() != weight.size()) { return 0; } int n = profits.size(); vector\u0026lt;int\u0026gt; dp(capacity + 1); //如果第一个物品小于物品重量，放置 for (int j = 0; j \u0026lt;= capacity; j++) { if (weight[0] \u0026lt;= j) { dp[j] = profits[0]; } } //之后的物品 for (int i = 1; i \u0026lt; n; i++) { //顺序改变防止覆盖 for (int j = capacity; j \u0026gt;= 0; j--) { int profit1 = 0, profit2 = 0; if (weight[i] \u0026lt;= j) { profit1 = profits[i] + dp[j - weight[i]]; } profit2 = dp[j]; dp[j] = max(profit1, profit2); } } return dp[capacity]; }  Time Complexity : O(N * C)\nSpace Complexity : O(C)\n2、equal subsets sum partition  给定正整数数组，是否存在一种分法将数组分为不相交的两部分，使得他们的和相等\n即求是否存在子数组使得其和为数组和的一半\n 暴力法 bool partitionRecursive(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int sum, int currentIndex) { if (sum == 0) { return true; } if (currentIndex \u0026gt;= nums.size()) { return false; } if (nums[currentIndex] \u0026lt;= sum) { if (partitionRecursive(nums, sum - nums[currentIndex], currentIndex + 1)) { return true; } } return partitionRecursive(nums, sum, currentIndex + 1); } bool equalSubset(const vector\u0026lt;int\u0026gt; \u0026amp;nums) { if (nums.empty()) { return false; } int sum = 0; for (int i = 0; i \u0026lt; nums.size(); i++) { sum += nums[i]; } if (sum % 2 != 0) { return false; } return partitionRecursive(nums, sum / 2, 0); }  Time Complexity : O(2^N)\nSpace Complexity : O(N)\n自顶向下 bool partitionRecursive2(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int sum, int currentIndex, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;dp) { if (sum == 0) { return true; } if (currentIndex \u0026gt;= nums.size()) { return false; } if (dp[currentIndex][sum] == -1) { if (nums[currentIndex] \u0026lt;= sum) { if (partitionRecursive(nums, sum - nums[currentIndex], currentIndex + 1)) { dp[currentIndex][sum] = 1; return true; } } dp[currentIndex][sum] = partitionRecursive(nums, sum, currentIndex + 1) ? 1 : 0; } return dp[currentIndex][sum] == 1 ? true : false; } bool equalSubset2(const vector\u0026lt;int\u0026gt; \u0026amp;nums) { if (nums.empty()) { return false; } int sum = 0; for (int i = 0; i \u0026lt; nums.size(); i++) { sum += nums[i]; } if (sum % 2 != 0) { return false; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(nums.size(), vector\u0026lt;int\u0026gt;(sum / 2 + 1, -1)); return partitionRecursive2(nums, sum / 2, 0, dp); }  Time Complexity : O(N * S) ，S为数组和\nSpace Complexity : O(N * S)\n自底向上 bool equalSubset3(const vector\u0026lt;int\u0026gt; \u0026amp;nums) { if (nums.empty()) { return false; } int sum = 0; for (int i = 0; i \u0026lt; nums.size(); i++) { sum += nums[i]; } if (sum % 2 != 0) { return false; } int halfSum = sum / 2; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(nums.size(), vector\u0026lt;bool\u0026gt;(halfSum + 1)); //第一列 for (int i = 0; i \u0026lt; nums.size(); i++) { dp[i][0] = true; } //第一行：第二个到最后一个 //此行非常重要，值不一定相同，视情况而定 //当处理nums[0]时，如果其值等于s,表明数组其余的元素和也是s for (int s = 1; s \u0026lt;= halfSum; s++) { //dp[0][s]= (nums[0]==s? true: false); if (nums[0] == s) { dp[0][s] = true; } else { dp[0][s] = false; } } for (int i = 1; i \u0026lt; nums.size(); i++) { for (int s = 1; s \u0026lt;= halfSum; s++) { //选中nums[i] if(dp[i-1][s]) { //跳过nums[i] dp[i][s] = dp[i - 1][s]; }else if (nums[i] \u0026lt;= s) { dp[i][s] = dp[i - 1][s - nums[i]]; } } } return dp[nums.size() - 1][halfSum]; }  Time Complexity : O(N * S) ，S为数组和\nSpace Complexity : O(N * S)\n拓展：\n 输出和相等的两个分组\n vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; printPartition(const vector\u0026lt;int\u0026gt; \u0026amp;nums, const vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; \u0026amp;dp) { int row = nums.size(); int halfSum = dp[0].size() - 1; //能否分成和相等的两部分 bool canPartition = dp[row - 1][halfSum]; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; vector\u0026lt;int\u0026gt; part1; vector\u0026lt;int\u0026gt; part2; for (int i = row - 1; i \u0026gt; 0; i--) { //选中，上一行和此行比较 if (dp[i - 1][halfSum] != canPartition) { part1.push_back(nums[i]); //跳到选中之前的一步 halfSum -= nums[i]; //既然两行的值不一样，下一步比较时，canPartition取反 canPartition = dp[i - 1][halfSum]; } else { part2.push_back(nums[i]); //canPartition = dp[i][halfSum]; } } //处理第一行，halfSum==0时，未选中。 if (halfSum != 0) { part1.push_back(nums[0]); } else { part2.push_back(nums[0]); } result.push_back(part1); result.push_back(part2); return result; }  3、subset sum  给定正整数数组和S值，判断是否存在子数组，使得其和等于S\n input: [1, 2, 3, 7], s=6 output:\ttrue explanation:sum(1, 2, 3)=6  input: [1, 2, 7, 1, 5], s=10 output:\ttrue explanation:sum(1, 2, 7)=10  input: [1, 3, 4, 8], s=6 output:\tfalse  暴力法 bool subsetSumRecursive(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int sum, int currentIndex) { if (sum == 0) { return true; } if (currentIndex \u0026gt;= nums.size()) { return false; } if (nums[currentIndex] \u0026lt;= sum) { //一定要加if判断，此分支(及分支的分支···）为假，不代表下一分支假 //为假时跳到下一步 if (subsetSumRecursive(nums, sum - nums[currentIndex], currentIndex + 1)) { return true; } } //上一分支为假 return subsetSumRecursive(nums, sum, currentIndex + 1); } bool subsetSum(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int sum) { if (sum == 0) { return true; } if (nums.empty()) { return false; } return subsetSumRecursive(nums, sum, 0); }  Time Complexity : O(2^N)\nSpace Complexity : O(N)\n自顶向下 bool subsetSumRecursive2(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int sum, int currentIndex, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;dp) { if (sum == 0) { return true; } if (currentIndex \u0026gt;= nums.size()) { return false; } if (dp[currentIndex][sum] == -1) { if (nums[currentIndex] \u0026lt;= sum) { if (subsetSumRecursive2(nums, sum - nums[currentIndex], currentIndex + 1, dp)) { dp[currentIndex][sum] = 1; return true; } } dp[currentIndex][sum] = subsetSumRecursive2(nums, sum, currentIndex + 1, dp) ? 1 : 0; } return dp[currentIndex][sum] == 1 ? true : false; } bool subsetSum2(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int sum) { if (sum == 0) { return true; } if (nums.empty()) { return false; } int n = nums.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(sum + 1, -1)); return subsetSumRecursive2(nums, sum, 0, dp); }  Time Complexity : O(N * S)\nSpace Complexity : O(N * S)\n自底向上 bool subsetSum3(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int sum) { if (sum == 0) { return true; } if (nums.empty()) { return false; } int n = nums.size(); vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(n, vector\u0026lt;bool\u0026gt;(sum + 1)); for (int i = 0; i \u0026lt; n; i++) { dp[i][0] = true; } for (int s = 1; s \u0026lt;= sum; s++) { if (nums[0] == s) { dp[0][s] = true; } else { dp[0][s] = false; } } for (int i = 1; i \u0026lt; n; i++) { for (int s = 1; s \u0026lt;= sum; s++) { //选中nums[i] if(dp[i-1][s]) { //跳过nums[i] dp[i][s] = dp[i - 1][s]; }else if (nums[i] \u0026lt;= s) { dp[i][s] = dp[i - 1][s - nums[i]]; } } } return dp[n - 1][sum]; }  Time Complexity : O(N * S)\nSpace Complexity : O(N * S)\n4、minimum subset sum different  给定正整数组成的数组，将其分为不重合的两个子数组，使得子数组的和 的差的绝对值最小，输出最小的差\n input:\t[1, 2, 3, 9] output:\t3 explanation：|sum(1,2,3) - sum(9)| = 3  input:\t[1, 2, 7, 1, 5] output:\t0 explanation：|sum(1,2,5) - sum(7,1)| = 0  input:\t[1, 3, 100, 4] output:\t92 explanation：|sum(1,3,4) - sum(100)| = 92  暴力法 int minSubsetSumDifferentRecursive(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int sum1, int sum2, int currentIndex) { if (currentIndex == nums.size()) { return abs(sum1 - sum2); } int diff1 = minSubsetSumDifferentRecursive(nums, sum1 + nums[currentIndex], sum2, currentIndex + 1); int diff2 = minSubsetSumDifferentRecursive(nums, sum1, sum2 + nums[currentIndex], currentIndex + 1); return min(diff1, diff2); } int minSubsetSumDifferent(const vector\u0026lt;int\u0026gt; \u0026amp;nums) { return minSubsetSumDifferentRecursive(nums, 0, 0, 0); }  Time Complexity : O(2^N )\nSpace Complexity : O(N)\n自顶向下 int minSubsetSumDifferentRecursive2(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int sum1, int sum2, int currentIndex,vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;dp) { if (currentIndex == nums.size()) { return abs(sum1-sum2); } if(dp[currentIndex][sum1]==-1){ int diff1 = minSubsetSumDifferentRecursive(nums, sum1 + nums[currentIndex], sum2, currentIndex + 1); int diff2 = minSubsetSumDifferentRecursive(nums, sum1, sum2 + nums[currentIndex], currentIndex + 1); dp[currentIndex][sum1] = min(diff1,diff2); } return dp[currentIndex][sum1]; } int minSubsetSumDifferent2(const vector\u0026lt;int\u0026gt; \u0026amp;nums) { int sum=0; for(int i=0;i\u0026lt;nums.size();i++){ sum+=nums[i]; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(nums.size(),vector\u0026lt;int\u0026gt;(sum+1,-1)); return minSubsetSumDifferentRecursive2(nums, 0, 0, 0,dp); }  Time Complexity : O(N * S)\nSpace Complexity : O(N * S)\n自底向上  子数组和等于Sum/2时，有最小值，如果不等于，求最接近sum/2的子数组。\n int minSubsetSumDifferent3(const vector\u0026lt;int\u0026gt; \u0026amp;nums) { int sum = 0; for (int i = 0; i \u0026lt; nums.size(); i++) { sum += nums[i]; } int n = nums.size(); int halfSum = sum / 2; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(n, vector\u0026lt;bool\u0026gt;(halfSum + 1)); for (int i = 0; i \u0026lt; n; i++) { dp[i][0] = true; } for (int s = 1; s \u0026lt;= halfSum; s++) { dp[0][s] = (nums[0] == s ? true : false); } for (int i = 1; i \u0026lt; n; i++) { for (int s = 1; s \u0026lt;= halfSum; s++) { if(dp[i-1][s]) { //跳过nums[i] dp[i][s] = dp[i - 1][s]; }else if (nums[i] \u0026lt;= s) { dp[i][s] = dp[i - 1][s - nums[i]]; } } } int sum1 = 0; //最后一行索引最大的值 for (int i = halfSum; i \u0026gt;= 0; i--) { if (dp[n - 1][i] == true) { sum1 = i; break; } } int sum2 = sum - sum1; return abs(sum2 - sum1); }  Time Complexity : O(N * S)\nSpace Complexity : O(N * S)\n5、count of subset sum  给定正整数数组和S值，求满足子数组和等于S的子数组所有个数\n input:\t[1, 1, 2, 3], S=4 output:\t3 explanation:[1,1,2], [1,3], [1,3]  input:\t[1, 2, 7, 1 , 5], S=9 output:\t3 explanation:[2,7], [1,7,1], [1,2,1,5]  暴力法 int countSubsetRecursive(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int sum, int currentIndex) { if (sum == 0) { return 1; } if (currentIndex \u0026gt;= nums.size()) { return 0; } int sum1 = 0; if (nums[currentIndex] \u0026lt;= sum) { sum1 = countSubsetRecursive(nums, sum - nums[currentIndex], currentIndex + 1); } int sum2 = countSubsetRecursive(nums, sum, currentIndex + 1); return sum1 + sum2; } int countSubset(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int sum) { if (nums.empty()) { return 0; } return countSubsetRecursive(nums, sum, 0); }  Time Complexity : O(2^N )\nSpace Complexity : O(N)\n自顶向下 int countSubsetRecursive2(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int sum, int currentIndex, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;dp) { if (sum == 0) { return 1; } if (currentIndex \u0026gt;= nums.size()) { return 0; } if (dp[currentIndex][sum] == -1) { int sum1 = 0; if (nums[currentIndex] \u0026lt;= sum) { sum1 = countSubsetRecursive(nums, sum - nums[currentIndex], currentIndex + 1); } int sum2 = countSubsetRecursive(nums, sum, currentIndex + 1); dp[currentIndex][sum] = sum1 + sum2; } return dp[currentIndex][sum]; } int countSubset2(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int sum) { if (nums.empty()) { return 0; } int n = nums.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(sum + 1, -1)); return countSubsetRecursive2(nums, sum, 0, dp); }  Time Complexity : O(N * S)\nSpace Complexity : O(N * S)\n自底向上 int countSubset3(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int sum) { if (nums.empty()) { return 0; } int n = nums.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(sum + 1, 0)); for (int i = 0; i \u0026lt; n; i++) { dp[i][0] = 1; } for (int s = 1; s \u0026lt;= sum; s++) { dp[0][s] = (nums[0] == s ? 1 : 0); } for (int i = 1; i \u0026lt; n; i++) { for (int s = 1; s \u0026lt;= sum; s++) { //未加入，顺序不能错 dp[i][s] = dp[i - 1][s]; //加入 if (nums[i] \u0026lt;= s) { dp[i][s] = dp[i][s] + dp[i - 1][s - nums[i]]; } } } return dp[n - 1][sum]; }  Time Complexity : O(N * S)\nSpace Complexity : O(N * S)\n6、target sum  给定正整数数组和值S，数组每个数前缀\u0026rdquo;+\u0026ldquo;或\u0026rdquo;-\u0026ldquo;，使得所有数的和为S，求多少种方式\n即求子数组a1，子数组a2，使得sum(a1) - sum(a2)=S\n且sum(a1) + sum(a2)= S-total\n则：sum(a1)=(S + S-total)/2\n即求子数组，使得其和为(S + S-total)/2\n input:\t[1, 2, 2, 3] ,s=1 output:\t3 explanation:+1-1-2+3=1, -1+1-2+3=1, +1+1+2-3=1  input:\t[1 ,2 ,7, 1] ,s=9 output:\t2 explanation:+1+2+7-1=9 , -1+2+7+1=2  自底向上 int countSubsets(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int sum) { int n = nums.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(sum + 1)); for (int i = 0; i \u0026lt; n; i++) { dp[i][0] = 1; } for (int s = 1; s \u0026lt;= sum; s++) { dp[0][s] = (nums[0] == s ? 1 : 0); } for (int i = 1; i \u0026lt; n; i++) { for (int s = 1; s \u0026lt;= sum; s++) { dp[i][s] = dp[i - 1][s]; if (nums[i] \u0026lt;= s) { dp[i][s] = dp[i][s] + dp[i - 1][s - nums[i]]; } } } return dp[n - 1][sum]; } int targetSum(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { int totalSum = 0; for (auto n:nums) { totalSum += n; } if (totalSum \u0026lt; target || (target + totalSum) % 2 == 1) { return 0; } return countSubsets(nums, (target + totalSum) / 2); }  Time Complexity : O(N * S)\nSpace Complexity : O(N * S)\n","date":1593592418,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593592418,"objectID":"4ad9cf2011cf459d2c27af6637eaba61","permalink":"/code/dynamic-progamming/2-0-1-knapsack/","publishdate":"2020-07-01T16:33:38+08:00","relpermalink":"/code/dynamic-progamming/2-0-1-knapsack/","section":"code","summary":"0-1背包","tags":["0-1 Knapsack"],"title":"Dynamic Programming-2 0-1 Knapsack","type":"code"},{"authors":[],"categories":["Dynamic Programming"],"content":" 1、introduction ​ 解决多阶段决策过程最优化的一种数学方法。把多阶段问题变换为一系列相互联系的的单阶段问题，然后逐个加以解决。是一种数学方法，是求解某类问题的一种方法，而不是一种特殊的算法，没有一个标准的数学表达式或明确定义的一种规则。\n2、特征 重叠子问题 最优子结构 3、方法 自顶向下，缓存已计算的重复结果 int fibRecursive(vector\u0026lt;int\u0026gt; \u0026amp;memoize, int n) { if (n \u0026lt; 2) return n; if (memoize[n] != 0) { return memoize[n]; } memoize[n] = fibRecursive(memoize, n - 1) + fibRecursive(memoize, n - 2); return memoize[n]; } int fib(int n) { vector\u0026lt;int\u0026gt; memoize(n + 1, 0); return fibRecursive(memoize, n-1)+fibRecursive(memoize,n-2); }  自底向上，列表计算后续结果 int fib(int n) { if (n == 0) return 0; vector\u0026lt;int\u0026gt; dp(n + 1); dp[0] = 0; dp[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; }  ","date":1593592396,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593592396,"objectID":"f9fd0c8bcfcf1746071af71b7952cbb2","permalink":"/code/dynamic-progamming/1-introduction/","publishdate":"2020-07-01T16:33:16+08:00","relpermalink":"/code/dynamic-progamming/1-introduction/","section":"code","summary":"简介","tags":[],"title":"Dynamic Programming-1 Introduction","type":"code"},{"authors":[],"categories":[],"content":" 2号 3号 4号 ","date":1590294608,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590294608,"objectID":"a8e7477f8919318ce855bbb90a6d86d1","permalink":"/code/pattern/miscellaneous/","publishdate":"2020-05-24T12:30:08+08:00","relpermalink":"/code/pattern/miscellaneous/","section":"code","summary":"杂","tags":["pattern"],"title":"Pattern-18 Miscellaneous","type":"code"},{"authors":[],"categories":[],"content":"","date":1590228075,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590228075,"objectID":"eeebfa542462ea772a81b417244ea9a1","permalink":"/code/pattern/conclusion/","publishdate":"2020-05-23T18:01:15+08:00","relpermalink":"/code/pattern/conclusion/","section":"code","summary":"总结","tags":["pattern"],"title":"Pattern-19 Conclusion","type":"code"},{"authors":[],"categories":[],"content":"","date":1590227948,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590227948,"objectID":"138be47416c6dc89e8150776c5436395","permalink":"/code/pattern/topological-sort/","publishdate":"2020-05-23T17:59:08+08:00","relpermalink":"/code/pattern/topological-sort/","section":"code","summary":"拓扑排序","tags":["pattern"],"title":"Pattern-17 Topological Sort","type":"code"},{"authors":[],"categories":[],"content":"","date":1590227870,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590227870,"objectID":"4c531a21e5a1162a3aeaf47277fcce4d","permalink":"/code/pattern/0-1-knapsack/","publishdate":"2020-05-23T17:57:50+08:00","relpermalink":"/code/pattern/0-1-knapsack/","section":"code","summary":"0-1背包","tags":["pattern"],"title":"Pattern-16 0-1 Knapsack","type":"code"},{"authors":[],"categories":[],"content":" 1、introduction 解决k个有序数组的合并、最值问题。用heap。\n2、merge k sorted lists  给定K组有序链表，合成一个有序链表\n input:\tl1=[2, 6, 8], l2=[3, 6, 7], l3=[1, 3, 4] output:\t[1, 2, 3, 3, 4, 6, 6, 7, 8]  input:\tl1=[5, 8, 9] ,l2=[1, 7] output:\t[1, 5, 7, 8, 9]  code：\nstruct ListNode { int val; ListNode *next; ListNode(int data) : val(data), next(NULL) {}; }; struct cmp_greater { bool operator()(const ListNode *x, const ListNode *y) { return x-\u0026gt;val \u0026gt; y-\u0026gt;val; } }; ListNode *merge(const vector\u0026lt;ListNode *\u0026gt; \u0026amp;lists) { priority_queue\u0026lt;ListNode *, vector\u0026lt;ListNode *\u0026gt;, cmp_greater\u0026gt; minHeap; for (auto root:lists) { if (root != NULL) { minHeap.push(root); } } ListNode *resultHead = NULL; ListNode *resultTail = NULL; while (!minHeap.empty()) { ListNode *node = minHeap.top(); minHeap.pop(); if (resultHead == NULL) { resultHead = node; resultTail = node; } else { resultTail-\u0026gt;next = node; resultTail = resultTail-\u0026gt;next; //resultTail=node; } if (node-\u0026gt;next != NULL) { minHeap.push(node-\u0026gt;next); } } return resultHead; }  Time Complexity : O(N * log K)\nSpace Complexity : O(K)\n3、kth smallest number in m sorted lists  给定M个有序数组，求所有数组中第K小的元素\n input:\tl1=[2, 6, 8], l2=[3, 6, 7], l3=[1, 3, 4],K=5 output:\t4 explanations:[1, 2, 3, 3, 4, 6, 6, 7, 8] 5th-\u0026gt;4  input: l1=[5, 8, 9], l2=[1, 7],K=3 output:\t7 explanations:[1, 5, 7, 8, 9] 3th-\u0026gt;7  code:\nstruct cmp_greater { bool operator()(const pair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;x, const pair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;y) { return x.first \u0026gt; y.first; } }; int kthSmallest(const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;lists, int k) { //pair\u0026lt;int,pair\u0026lt;int,int\u0026gt;\u0026gt;\u0026gt; 值，值所在第几个数组，值得索引 priority_queue\u0026lt;pair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt;, vector\u0026lt;pair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt;, cmp_greater\u0026gt; minHeap; for (int i = 0; i \u0026lt; lists.size(); i++) { if (!lists[i].empty()) { minHeap.push({lists[i][0], {i, 0}}); } } int numberCount = 0, result = 0; while (!minHeap.empty()) { auto node = minHeap.top(); minHeap.pop(); result = node.first; if (++numberCount == k) { break; } //下一个node node.second.second++; //node 所在链表还有元素 if (lists[node.second.first].size() \u0026gt; node.second.second) { node.first = lists[node.second.first][node.second.second]; minHeap.push(node); } } return result; }  Time Complexity : O(K * log M)\nSpace Complexity : O(M)\n相似问题1：\n 求m个有序数组、链表的平均值\n解：此时k=N/2\n 相似问题1：\n 合并m个有序数组\n解：同此题，要记录元素所在数组及索引\n 4、kth smallest number in a sorted matrix  给定矩阵和K值，每行每列增序，求第K小的数\n input:\tmaxtrix=[ [2, 6, 8], [3, 7, 10], [5, 8, 11] ], k=5 output:\t7  code:\nstruct cmp_greater { bool operator()(const pair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;x, const pair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;y) { return x.first \u0026gt; y.first; } }; int kthSmallest(const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;matrix, int k) { //pair\u0026lt;int,pair\u0026lt;int,int\u0026gt;\u0026gt;\u0026gt; 值，值所在第几个数组，值得索引 priority_queue\u0026lt;pair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt;, vector\u0026lt;pair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt;, cmp_greater\u0026gt; minHeap; //每行第一个元素放入heap，且不需要超过k个元素 for (int i = 0; i \u0026lt; matrix.size() \u0026amp;\u0026amp; i \u0026lt; k; i++) { minHeap.push({matrix[i][0], {i, 0}}); } int numberCount = 0, result = 0; while (!minHeap.empty()) { auto node = minHeap.top(); minHeap.pop(); result = node.first; if (++numberCount == k) { break; } //下一个node node.second.second++; //node 所在链表还有元素 if (matrix.size() \u0026gt; node.second.second) { node.first = matrix[node.second.first][node.second.second]; minHeap.push(node); } } return result; }  Time Complexity : O(min(K,N) + K * log N)\nSpace Complexity : O(N)\n二分查找的方法：\ncode：\n待看  5、smallest number range  给定m个有序数组，求长度最小的范围区间，使得区间包含每个数组至少一个元素\n input:\tl1=[1, 5, 8], l2=[4, 12], l3=[7, 8, 10] output:\t[4, 7] explanation: l1:-\u0026gt;5,l2:-\u0026gt;4, l3:-\u0026gt;7  input:\tl1=[1, 9], l2=[4, 12], l3=[7, 10, 16] output:\t[9, 12] explanation: l1:-\u0026gt;9 ,l2:-\u0026gt;12, l3:-\u0026gt;10  code:\nstruct cmp_greater { bool operator()(const pair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;x, const pair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;y) { return x.first \u0026gt; y.first; } }; pair\u0026lt;int, int\u0026gt; smallestRange(const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;lists) { //pair\u0026lt;int,pair\u0026lt;int,int\u0026gt;\u0026gt;\u0026gt; 值，值所在第几个数组，值得索引 priority_queue\u0026lt;pair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt;, vector\u0026lt;pair\u0026lt;int, pair\u0026lt;int, int\u0026gt;\u0026gt;\u0026gt;, cmp_greater\u0026gt; minHeap; int rangeStart = 0, rangeEnd = INT_MAX; int currentMaxNumber = INT_MIN; for (int i = 0; i \u0026lt; lists.size(); i++) { if (!lists[i].empty()) { minHeap.push({lists[i][0], {i, 0}}); //minHeap.push(make_pair(lists[i][0], make_pair(i, 0))); currentMaxNumber = max(lists[i][0], currentMaxNumber); } } while (minHeap.size() == lists.size()) { auto node = minHeap.top(); minHeap.pop(); if (rangeEnd - rangeStart \u0026gt; currentMaxNumber - node.first) { rangeStart = node.first; rangeEnd = currentMaxNumber; } //下一个node node.second.second++; //node 所在链表还有元素 if (lists[node.second.first].size() \u0026gt; node.second.second) { node.first = lists[node.second.first][node.second.second]; minHeap.push(node); currentMaxNumber = max(currentMaxNumber, node.first); } } return make_pair(rangeStart, rangeEnd); }  Time Complexity : O(N * log M)\nSpace Complexity : O(M)\n6、k pair with largest sums  给定两个降序数组和k值，求和最大的K对数(每个数组各一个值，值允许重复)\n input:\tl1=[9, 8, 2], l2=[6, 3, 1], k=3 output:\t[9, 3],[9, 6],[8, 6] explanation: 和最大的三组  input:\tl1=[5, 2, 1], l2=[2, -1], k=3 output:\t[5, 2],[5, -1], [2,2]  code:\nstruct cmp_greater_sum{ bool operator()(const pair\u0026lt;int,int\u0026gt; \u0026amp;x,const pair\u0026lt;int,int\u0026gt; \u0026amp;y){ return x.first+x.second\u0026gt;y.second+y.first; } }; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; klargestPairs(const vector\u0026lt;int\u0026gt; \u0026amp;num1,const vector\u0026lt;int\u0026gt; \u0026amp;num2,int k) { priority_queue\u0026lt;pair\u0026lt;int,int\u0026gt;,vector\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;,cmp_greater_sum\u0026gt; minHeap; for(int i=0;i\u0026lt;num1.size();i++){ for(int j=0;i\u0026lt;num2.size();j++){ if(minHeap.size()\u0026lt;k){ minHeap.push(make_pair(num1[i],num2[j])); }else{ if(num1[i]+num2[j]\u0026lt;minHeap.top().first+minHeap.top().second){ break; }else{ minHeap.pop(); minHeap.push(make_pair(num1[i],num2[j])); } } } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; while(!minHeap.empty()){ result.push_back({minHeap.top().first,minHeap.top().second}); minHeap.pop(); } return result; }  Time Complexity : O(N * M * log K)\nSpace Complexity : O(K)\n","date":1590227810,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590227810,"objectID":"1b14d3b4802f2749f5d790f39e2ae655","permalink":"/code/pattern/k-way-merge/","publishdate":"2020-05-23T17:56:50+08:00","relpermalink":"/code/pattern/k-way-merge/","section":"code","summary":"多路归并排序","tags":["pattern"],"title":"Pattern-15 K Way Merge","type":"code"},{"authors":[],"categories":[],"content":" 1、introduction 最大/最小/出现次数 的 第/前 K个元素，常用heap。\n2、top k numbers  给定未排序数组和K值，求前K个大的元素\n input:\t[3, 1, 5, 12, 2, 11] ,K=3 output: [5, 12, 11]  input:\t[5, 12, 11, -1, 12] ,K=3 output: [5, 12, 12]  vector\u0026lt;int\u0026gt; findLargestNumbers(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minHeap; vector\u0026lt;int\u0026gt; result; for (int i = 0; i \u0026lt; k; i++) { minHeap.push(nums[i]); } for (int i = k; i \u0026lt; nums.size(); i++) { if (nums[i] \u0026gt; minHeap.top()) { minHeap.pop(); minHeap.push(nums[i]); } } for (int i = 0; i \u0026lt; k; i++) { result.push_back(minHeap.top()); minHeap.pop(); } return result; }  Time Complexity : O(N * log K)\nSpace Complexity : O(K)\n3、kth smallest number  给定未排序数组和K值，求第K个小的元素\n input:\t[1, 5, 12, 2, 11, 5] ,K=3 output: 5 explanations: 1 2 5 5 11 12  input:\t[1, 5, 12, 2, 11, 5] ,K=4 output: 5 explanations: 1 2 5 5 11 12  input:\t[5, 11, 12, -1, 12] ,K=3 output: 11 explanations: -1 5 11 12 12  code:\nint kthSmallestNumber(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { priority_queue\u0026lt;int\u0026gt; maxHeap; for (int i = 0; i \u0026lt; k; i++) { maxHeap.push(nums[i]); } for (int i = k; i \u0026lt; nums.size(); i++) { if (nums[i] \u0026lt; maxHeap.top()) { maxHeap.pop(); maxHeap.push(nums[i]); } } return maxHeap.top(); }  Time Complexity : O(N * log K)\nSpace Complexity : O(K)\n使用小顶堆：\ncode：\nint kthSmallestNumberUseMinHeap(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minHeap; for (int i = 0; i \u0026lt; nums.size(); i++) { minHeap.push(nums[i]); } for (int i = 0; i \u0026lt; k - 1; i++) { minHeap.pop(); } return minHeap.top(); }  Time Complexity : O(N + K log N)\nSpace Complexity : O(N)\n4、k closest points to the origin  给定一组二位坐标点和K值，求前K个离原点最近的的点\n input:\t[[1, 2], [1, 3]], k=1 output:\t[[1, 2]]  input:\t[[1, 3], [3, 4], [2, -1]], k=2 output:\t[[1, 3],[2, -1]]  code:\nstruct Point { int x, y; Point(int _x, int _y) : x(_x), y(_y) {}; }; int distance(Point p) { return p.x * p.x + p.y + p.y; } bool operator\u0026lt;(Point a, Point b) { //return a.x*a.x +a.y*a.y \u0026gt; b.x*b.x+b.y+b.y; return distance(a) \u0026lt; distance(b); } vector\u0026lt;Point\u0026gt; findKthClosestPoints(const vector\u0026lt;Point\u0026gt; \u0026amp;Points, int k) { priority_queue\u0026lt;Point\u0026gt; maxHeap; vector\u0026lt;Point\u0026gt; result; for (int i = 0; i \u0026lt; k; i++) { maxHeap.push(Points[i]); } for (int i = k; i \u0026lt; Points.size(); i++) { if (distance(Points[i]) \u0026lt; distance(maxHeap.top())) { maxHeap.pop(); maxHeap.push(Points[i]); } } for (int i = 0; i \u0026lt; k; i++) { result.push_back(maxHeap.top()); maxHeap.pop(); } return result; }  Time Complexity : O(N * log K)\nSpace Complexity : O(K)\n5、connect ropes  把N段不同绳子连接成一段长绳子，使得cost最小\n连接两段绳子的cost= 两段绳子的长度和\n input: [1, 3, 11, 5] output: 33 explanations: cost1: 1 + 3 = 4; cost2: 4 + 5 = 9 ; cost3 :9 + 11 =20 ;totalcost: 4 + 9 + 20 = 33  input: [3, 4, 5, 6] output: 36 explanations: cost1: 3 + 4 = 7; cost2: 5 + 6 = 11 ; cost3 :7 + 11 =18 ;totalcost: 7 + 11 + 18 = 36  input: [1, 3, 11, 5, 2] output: 42 explanations: cost1: 1 + 2 = 3; cost2: 3 + 3 = 6 ; cost3 :6 + 5 =11 ;cost4 :11 + 11 =22 ; totalcost: 3 +6 + 11 + 12 = 42  code:\nint minimumCostConnectRopes(const vector\u0026lt;int\u0026gt; \u0026amp;nums) { int result = 0; int temp = 0; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minHeap; for (int i = 0; i \u0026lt; nums.size(); i++) { minHeap.push(nums[i]); } while (minHeap.size() \u0026gt; 1) { temp = minHeap.top(); minHeap.pop(); temp += minHeap.top(); minHeap.pop(); result += temp; minHeap.push(temp); } return result; }  Time Complexity : O(N * log N)\nSpace Complexity : O(N)\n6、top k frequent numbers  给定未排序数组和K值，求出现次数前K的数\n input: [1, 3, 5, 12, 11, 12, 11], k=2 output:\t[12, 11] explanations: 12(2), 11(2) , 其他1次  input: [5, 12, 11, 3, 11], k=2 output:\t[11, 5] 或[11, 12] 或[11, 3] explanations: 11(2), 其他1次  struct cmp_greater { bool operator()(const pair\u0026lt;int, int\u0026gt; \u0026amp;x, const pair\u0026lt;int, int\u0026gt; \u0026amp;y) { return x.second \u0026gt; y.second; } }; vector\u0026lt;int\u0026gt; findTopKFrequencyNumbers(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { unordered_map\u0026lt;int, int\u0026gt; numFrequencyMap; for (auto n:nums) { numFrequencyMap[n]++; } priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, cmp_greater\u0026gt; minHeap; for (auto entry: numFrequencyMap) { minHeap.push(entry); if (minHeap.size() \u0026gt; k) { minHeap.pop(); } } vector\u0026lt;int\u0026gt; topNumbers; while (!minHeap.empty()) { topNumbers.push_back(minHeap.top().first); minHeap.pop(); } return topNumbers; }  Time Complexity : O(N + N * log K)\nSpace Complexity : O(N)\n7、frequency sort  给定字符串，按照字符出现的次数降序排列\n input:\t\u0026quot;Programming\u0026quot; output:\t\u0026quot;rrggmmPiano\u0026quot;  input:\t\u0026quot;abcbab\u0026quot; output:\t\u0026quot;bbbaac\u0026quot;  code:\nstruct cmp_smaller { bool operator()(const pair\u0026lt;char, int\u0026gt; \u0026amp;x, const pair\u0026lt;char, int\u0026gt; \u0026amp;y) { return x.second \u0026lt; y.second; } }; string sortCharacterByFrequency(const string \u0026amp;str) { unordered_map\u0026lt;char, int\u0026gt; characterFrequencyMap; for (char chr:str) { characterFrequencyMap[chr]++; } priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, cmp_smaller\u0026gt; maxHeap; for (auto entry :characterFrequencyMap) { maxHeap.push(entry); } string sortedString = \u0026quot;\u0026quot;; while (!maxHeap.empty()) { auto entry = maxHeap.top(); maxHeap.pop(); for (int i = 0; i \u0026lt; entry.second; i++) { sortedString += entry.first; } } return sortedString; }  Time Complexity : O(N * log N)\nSpace Complexity : O(N)\n8、kth largest number in a stream  设计一个类，求数据流中的最大值\n 9、k closest numbers  给定排序的数组，及整数K和X。求数组中K个接近X的数，将返回的数排序，X不一定在原数组中。\n input:\t[5, 6, 7, 8, 9] , k=3 ,x=7 output:\t[6, 7 , 8]  input:\t[2 ,4 ,5 ,6 ,9] ,k=3 ,x=6 output:\t[4, 5, 6]  input:\t[2, 4, 5, 6, 9] ,k=3 ,x=10 output:\t[5, 6, 9]  code:\nstruct cmp_greater { bool operator()(const pair\u0026lt;int, int\u0026gt; \u0026amp;x, const pair\u0026lt;int, int\u0026gt; \u0026amp;y) { return x.first \u0026gt; y.first; } }; int binarySearch(const vector\u0026lt;int\u0026gt; \u0026amp;arr, int target) { int low = 0; int high = arr.size() - 1; while (low \u0026lt;= high) { int mid = low + (high - low) / 2; if (target = arr[mid]) { return mid; } else if (target \u0026gt; arr[mid]) { low = mid + 1; } else { high = mid - 1; } } if (low \u0026gt; 0) { return low - 1; } return low; } vector\u0026lt;int\u0026gt; findClosestElements(const vector\u0026lt;int\u0026gt; \u0026amp;arr, int k, int x) { int index = binarySearch(arr, x); int low = index - k; int high = index + k; low = max(low, 0); high = min((int) arr.size() - 1, high); priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, cmp_greater\u0026gt; minHeap; for (int i = low; i \u0026lt;= high; i++) { minHeap.push(make_pair(abs(arr[i] - x), i)); } vector\u0026lt;int\u0026gt; result; for (int i = 0; i \u0026lt; k; i++) { result.push_back(arr[minHeap.top().second]); minHeap.pop(); } sort(result.begin(), result.end()); return result; }  Time Complexity : O( log N + K * log K)\nSpace Complexity : O(K)\n双指针法：\nint binarySearch(const vector\u0026lt;int\u0026gt; \u0026amp;arr, int target) { int low = 0; int high = arr.size() - 1; while (low \u0026lt;= high) { int mid = low + (high - low) / 2; if (target = arr[mid]) { return mid; } else if (target \u0026gt; arr[mid]) { low = mid + 1; } else { high = mid - 1; } } if (low \u0026gt; 0) { return low - 1; } return low; } vector\u0026lt;int\u0026gt; findClosestElements2(const vector\u0026lt;int\u0026gt; \u0026amp;arr, int k, int x) { deque\u0026lt;int\u0026gt; result; int index = binarySearch(arr, x); int leftPointer = index; int rightPointer = index + 1; for (int i = 0; i \u0026lt; k; i++) { if (leftPointer \u0026gt;= 0 \u0026amp;\u0026amp; rightPointer \u0026lt; (int) arr.size()) { int diff1 = abs(x - arr[leftPointer]); int diff2 = abs(x - arr[rightPointer]); if (diff1 \u0026lt;= diff2) { result.push_back(arr[leftPointer]); leftPointer--; } else { result.push_back(arr[rightPointer++]); } } else if (leftPointer \u0026gt;= 0) { result.push_back(arr[leftPointer--]); } else if (rightPointer \u0026lt; (int) arr.size()) { result.push_back(arr[rightPointer++]); } } vector\u0026lt;int\u0026gt; resultvec; move(begin(result), end(result), back_inserter(resultvec)); sort(resultvec.begin(), resultvec.end()); return resultvec; }  Time Complexity : O(K + log N)\nSpace Complexity : O(1)\n10、maximum distinct elements  给定数组和K值，删除K个数后，求剩余的不重复的数的最大个数\n code:\nstruct cmp_greater { bool operator()(const pair\u0026lt;int, int\u0026gt; \u0026amp;x, const pair\u0026lt;int, int\u0026gt; \u0026amp;y) { return x.second \u0026gt; y.second; } }; int maximumDistinctElements(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { int distinctElementsCount = 0; if (nums.size() \u0026lt;= k) { return distinctElementsCount; } unordered_map\u0026lt;int, int\u0026gt; numFrequencyMap; for (auto num:nums) { numFrequencyMap[num]++; } priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, cmp_greater\u0026gt; minHeap; for (auto entry:numFrequencyMap) { if (entry.second == 1) { distinctElementsCount++; } else { minHeap.push(entry); } } while (k \u0026gt; 0 \u0026amp;\u0026amp; !minHeap.empty()) { auto entry = minHeap.top(); minHeap.pop(); k -= entry.second - 1; if (k \u0026gt;= 0) { distinctElementsCount++; } } if (k \u0026gt; 0) { distinctElementsCount -= k; } return distinctElementsCount; }  Time Complexity : O( N * log N + K * log K)\nSpace Complexity : O(N)\n11、sum of elements  给定数组和K1、K2值，求第k1小和第k2小之间元素和\n input:\t[1 ,3 ,12 ,5 ,15 ,11] , k1= 3, k2 = 6 output:\t23 explanations:3th-\u0026gt;5,6th-\u0026gt;15 ,11(4th) + 12(5th) = 23  input:\t[3, 5, 8, 7] , k1=1, k2 = 4 output:\t12 explanations:1th-\u0026gt;3,4th-\u0026gt;8 ,5(2th) + 7(3th) = 12  code:\nint sumOfElements(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int k1, int k2) { int sum = 0; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minHeap; for (auto num:nums) { minHeap.push(num); } for (int i = 0; i \u0026lt; k1; i++) { minHeap.pop(); } for (int i = 0; i \u0026lt; k2 - k1 - 1; i++) { sum += minHeap.top(); minHeap.pop(); } return sum; }  Time Complexity : O(N * log N)\nSpace Complexity : O(N)\n大顶堆方法：\nint sumOfElements2(const vector\u0026lt;int\u0026gt; \u0026amp;nums, int k1, int k2) { int sum = 0; priority_queue\u0026lt;int\u0026gt; maxHeap; for (int i = 0; i \u0026lt; nums.size(); i++) { if (i \u0026lt; k2 - 1) { maxHeap.push(nums[i]); } else if (nums[i] \u0026lt; maxHeap.top()) { maxHeap.pop(); maxHeap.push(nums[i]); } } for (int i = 0; i \u0026lt; k2 - k1 - 1; i++) { sum += maxHeap.top(); maxHeap.pop(); } return sum; }  Time Complexity : O(N * log K2)\nSpace Complexity : O(K2)\n12、rearrange string  给定字符串，重新排列，使得相同字符不在一起\n input:\t\u0026quot;aappp\u0026quot; output:\t\u0026quot;papap\u0026quot;  input:\t\u0026quot;Programming\u0026quot; output:\t\u0026quot;rgmrgmPiano\u0026quot;,或\u0026quot;gmringmrPoa\u0026quot;,等等  input:\t\u0026quot;aapa\u0026quot; output:\t\u0026quot;\u0026quot;  code:\nstruct cmp_smaller { bool operator()(const pair\u0026lt;char, int\u0026gt; \u0026amp;x, const pair\u0026lt;char, int\u0026gt; \u0026amp;y) { return x.second \u0026lt; y.second; } }; string rearrangeString(const string \u0026amp;str) { unordered_map\u0026lt;char, int\u0026gt; charFrequencyMap; priority_queue\u0026lt;pair\u0026lt;char, int\u0026gt;, vector\u0026lt;pair\u0026lt;char, int\u0026gt;\u0026gt;, cmp_smaller\u0026gt; maxHeap; string resultString = \u0026quot;\u0026quot;; pair\u0026lt;char, int\u0026gt; previousEntry(-1, -1); for (auto chr:str) { charFrequencyMap[chr]++; } for (auto entry:charFrequencyMap) { maxHeap.push(entry); } while (!maxHeap.empty()) { pair\u0026lt;char, int\u0026gt; currentEntry = maxHeap.top(); maxHeap.pop(); if (previousEntry.second \u0026gt; 0) { maxHeap.push(previousEntry); } resultString += currentEntry.first; currentEntry.second--; previousEntry = currentEntry; } return resultString.length() == str.length() ? resultString : \u0026quot;\u0026quot;; }  Time Complexity : O(N * log N)\nSpace Complexity : O(N)\n13、rearrange string k distance apart  给定字符串和K值，重新排列字符串，使得相同字符至少相隔k个字符\n input:\t\u0026quot;mmpp\u0026quot;, k=2 output:\t\u0026quot;mpmp\u0026quot; 或 \u0026quot;pmpm\u0026quot;  input:\t\u0026quot;aappa\u0026quot;, k=3 output:\t\u0026quot;\u0026quot;  input:\t\u0026quot;Programming\u0026quot;, k=3 output:\t\u0026quot;rgmPrgmiano\u0026quot; 或 \u0026quot;gmrPagimnor\u0026quot; 等等  code：\nstruct cmp_smaller { bool operator()(const pair\u0026lt;char, int\u0026gt; \u0026amp;x, const pair\u0026lt;char, int\u0026gt; \u0026amp;y) { return x.second \u0026lt; y.second; } }; string reorganizeString(const string \u0026amp;str, int k) { unordered_map\u0026lt;char, int\u0026gt; charFrequencyMap; priority_queue\u0026lt;pair\u0026lt;char, int\u0026gt;, vector\u0026lt;pair\u0026lt;char, int\u0026gt;\u0026gt;, cmp_smaller\u0026gt; maxHeap; string resultString = \u0026quot;\u0026quot;; queue\u0026lt;pair\u0026lt;char, int\u0026gt;\u0026gt; queue; if (k \u0026lt;= 1) { return str; } for (auto chr:str) { charFrequencyMap[chr]++; } for (auto entry:charFrequencyMap) { maxHeap.push(entry); } while (!maxHeap.empty()) { pair\u0026lt;char, int\u0026gt; currentEntry = maxHeap.top(); maxHeap.pop(); resultString += currentEntry.first; currentEntry.second--; queue.push(currentEntry); if (queue.size() == k) { auto entry = queue.front(); queue.pop(); if (entry.second \u0026gt; 0) { maxHeap.push(entry); } } } return resultString.length() == str.length() ? resultString : \u0026quot;\u0026quot;; }  Time Complexity : O(N * log N)\nSpace Complexity : O(N)\n14、scheduling tasks  任务调度，给定一组任务和K值，一个任务执行后必须间隔K 段时间，求完成调度最小总时间，当任务不能调度时用idle\n code:\nstruct cmp_smaller { bool operator()(const pair\u0026lt;char, int\u0026gt; \u0026amp;x, const pair\u0026lt;char, int\u0026gt; \u0026amp;y) { return x.second \u0026lt; y.second; } }; int scheduleTask(const vector\u0026lt;char\u0026gt; \u0026amp;task, int k) { int intervalCount = 0; unordered_map\u0026lt;char, int\u0026gt; charFrequencyMap; priority_queue\u0026lt;pair\u0026lt;char, int\u0026gt;, vector\u0026lt;pair\u0026lt;char, int\u0026gt;\u0026gt;, cmp_smaller\u0026gt; maxHeap; for (auto chr:task) { charFrequencyMap[chr]++; } for (auto entry:charFrequencyMap) { maxHeap.push(entry); } while (!maxHeap.empty()) { vector\u0026lt;pair\u0026lt;char, int\u0026gt;\u0026gt; waitList; int n = k + 1; for (; n \u0026gt; 0 \u0026amp;\u0026amp; !maxHeap.empty(); n--) { intervalCount++; auto currentEntry = maxHeap.top(); maxHeap.pop(); if (currentEntry.second \u0026gt; 1) { currentEntry.second--; waitList.push_back(currentEntry); } } for (auto w:waitList) { maxHeap.push(w); } if (!maxHeap.empty()) { intervalCount += n; } } return intervalCount; }  Time Complexity : O(N * log N)\nSpace Complexity : O(N)\n15、frequency stack  设计类\n ","date":1590227790,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590227790,"objectID":"b04141187f93160e24f6b576f67ee363","permalink":"/code/pattern/top-k-elements/","publishdate":"2020-05-23T17:56:30+08:00","relpermalink":"/code/pattern/top-k-elements/","section":"code","summary":"前K个元素","tags":["pattern"],"title":"Pattern-14 Top K Elements","type":"code"},{"authors":[],"categories":[],"content":" 1、introduction 异或操作\n异或性质： 1、自身异或为0： 1 ^ 1 = 0, 29 ^ 29 = 0 2、与0异或为自身： 1 ^ 0 = 1, 29 ^ 0 = 29 3、交换律和结合律： (a ^ b) ^ c = a ^ (b ^ c) a ^ b = b ^ a  2、missing number and single number  给定数组（元素为n-1个），范围（1-n），求缺失的数\n code:\nint findMissingNumber(const vector\u0026lt;int\u0026gt; \u0026amp;arr) { int n = arr.size() + 1; int s1 = 1; for (int i = 2; i \u0026lt;= n; i++) { s1 ^= i; } int s2 = arr[0]; for (int j = 1; j \u0026lt; n - 1; j++) { s2 ^= arr[j]; } return s1 ^ s2; }  Time Complexity : O(N)\nSpace Complexity : O(1)\n相似问题：\n 非空数组，只有1个元素出现1次，其余出现2次，求出现一次的那个数\n input: [1, 4, 2, 1, 3, 2, 3] output: 4  input: [7, 9, 7] output: 9  code:\nint singleNumber(const vector\u0026lt;int\u0026gt; \u0026amp;arr) { int result = arr[0]; //int result1=0; for循环：i=0 for (int i = 1; i \u0026lt; arr.size(); i++) { result ^= arr[i]; } return result; }  Time Complexity : O(N)\nSpace Complexity : O(1)\n3、two single number  非空数组，有2个元素出现1次，其余出现2次，求出现1次的那2个数\n input: [1, 4, 2, 1, 3, 5, 6, 2,3, 5] output: [4, 6]  input: [2, 1, 3, 2] output: [1, 3]  code:\nvector\u0026lt;int\u0026gt; twoSingleNumber(const vector\u0026lt;int\u0026gt; \u0026amp;nums) { int n1xn2 = 0; for (auto num: nums) { n1xn2 ^= num; } int rightMostSetBit = 1; while ((rightMostSetBit \u0026amp; n1xn2) == 0) { rightMostSetBit = rightMostSetBit \u0026lt;\u0026lt; 1; } int num1 = 0, num2 = 0; for (int num: nums) { if ((num \u0026amp; rightMostSetBit) != 0) { num1 ^= num; } else { num2 ^= num; } } return vector\u0026lt;int\u0026gt;{num1, num2}; }  Time Complexity : O(N)\nSpace Complexity : O(1)\n4、complement of base 10 number  10进制的正整数，转换为二进制，按位取反后，转化为10进制\n input: 8 output: 7 explanations: 8 -\u0026gt; 1000 -\u0026gt; 0111 -\u0026gt; 7  input: 10 output: 5 explanations: 10 -\u0026gt; 1010 -\u0026gt; 0101 -\u0026gt; 5  code:\nint bitwiseComplement(int num) { int bitCount = 0; int n = num; while (n \u0026gt; 0) { bitCount++; n = n \u0026gt;\u0026gt; 1; } int all_bits_set = pow(2, bitCount) - 1; return num ^ all_bits_set; }  Time Complexity : O(b)，b:整数二进制的位数\nSpace Complexity : O(1)\n5、flip matrix  没看懂\n ","date":1590227741,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590227741,"objectID":"08d8d414fbbf07cc25d5b71d6f3d5b19","permalink":"/code/pattern/bitwise-xor/","publishdate":"2020-05-23T17:55:41+08:00","relpermalink":"/code/pattern/bitwise-xor/","section":"code","summary":"位运算","tags":["pattern"],"title":"Pattern-13 Bitwise Xor","type":"code"},{"authors":[],"categories":[],"content":" 1、introduction 在数组，链表，矩阵中查找特定的值\n2、order-agnostic binary search  给定有序数组（不知升序，降序，有可能有重复）和Key值，判断key是否在数组中，返回其索引\n input:\t[4, 6, 10] ,key=10 output: 2  input:\t[1, 2, 3, 4, 6] ,key=4 output: 3  code:\nint search(const vector\u0026lt;int\u0026gt; \u0026amp;arr, int key) { int start = 0; int end = arr.size()-1; bool isAscending = arr[start] \u0026lt; arr[end]; while (start \u0026lt;= end) { int mid = start + (end - start) / 2; if (key == arr[mid]) { return mid; } if (isAscending) { if (key \u0026lt; arr[mid]) { end = mid - 1; } else { start = mid + 1; } } else { if (key \u0026gt; arr[mid]) { end = mid - 1; } else { start = mid + 1; } } } return -1; }  Time Complexity : O(logN)\nSpace Complexity : O(1)\n3、ceiling of a number  给定升序序列和key值，求ceiling of key（数组中最小的大于等于key的数），返回其索引\n input:\t[4, 6, 10] ,key=6 output:\t1 explanations:\t6-\u0026gt;index=1  input:\t[1, 3, 8, 10, 15] ,key=12 output:\t4 explanations:\t15-\u0026gt;index=4  code:\nint searchCeilingOfANumber(const vector\u0026lt;int\u0026gt; \u0026amp;arr, int key) { if (key \u0026gt; arr[arr.size() - 1]) { return -1; } int start = 0; int end = arr.size() - 1; while (start \u0026lt;= end) { int mid = start + (end - start) / 2; if (key \u0026lt; arr[mid]) { end = mid - 1; } else if (key \u0026gt; arr[mid]) { start = mid + 1; } else { return mid; } } //当循环结束时，start=end+1,没有找到等于key的元素，此时arr[start] //就是最小的大于等于key的值， //等同于 return end+1; return start; }  Time Complexity : O(logN)\nSpace Complexity : O(1)\n4、next letter  给定包含小写字母的升序序列和key，寻找最小的字母使得大于key，假定序列为循环序列（当key大于等于arr[arr.size()-1]时，返回arr[0]\n input:\t['a','c','f','h'] ,key='f' output:\t'h' explanations:\t'h' \u0026gt; 'f'  input:\t['a','c','f','h'] ,key='m' output:\t'a' explanations:循环后\t'a' \u0026gt; 'm'  code：\nchar searchNextLetter(const vector\u0026lt;char\u0026gt; \u0026amp;letter, char key) { int n = letter.size(); if (key \u0026lt; letter[0] || key \u0026gt;= letter[n - 1]) { return letter[0]; } int start = 0; int end = n - 1; while (start \u0026lt;= end) { int mid = start + (end - start) / 2; if (key \u0026lt; letter[mid]) { end = mid - 1; } else { start = mid + 1; } } //start=end+1 return letter[start]; }  Time Complexity : O(logN)\nSpace Complexity : O(1)\n5、number range  给定升序序列和key值，求key值得范围（key出现在序列中起始结束的索引）\n code：\ninput:\t[4, 6 ,6 ,6 ,9] ,key=6 output:\t[1 ,3]  input:\t[1, 3, 8, 10, 15] ,key=10 output:\t[3 ,3]  input:\t[1, 3, 8, 10, 15] ,key=112 output:\t[-1 ,-1]  code:\nint search(const vector\u0026lt;int\u0026gt; \u0026amp;arr, int key, bool findMaxIndex) { //findMaxIndex:是否找最大索引，每次search 只能找最大索引或最小索引 int keyIndex = -1; int start = 0; int end = arr.size() - 1; while (start \u0026lt;= end) { int mid = start + (end - start) / 2; if (key \u0026lt; arr[mid]) { end = mid - 1; } else if (key \u0026gt; arr[mid]) { start = mid + 1; } else { //记录最大索引或最小索引 keyIndex = mid; if (findMaxIndex) { //向后找最大索引 start = mid + 1; } else { //向前找最大索引 end = mid - 1; } } } return keyIndex; } pair\u0026lt;int, int\u0026gt; findRange(const vector\u0026lt;int\u0026gt; \u0026amp;arr, int key) { pair\u0026lt;int, int\u0026gt; result(-1, -1); result.first = search(arr, key, false); if (result.first != -1) { result.second = search(arr, key, true); } return result; }  Time Complexity : O(logN)\nSpace Complexity : O(1)\n6、search in a sorted infinite array  给定未知个数的升序序列和key，判断key是否在其中\n待看\n 7、minimum difference element  给定升序序列和key，求序列中与key 的差的绝对值差距最小的数\n input:\t[4, 6 ,10] ,key=7 output:\t6 explanations:|6-7|=1  input:\t[4, 6 ,10] ,key=4 output:\t4 explanations:|4-4|=0  code:\nint searchMinimumDifference(const vector\u0026lt;int\u0026gt; \u0026amp;arr, int key) { if (key \u0026lt; arr[0]) { return arr[0]; } if (key \u0026gt; arr[arr.size() - 1]) { return arr[arr.size() - 1]; } int start = 0; int end = arr.size() - 1; while (start \u0026lt;= end) { int mid = start + (end - start) / 2; if (key \u0026lt; arr[mid]) { end = mid - 1; } else if (key \u0026gt; arr[mid]) { start = mid + 1; } else { return arr[mid]; } } if ((arr[start] - key) \u0026lt; (key - arr[end])) { return arr[start]; } return arr[end]; }  Time Complexity : O(logN)\nSpace Complexity : O(1)\n8、bitonic array maximum  求bitonic数组中的最大值\nbitonic array：先单调递增，在单调递减，arr[i] != arr[i+1]\n input: [1, 3, 8, 12, 4, 2] output:\t12  input: [3, 8, 3, 1] output:\t8  input: [1, 3, 8, 12] output:\t12  input: [10, 9 , 8] output:\t10  code:\nint finMax(const vector\u0026lt;int\u0026gt; \u0026amp;arr) { int start = 0; int end = arr.size() - 1; while (start \u0026lt; end) { int mid = start + (end - start) / 2; //当arr[mid]\u0026gt;arr[mid+1]，位于后半段，最大值在mid前面 if (arr[mid] \u0026gt; arr[mid + 1]) { end = mid; } else { //位于前半段，最大值在mid+1后面 start = mid + 1; } } //循环结束start==end return arr[start]; }  Time Complexity : O(logN)\nSpace Complexity : O(1)\n9、search bitonic array  给定bitonic数组和key值，判断key是否在其中，返回索引\nbitonic array：先单调递增，在单调递减，arr[i] != arr[i+1]\n input: [1, 3, 8, 4, 3],key=4 output:\t3  input: [3, 8, 3, 1],key=8 output:\t1  input: [1, 3, 8, 12],key=12 output:\t3  input: [10, 9 , 8],key=10 output:\t0  code:\nint binarySearch(const vector\u0026lt;int\u0026gt; \u0026amp;arr, int key, int start, int end) { bool isAscending = arr[start] \u0026lt; arr[end]; while (start \u0026lt;= end) { int mid = start + (end - start) / 2; if (key == arr[mid]) { return mid; } if (isAscending) { if (key \u0026lt; arr[mid]) { end = mid - 1; } else { start = mid + 1; } } else { if (key \u0026gt; arr[mid]) { end = mid - 1; } else { start = mid + 1; } } } return -1; } //返回最大值得索引 int finMax(const vector\u0026lt;int\u0026gt; \u0026amp;arr) { int start = 0; int end = arr.size() - 1; while (start \u0026lt; end) { int mid = start + (end - start) / 2; //当arr[mid]\u0026gt;arr[mid+1]，位于后半段，最大值在mid前面 if (arr[mid] \u0026gt; arr[mid + 1]) { end = mid; } else { //位于前半段，最大值在mid+1后面 start = mid + 1; } } //循环结束start==end return start; } int search(const vector\u0026lt;int\u0026gt; \u0026amp;arr, int key) { int maxIndex = finMax(arr); //前半段 int keyIndex = binarySearch(arr, key, 0, maxIndex); if (keyIndex != -1) { return keyIndex; } //后半段 return binarySearch(arr, key, maxIndex + 1, arr.size() - 1); }  Time Complexity : O(logN)\nSpace Complexity : O(1)\n10、search in rotated array  给定rotated array(不含重复)和key，判断key是否在其中，返回索引\nrotated array：旋转数组，有序数组旋转了有理数个位置，生成两段递增子数组\n code：\nint search(const vector\u0026lt;int\u0026gt; \u0026amp;arr, int key) { int start = 0; int end = arr.size() - 1; while (start \u0026lt;= end) { int mid = start + (end - start) / 2; if (arr[mid] == key) { return mid; } //左开左开右闭区间 //[start,mid]之间有序，较长段有序序列在前 if (arr[start] \u0026lt;= arr[mid]) { //判断key在[start,mid]之间，还是在之后 if (key \u0026gt;= arr[start] \u0026amp;\u0026amp; key \u0026lt; arr[mid]) { end = mid - 1; } else { start = mid + 1; } //[mid，end]之间有序，较长段有序序列在后 } else { if (key \u0026gt; arr[mid] \u0026amp;\u0026amp; key \u0026lt;= arr[end]) { //判断key在[mid，end]之间，还是在之后 start = mid + 1; } else { end = mid - 1; } } } return -1; }  Time Complexity : O(logN)\nSpace Complexity : O(1)\n相似问题：\n 给定rotated array(含重复)和key，判断key是否在其中，返回索引\nrotated array：旋转数组，有序数组旋转了有理数个位置，生成两段递增子数组\n code:\nint searchDuplicate(const vector\u0026lt;int\u0026gt; \u0026amp;arr, int key) { int start = 0; int end = arr.size() - 1; while (start \u0026lt;= end) { int mid = start + (end - start) / 2; if (arr[mid] == key) { return mid; } //左开左开右闭区间 //当arr[start]=arr[mid]==arr[end]时，无法分辨数组那一部分是有序的 if((arr[start]==arr[mid])\u0026amp;\u0026amp;(arr[end]==arr[mid])){ //跳过一位 start++; end--; //[start,mid]之间有序，较长段有序序列在前 }else if (arr[start] \u0026lt;= arr[mid]) { //判断key在[start,mid]之间，还是在之后 if (key \u0026gt;= arr[start] \u0026amp;\u0026amp; key \u0026lt; arr[mid]) { end = mid - 1; } else { start = mid + 1; } //[mid，end]之间有序，较长段有序序列在后 } else { if (key \u0026gt; arr[mid] \u0026amp;\u0026amp; key \u0026lt;= arr[end]) { //判断key在[mid，end]之间，还是在之后 start = mid + 1; } else { end = mid - 1; } } } return -1; }  Time Complexity : O(logN)，最坏： O(N)\nSpace Complexity : O(1)\n11、rotation count  求旋转数组(无重复)旋转了几个位置\n等同于求最小值的索引\n code:\nint countRotations(const vector\u0026lt;int\u0026gt; \u0026amp;arr) { int start = 0; int end = arr.size() - 1; while (start \u0026lt; end) { int mid = start + (end - start) / 2; //最小值前面全是比它大的元素 if (mid \u0026lt; end \u0026amp;\u0026amp; arr[mid] \u0026gt; arr[mid + 1]) { return mid +1; } if (mid \u0026gt; start \u0026amp;\u0026amp; arr[mid - 1] \u0026gt; arr[mid]) { return mid; } //左侧有序，最小值在右面 if (arr[start] \u0026lt; arr[mid]) { start = mid + 1; } else { end = mid - 1; } } return 0; }  Time Complexity : O(logN)\nSpace Complexity : O(1)\n相似问题：\n 求旋转数组(有重复)旋转了几个位置\n code:\nint countRotationsDuplicate(const vector\u0026lt;int\u0026gt; \u0026amp;arr) { int start = 0; int end = arr.size() - 1; while (start \u0026lt; end) { int mid = start + (end - start) / 2; //最小值前面全是比它大的元素 if (mid \u0026lt; end \u0026amp;\u0026amp; arr[mid] \u0026gt; arr[mid + 1]) { return mid + 1; } if (mid \u0026gt; start \u0026amp;\u0026amp; arr[mid - 1] \u0026gt; arr[mid]) { return mid; } //arr[start] = arr[end] =arr[mid]，挑一步 if (arr[start] == arr[end] \u0026amp;\u0026amp; arr[end] == arr[mid]) { if (arr[start] \u0026gt; arr[start + 1]) { return start + 1; } start++; if (arr[end - 1] \u0026gt; arr[end]) { return end; } end--; //左侧有序，最小值在右面 } else if (arr[start] \u0026lt; arr[mid] || (arr[start] == arr[mid]) \u0026amp;\u0026amp; (arr[mid] \u0026gt; arr[end])) { start = mid + 1; } else { end = mid - 1; } } return 0; }  Time Complexity : O(logN)，最坏： O(N)\nSpace Complexity : O(1)\n","date":1590227706,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590227706,"objectID":"d9965ddcb9fe9aba6badf5a8e039f2a9","permalink":"/code/pattern/modified-binary-search/","publishdate":"2020-05-23T17:55:06+08:00","relpermalink":"/code/pattern/modified-binary-search/","section":"code","summary":"改造后的二分查找","tags":["pattern","二分查找"],"title":"Pattern-12 Modified Binary Search","type":"code"},{"authors":[],"categories":[],"content":" 1、introduction 解决排列和组合问题，使用广度优先算法\n2、subsets  给定不含重复元素的集合，求其所有不同的子集\n input:\t[1, 3] output:\t[], [1], [3], [1, 3]  input:\t[1, 5, 3] output:\t[], [1], [3], [5] ,[1, 3], [1, 5], [3 ,5],[1 ,3 ,5]  code:\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; findSubsets(const vector\u0026lt;int\u0026gt;\u0026amp;nums){ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets; subsets.push_back(vector\u0026lt;int\u0026gt;()); //取已经有的子集，插入新的元素，生成新的子集 for(auto currentNumber: nums){ int n=subsets.size(); for(int i=0;i\u0026lt;n;i++){ vector\u0026lt;int\u0026gt; set(subsets[i]); set.push_back(currentNumber); subsets.push_back(set); } } return subsets; }  Time Complexity : O(2^N)\nSpace Complexity : O(2^N)\n3、subsets with Duplicates  给定含重复元素的集合，求其所有不同的子集\n input:\t[1, 3, 3] output:\t[], [1], [3], [1, 3], [3, 3], [1, 3, 3]  input:\t[1, 5, 3, 3] output:\t[], [1], [3], [5], [1, 5] ,[1, 3], [1, 5, 3], [3, 3], [1, 3, 3],[5 ,3], [3,3,5],[1, 5, 3, 3]  code:\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; findSubsets(vector\u0026lt;int\u0026gt; \u0026amp;nums) { sort(nums.begin(), nums.end()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets; subsets.push_back(vector\u0026lt;int\u0026gt;()); int startIndex = 0; int endIndex = 0; //当遇到重复的元素时，取上一步生成的子集，插入新的元素，生成新的子集 for (int i = 0; i \u0026lt; nums.size(); i++) { startIndex = 0; if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { startIndex = endIndex + 1; } endIndex = subsets.size() - 1; for (int j = startIndex; j \u0026lt;= endIndex; j++) { vector\u0026lt;int\u0026gt; set(subsets[j]); set.push_back(nums[i]); subsets.push_back(set); } } return subsets; }  Time Complexity : O(2^N)\nSpace Complexity : O(2^N)\n4、permutations  给定不含重复元素的集合，求其所有排列\n input:\t[1, 3, 5] output:\t[1, 3, 5], [1 ,5, 3], [3, 5, 1], [3, 1, 5], [5, 1, 3], [5, 3, 1]  code:\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; findPermutations(vector\u0026lt;int\u0026gt; \u0026amp;nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; queue\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permutations; permutations.push(vector\u0026lt;int\u0026gt;()); for (auto currentNumber:nums) { int n = permutations.size(); for (int i = 0; i \u0026lt; n; i++) { vector\u0026lt;int\u0026gt; oldPermutation = permutations.front(); permutations.pop(); //添加currentNumber ，到所有的position for (int j = 0; j \u0026lt;= oldPermutation.size(); j++) { vector\u0026lt;int\u0026gt; newPermutations(oldPermutation); newPermutations.insert(newPermutations.begin() + j, currentNumber); if (newPermutations.size() == nums.size()) { result.push_back(newPermutations); } else { permutations.push(newPermutations); } } } } return result; }  递归的方法：\nvoid generatePermutationsRecursive(vector\u0026lt;int\u0026gt; \u0026amp;nums, int numsIndex, vector\u0026lt;int\u0026gt; \u0026amp;currentPermutation, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;result) { if (numsIndex == nums.size()) { result.push_back(currentPermutation); } else { for (int i = 0; i \u0026lt;= currentPermutation.size(); i++) { vector\u0026lt;int\u0026gt; newPermutation(currentPermutation); newPermutation.insert(newPermutation.begin() + i, nums[numsIndex]); generatePermutationsRecursive(nums, numsIndex + 1, newPermutation, result); } } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; generatePermutation(vector\u0026lt;int\u0026gt; \u0026amp;nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; vector\u0026lt;int\u0026gt; currentPermutation; generatePermutationsRecursive(nums, 0, currentPermutation, result); return result; }  Time Complexity : O(N * N !)\nSpace Complexity : O(N * N !)\n5、string permutation by changing case  给定字符串，保留原序列，只改变字母的大小写，求所有排列\n input:\t\u0026quot;ad52\u0026quot; ouput:\t\u0026quot;ad52\u0026quot; ,\u0026quot;Ad52\u0026quot;, \u0026quot;aD52\u0026quot;, \u0026quot;AD52\u0026quot;  input:\t\u0026quot;ab7c\u0026quot; ouput:\t\u0026quot;ab7c\u0026quot;, \u0026quot;Ab7c\u0026quot;,\u0026quot;aB7c\u0026quot;,\u0026quot;ab7C\u0026quot;,\u0026quot;AB7c\u0026quot;,\u0026quot;Ab7C\u0026quot;,\u0026quot;aB7C\u0026quot;,\u0026quot;AB7C\u0026quot;  code:\nvector\u0026lt;string\u0026gt; findLetterCaseStringPermutation(const string \u0026amp;str) { vector\u0026lt;string\u0026gt; permutations; if (str == \u0026quot;\u0026quot;) { return permutations; } permutations.push_back(str); for (int i = 0; i \u0026lt; str.length(); i++) { if (isalpha(str[i])) { int n = permutations.size(); for (int j = 0; j \u0026lt; n; j++) { vector\u0026lt;char\u0026gt; chs(permutations[j].begin(), permutations[j].end()); if (isupper(chs[i])) { chs[i] = tolower(chs[i]); } else { chs[i] = toupper(chs[i]); } permutations.push_back(string(chs.begin(), chs.end())); } } } return permutations; }  Time Complexity : O(N * 2^ N )\nSpace Complexity : O(N * 2^ N )\n6、balanced parentheses  给定N，求n对（）的合理的组合\n input: N=2 output:\t(()) ,()()  input: N=3 output:\t((())) ,()()(), (())(), ()(()), ((),())  code:\nstruct Parenthesese { string str; int openCount; int closeCount; Parenthesese(const string \u0026amp;str, int openCount, int closeCount) : str(str), openCount(openCount), closeCount(closeCount) {}; }; vector\u0026lt;string\u0026gt; generateValidParentheses(int num) { vector\u0026lt;string\u0026gt; result; queue\u0026lt;Parenthesese\u0026gt; queue; queue.push({\u0026quot;\u0026quot;, 0, 0}); while (!queue.empty()) { Parenthesese ps = queue.front(); queue.pop(); if (ps.openCount == num \u0026amp;\u0026amp; ps.closeCount == num) { result.push_back(ps.str); } else { if (ps.openCount \u0026lt; num) { queue.push({ps.str + \u0026quot;(\u0026quot;, ps.openCount + 1, ps.closeCount}); } if (ps.openCount \u0026gt; ps.closeCount) { queue.push({ps.str + \u0026quot;)\u0026quot;, ps.openCount, ps.closeCount + 1}); } } } return result; }  Time Complexity :Space Complexity : O(N * 2^ N )\n递归方法\nvoid generateValidParenthesesRecursive(int num, int openCount, int closeCount, int stringIndex, vector\u0026lt;char\u0026gt; \u0026amp;parenthesesString, vector\u0026lt;string\u0026gt; \u0026amp;result) { if (openCount == num \u0026amp;\u0026amp; closeCount == num) { result.push_back(string(parenthesesString.begin(), parenthesesString.end())); } else { if (openCount \u0026lt; num) { parenthesesString[stringIndex] = '('; generateValidParenthesesRecursive(num, openCount+1, closeCount , stringIndex + 1, parenthesesString, result); } if (openCount \u0026gt; closeCount) { parenthesesString[stringIndex] = ')'; generateValidParenthesesRecursive(num, openCount, closeCount + 1, stringIndex + 1, parenthesesString, result); } } } vector\u0026lt;string\u0026gt; generateValidParentheses2(int num) { vector\u0026lt;string\u0026gt; result; vector\u0026lt;char\u0026gt; parenthesesString(2 * num); generateValidParenthesesRecursive(num, 0, 0, 0, parenthesesString, result); return result; }  7、unique generalized abbreviations  没看懂题目\n 8、evaluate expression  给定只包含0-9和+ - *的表达式，计算表达式加上括号后所有合理的运算结果\n input:\t\u0026quot;1+2*3\u0026quot; output:\t7,9 explanations: 1+(2*3)=7, (1+2)*3=9  input:\t\u0026quot;2*3-4-5\u0026quot; output:\t8, -12, 7 ,-7 ,-3 explanations: 2*(3-(4-5)=8, 2*(3-4-5)=-12, 2*3-(4-5)=7, 2*(3-4)-5=-7, (2*3)-4-5=-3  code:\nvector\u0026lt;int\u0026gt; diffWaysToEvaluateExpression(const string \u0026amp;input) { vector\u0026lt;int\u0026gt; result; //有两个字符串a、b, 判断a字符串是否包含b字符串，用到string库中的find函数与npos参数。 //string::npos参数：npos 是一个常数，用来表示不存在的位置 if (input.find('+', 0) == string::npos \u0026amp;\u0026amp; input.find(\u0026quot;-\u0026quot;) == string::npos \u0026amp;\u0026amp; input.find(\u0026quot;*\u0026quot;) == string::npos) { } if (input.find(\u0026quot;+\u0026quot;) == string::npos \u0026amp;\u0026amp; input.find(\u0026quot;-\u0026quot;) == string::npos \u0026amp;\u0026amp; input.find(\u0026quot;*\u0026quot;) == string::npos) { result.push_back(stoi(input)); } else { for (int i = 0; i \u0026lt; input.length(); i++) { char chr = input[i]; if (!isdigit(chr)) { vector\u0026lt;int\u0026gt; leftParts = diffWaysToEvaluateExpression(input.substr(0, i)); vector\u0026lt;int\u0026gt; rightParts = diffWaysToEvaluateExpression(input.substr(i + 1)); for (auto part1:leftParts) { for (auto part2:rightParts) { if (chr == '+') { result.push_back(part1 + part2); } else if (chr == '-') { result.push_back(part1 - part2); } else if (chr == '*') { result.push_back(part1 * part2); } } } } } } return result; }  Time Complexity : 实际：估计：O(N * 2^ N )\nSpace Complexity : 实际：估计：O*( 2^ N )\n节省空间的方法：\n有大量重复计算的值，用哈希表存储中间值\nunordered_map\u0026lt;string, vector\u0026lt;int\u0026gt;\u0026gt; map = unordered_map\u0026lt;string, vector\u0026lt;int\u0026gt;\u0026gt;(); vector\u0026lt;int\u0026gt; diffWaysToEvaluateExpression2(const string \u0026amp;input) { if (map.find(input) != map.end()) { return map[input]; } vector\u0026lt;int\u0026gt; result; if (input.find(\u0026quot;+\u0026quot;) == string::npos \u0026amp;\u0026amp; input.find(\u0026quot;-\u0026quot;) == string::npos \u0026amp;\u0026amp; input.find(\u0026quot;*\u0026quot;) == string::npos) { result.push_back(stoi(input)); } else { for (int i = 0; i \u0026lt; input.length(); i++) { char chr = input[i]; if (!isdigit(chr)) { vector\u0026lt;int\u0026gt; leftParts = diffWaysToEvaluateExpression(input.substr(0, i)); vector\u0026lt;int\u0026gt; rightParts = diffWaysToEvaluateExpression(input.substr(i + 1)); for (auto part1:leftParts) { for (auto part2:rightParts) { if (chr == '+') { result.push_back(part1 + part2); } else if (chr == '-') { result.push_back(part1 - part2); } else if (chr == '*') { result.push_back(part1 * part2); } } } } } } map[input] = result; return result; }  9、structurally unique binary search trees  给定N，求节点值为1-n的二叉查找树\n code:\nvector\u0026lt;TreeNode *\u0026gt; findUniqueTreeRecursive(int start, int end) { vector\u0026lt;TreeNode *\u0026gt; result; if (start \u0026gt; end) { result.push_back(NULL); return result; } for (int i = start; i \u0026lt;= end; i++) { vector\u0026lt;TreeNode *\u0026gt; leftSubsets = findUniqueTreeRecursive(start, i - 1); vector\u0026lt;TreeNode *\u0026gt; rightSubsets = findUniqueTreeRecursive(i + 1, end); for (auto leftTree:leftSubsets) { for (auto rightTree :rightSubsets) { TreeNode *root = new TreeNode(i); root-\u0026gt;left = leftTree; root-\u0026gt;right = rightTree; result.push_back(root); } } } return result; } vector\u0026lt;TreeNode *\u0026gt; findUniqueTrees(int n) { if (n \u0026lt;= 0) { return vector\u0026lt;TreeNode *\u0026gt;(); } else { return findUniqueTreeRecursive(1, n); } }  Time Complexity : 实际：估计：O(N * 2^ N )\nSpace Complexity : 实际：估计：O*( 2^ N )\n10、count of structurally unique binary search tree  给定N，求节点值为1-n的二叉查找树的个数\n int countTrees(int n) { if (n \u0026lt;= 1) return 1; int count = 0; for (int i = 1; i \u0026lt;= n; i++) { int countOfLeftSubtrees = countTrees(i - 1); int countOfRightSubtrees = countTrees(n - i); count += countOfLeftSubtrees * countOfRightSubtrees; } return count; }  Time Complexity : 实际：估计：O(N * 2^ N )\nSpace Complexity : 实际：估计：O*( 2^ N )\n节省空间的方法：\ncode：\nunordered_map\u0026lt;int, int\u0026gt; map = unordered_map\u0026lt;int, int\u0026gt;(); int countTrees2(int n) { if (map.find(n) != map.end()) { return map[n]; } if (n \u0026lt;= 1) return 1; int count = 0; for (int i = 1; i \u0026lt;= n; i++) { int countOfLeftSubtrees = countTrees(i - 1); int countOfRightSubtrees = countTrees(n - i); count += countOfLeftSubtrees * countOfRightSubtrees; } map[n] = n; return count; }  Time Complexity : O( N ^ 2)\nSpace Complexity : O(N)\n","date":1590227615,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590227615,"objectID":"64af4b5691932d26c29b59facdf05fd5","permalink":"/code/pattern/subsets/","publishdate":"2020-05-23T17:53:35+08:00","relpermalink":"/code/pattern/subsets/","section":"code","summary":"子集","tags":["pattern"],"title":"pattern-11 Subsets","type":"code"},{"authors":[],"categories":[],"content":" 1、introduction 给定一组可以划分成两个部分的元素，要求我们求一部分的最小元素，另一部分的最大元素，用two heaps ：Min Heap和Max Heap，可以解决这类的问题，。\n2、find the median of a number stream  设计一个类，能够计算数据流中的中位数，类必须包含两个函数：\ninsertNum(int num) :存储数据\nfindMedian() : 返回所有存储进类的数据流的中位数\n如果数据为奇数个，则中位数为中间两个数之和\n code:\nclass MedianOfStream{ priority_queue\u0026lt;int\u0026gt; maxHeap; priority_queue\u0026lt;int,vector\u0026lt;int\u0026gt;,greater\u0026lt;int\u0026gt;\u0026gt; minHeap; void insertNum(int num){ //小数存储在大顶堆，大数存储在小顶堆 //大顶堆个数==[小顶堆，小顶堆+1] if(maxHeap.empty()||maxHeap.top()\u0026gt;=num){ maxHeap.push(num); } else{ minHeap.push(num); } if(maxHeap.size()\u0026gt;minHeap.size()+1){ minHeap.push(maxHeap.top()); maxHeap.pop(); }else if(maxHeap.size()\u0026lt;minHeap.size()){ maxHeap.push(minHeap.top()); minHeap.pop(); } } double findMedian(){ if(maxHeap.size()==minHeap.size()){ return (maxHeap.top()+minHeap.top())/2.0 } return maxHeap.top() } };  3、sliding window median  给定数组和K值，求所有长度为k的连续子数组的中位数\n input:\t[1, 2, -1, 3, 5]， k=2 output:\t[1.5, 0.5, 1.0, 4.0]  input:\t[1, 2, -1, 3, 5]， k=3 output:\t[1.0, 2.0, 3.0]  code:\n同上 + 滑动窗口 + 增加queue删除特定的值？  Time Complexity : O(N * K)\nSpace Complexity : O(K)\n4、maximun capital  给定一组投资项目，已知项目所需投资资金，项目盈利、初始资金、投资的项目个数，求最大剩余的资金\n先前投资的（盈利+本钱）可作为后续投资的资金 ,\n input:\tproject capitals:[0, 1 ,2] project profits:[1, 2, 3] initial capital:1 number of project:2 output:\t6 explanations： 1、先投资第2个(所需资金1，盈利2)项目。得到1+2=3(本金+盈利)投资基金 2、再投资第3个(所需资金2，盈利3)项目。得到3+3=6(本金+盈利)投资基金  input:\tproject capitals:[0, 1 ,2, 3] project profits:[1, 2, 3, 5] initial capital:0 number of project:3 output:\t8 explanations： 1、先投资第1个(所需资金0，盈利1)项目。得到0+1=1(本金+盈利)投资基金 2、再投资第2个(所需资金1，盈利2)项目。得到1+2=3(本金+盈利)投资基金 3、再投资第4个(所需资金3，盈利5)项目。得到3+5=8(本金+盈利)投资基金  code:\nstruct cmp_greater_capital { bool operator()(const pair\u0026lt;int, int\u0026gt; \u0026amp;x, const pair\u0026lt;int, int\u0026gt; \u0026amp;y) { return x.first \u0026gt; y.first; } }; struct cmp_smaller_profit { bool operator()(const pair\u0026lt;int, int\u0026gt; \u0026amp;x, const pair\u0026lt;int, int\u0026gt; \u0026amp;y) { return x.first \u0026lt; y.first; } }; int maximumCapitals(const vector\u0026lt;int\u0026gt; \u0026amp;capital, const vector\u0026lt;int\u0026gt; \u0026amp;profits, int numOfProject, int initialCapital) { int n = profits.size(); priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, cmp_greater_capital\u0026gt; minCapitalHeap; priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, cmp_smaller_profit\u0026gt; maxProfitHeap; for (int i = 0; i \u0026lt; n; i++) { minCapitalHeap.push(make_pair(capital[i], i)); } int result = initialCapital; for (int i = 0; i \u0026lt; numOfProject; i++) { while (!minCapitalHeap.empty() \u0026amp;\u0026amp; minCapitalHeap.top().first \u0026lt;= result) { auto capitalIndex = minCapitalHeap.top().second; minCapitalHeap.pop(); maxProfitHeap.push({profits[capitalIndex], capitalIndex}); } if (maxProfitHeap.empty()) { break; } result += maxProfitHeap.top().first; maxProfitHeap.pop(); } return result; }  Time Complexity : O(N log N + K log K)\nSpace Complexity : O(N)\n5、next interval  没看懂\n ","date":1590227599,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590227599,"objectID":"7d8cd4ef69071a25eab72d4c6832d595","permalink":"/code/pattern/two-heaps/","publishdate":"2020-05-23T17:53:19+08:00","relpermalink":"/code/pattern/two-heaps/","section":"code","summary":"双堆","tags":["pattern"],"title":"Pattern-10 Two Heaps","type":"code"},{"authors":[],"categories":[],"content":" 1、introduction  深度遍历，树的一种遍历方式，在遍历过程中用递归或栈记录所有父节点\n 2、binary tree path sum  给定二叉树和数S，判断是否有从根到叶子的路径，使得此路径所有节点的和等于S\n code:\nbool hasPath(TreeNode *root, int sum) { if (root == NULL) { return false; } if (root-\u0026gt;val == sum \u0026amp;\u0026amp; root-\u0026gt;left == NULL \u0026amp;\u0026amp; root-\u0026gt;right == NULL) { return true; } return hasPath(root-\u0026gt;left, sum - root-\u0026gt;val) || hasPath(root-\u0026gt;right, sum - root-\u0026gt;val); }  Time Complexity : O(N)\nSpace Complexity : O(N)\n3、all Paths for a sum  给定二叉树和数S，求所有从根到叶子的路径，路径所有节点的和等于S\n code:\nvoid findPathRecursive(TreeNode *currentNode, int sum, vector\u0026lt;int\u0026gt; \u0026amp;currentPath, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;allPaths) { if (currentNode == NULL) { return; } currentPath.push_back(currentNode-\u0026gt;val); if (currentNode-\u0026gt;val == sum \u0026amp;\u0026amp; currentNode-\u0026gt;left == NULL \u0026amp;\u0026amp; currentNode-\u0026gt;right == NULL) { allPaths.push_back(vector\u0026lt;int\u0026gt;(currentPath)); } else { findPathRecursive(currentNode-\u0026gt;left, sum - currentNode-\u0026gt;val, currentPath, allPaths); findPathRecursive(currentNode-\u0026gt;right, sum - currentNode-\u0026gt;val, currentPath, allPaths); } //为了回溯,删除currentNode currentPath.pop_back(); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; findPaths(TreeNode *root, int sum) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; allPaths; vector\u0026lt;int\u0026gt; currentPath; findPathRecursive(root, sum, currentPath, allPaths); return allPaths; }  Time Complexity : O(N^2)\nSpace Complexity : O(N logN)\n相似问题1：\n 求所有根到叶子的路径\n void findAllPathRecursive(TreeNode *currentNode, vector\u0026lt;int\u0026gt; \u0026amp;currentPath, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;allPaths) { if (currentNode == NULL) { return; } currentPath.push_back(currentNode-\u0026gt;val); if ( currentNode-\u0026gt;left == NULL \u0026amp;\u0026amp; currentNode-\u0026gt;right == NULL) { allPaths.push_back(vector\u0026lt;int\u0026gt;(currentPath)); }else{ findAllPathRecursive(currentNode-\u0026gt;left, currentPath, allPaths); findAllPathRecursive(currentNode-\u0026gt;right, currentPath, allPaths); } //为了回溯，删除currentNode, currentPath.pop_back(); } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; findAllPaths(TreeNode *root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; allPaths; vector\u0026lt;int\u0026gt; currentPath; findAllPathRecursive(root,currentPath, allPaths); return allPaths; }  相似问题2：\n 和最大的路径\n void findMaxPathRecursive(TreeNode *currentNode, int \u0026amp;currentSum, int \u0026amp;maxPathSum) { if (currentNode == NULL) { return; } currentSum += currentNode-\u0026gt;val; if (currentNode-\u0026gt;left == NULL \u0026amp;\u0026amp; currentNode-\u0026gt;right == NULL) { maxPathSum = max(maxPathSum, currentSum); } else { findMaxPathRecursive(currentNode-\u0026gt;left, currentSum, maxPathSum); findMaxPathRecursive(currentNode-\u0026gt;right, currentSum, maxPathSum); } //为了回溯，删除currentNode-val, currentSum -= currentNode-\u0026gt;val; } int findMaxPath(TreeNode *root) { int maxPathSum = INT_MIN; int currentSum = 0; findMaxPathRecursive(root, currentSum, maxPathSum); return maxPathSum; }  4、sum of path numbers  给定二叉树，节点值在 0 - 9，从根到叶子节点的代表一个整数，求所有路径之和\n code:\nint findRootToLeafPathNumbers(TreeNode *currentNode, int pathSum) { if (currentNode == NULL) { return 0; } pathSum = 10 * pathSum + currentNode-\u0026gt;val; if (currentNode-\u0026gt;left == NULL \u0026amp;\u0026amp; currentNode-\u0026gt;right == NULL) { return pathSum; } return findRootToLeafPathNumbers(currentNode-\u0026gt;left, pathSum) + findRootToLeafPathNumbers(currentNode-\u0026gt;right, pathSum); } int findSumOfPathNUmbers(TreeNode *root) { return findRootToLeafPathNumbers(root, 0); }  Time Complexity : O(N)\nSpace Complexity : O(N)\n5、path with given sequence  给定二叉树和序列，序列代表从根到叶子节点的路径，判断序列代表的路径是否在树上\n code:\nbool findPathRecursive(TreeNode *currentNode, const vector\u0026lt;int\u0026gt; \u0026amp;sequence, int sequenceIndex) { if (currentNode == NULL) { return false; } if (sequenceIndex \u0026gt;= sequence.size() || currentNode-\u0026gt;val != sequence[sequenceIndex]) { return false; } if (currentNode-\u0026gt;left == NULL \u0026amp;\u0026amp; currentNode-\u0026gt;right == NULL \u0026amp;\u0026amp; sequenceIndex == sequence.size() - 1) { return true; } return findPathRecursive(currentNode-\u0026gt;left, sequence, sequenceIndex + 1) || findPathRecursive(currentNode-\u0026gt;right, sequence, sequenceIndex + 1); } bool findPath(TreeNode *root, const vector\u0026lt;int\u0026gt; \u0026amp;sequence) { if (root == NULL) { return sequence.empty(); } return findPathRecursive(root, sequence, 0); }  Time Complexity : O(N)\nSpace Complexity : O(N)\n6、tree diameter  给定二叉树，求其diameter(直径)：两叶子结点之间的最长路径。最长直径可能不经过根节点。\n code:\nint calculateHeight(TreeNode *currentNode, int \u0026amp;treeDiameter) { if (currentNode == NULL) { return 0; } int leftTreeHeight = calculateHeight(currentNode-\u0026gt;left, treeDiameter); int rightTreeHeight = calculateHeight(currentNode-\u0026gt;right, treeDiameter); //currentNode的直径是左子树的高度+右子树的高度+1 int diameter = leftTreeHeight + rightTreeHeight + 1; //更新整个树的最大直径 treeDiameter = max(treeDiameter, diameter); return max(leftTreeHeight, rightTreeHeight) + 1; } int findDiameter(TreeNode *root) { int treeDiameter = 0; calculateHeight(root, treeDiameter); return treeDiameter; }  Time Complexity : O(N)\nSpace Complexity : O(N)\n7、path with max sum  给定二叉树， 求任意两节点之间路径的最大和，不必经过根节点\n code:\nint findMaximumPathSumRecursive(TreeNode *currentNode, int \u0026amp;globalMaximumSum) { if (currentNode == NULL) { return 0; } int maxPathSumFromLeft = findMaximumPathSumRecursive(currentNode-\u0026gt;left, globalMaximumSum); int maxPathSumFromRight = findMaximumPathSumRecursive(currentNode-\u0026gt;right, globalMaximumSum); //忽略sum=0 的path maxPathSumFromLeft = max(maxPathSumFromLeft, 0); maxPathSumFromRight = max(maxPathSumFromRight, 0); //当前节点的maximumPathSum int localMaximumSum = maxPathSumFromLeft + maxPathSumFromRight + currentNode-\u0026gt;val; //更新全局maximum Sum globalMaximumSum = max(globalMaximumSum, localMaximumSum); //经过当前节点所有路径中最大的Sum return max(maxPathSumFromLeft, maxPathSumFromRight) + currentNode-\u0026gt;val; } int findMaximumPathSum(TreeNode *root) { int globalMaximum = INT_MIN; findMaximumPathSumRecursive(root, globalMaximum); return globalMaximum; }  Time Complexity : O(N)\nSpace Complexity : O(N)\n","date":1590227516,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590227516,"objectID":"845b33d80ba849a2fb63ddec6e8686e1","permalink":"/code/pattern/tree-depth-first-search/","publishdate":"2020-05-23T17:51:56+08:00","relpermalink":"/code/pattern/tree-depth-first-search/","section":"code","summary":"DFS","tags":["pattern"],"title":"Pattern-9 Tree Depth First Search","type":"code"},{"authors":[],"categories":[],"content":" 1、introduction 广度遍历，树的一种遍历方式，常用来解决需要一层一层遍历的问题\n2、binary tree level order Traversal  层序遍历，每层单独放进数组，每层自顶向下，自左向右\n code:\n//struct TreeNode { // int val; // TreeNode *left; // TreeNode *right; // TreeNode(int x) : val(x), left(NULL), right(NULL) {} //}; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; traverse(TreeNode *root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; queue\u0026lt;TreeNode *\u0026gt; queue; if (root == NULL) { return result; } queue.push(root); while (!queue.empty()) { int levelSize = queue.size(); vector\u0026lt;int\u0026gt; currentLevel; for (int i = 0; i \u0026lt; levelSize; i++) { TreeNode *currentNode = queue.front(); queue.pop(); currentLevel.push_back(currentNode-\u0026gt;val); if (currentNode-\u0026gt;left != NULL) { queue.push(currentNode-\u0026gt;left); } if (currentNode-\u0026gt;right != NULL) { queue.push(currentNode-\u0026gt;right); } } result.push_back(currentLevel); } return result; }  Time Complexity : O(N)\nSpace Complexity : O(N)\n3、reverse level order traversal  层序遍历，每层单独放进数组，每层自底向上，自左向右\n code:\ndeque\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; traverse(TreeNode *root) { deque\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; queue\u0026lt;TreeNode *\u0026gt; queue; if (root == NULL) { return result; } queue.push(root); while (!queue.empty()) { int levelSize = queue.size(); vector\u0026lt;int\u0026gt; currentLevel; for (int i = 0; i \u0026lt; levelSize; i++) { TreeNode *currentNode = queue.front(); queue.pop(); currentLevel.push_back(currentNode-\u0026gt;val); if (currentNode-\u0026gt;left != NULL) { queue.push(currentNode-\u0026gt;left); } if (currentNode-\u0026gt;right != NULL) { queue.push(currentNode-\u0026gt;right); } } result.push_front(currentLevel); } return result; }  Time Complexity : O(N)\nSpace Complexity : O(N)\n4、zigzag traversal  层序遍历，每层单独放进数组，每层自顶向下，自左向右和自右向左交替进行\n code:\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; traverse(TreeNode *root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; queue\u0026lt;TreeNode *\u0026gt; queue; bool leftToRight = true; if (root == NULL) { return result; } queue.push(root); while (!queue.empty()) { int levelSize = queue.size(); vector\u0026lt;int\u0026gt; currentLevel(levelSize); for (int i = 0; i \u0026lt; levelSize; i++) { TreeNode *currentNode = queue.front(); queue.pop(); if (leftToRight) { currentLevel[i] = currentNode-\u0026gt;val; } else { currentLevel[levelSize - 1 - i] = currentNode-\u0026gt;val; } if (currentNode-\u0026gt;left != NULL) { queue.push(currentNode-\u0026gt;left); } if (currentNode-\u0026gt;right != NULL) { queue.push(currentNode-\u0026gt;right); } } result.push_back(currentLevel); leftToRight = !leftToRight; } return result; }  Time Complexity : O(N)\nSpace Complexity : O(N)\n5 、level averages in a binary tree  层序遍历，计算每一层的平均值\n code:\nvector\u0026lt;double\u0026gt; findLevelAverages(TreeNode *root) { vector\u0026lt;double\u0026gt; result; queue\u0026lt;TreeNode *\u0026gt; queue; if (root == NULL) { return result; } queue.push(root); while (!queue.empty()) { int levelSize = queue.size(); vector\u0026lt;int\u0026gt; currentLevel(levelSize); double levelSum = 0; for (int i = 0; i \u0026lt; levelSize; i++) { TreeNode *currentNode = queue.front(); queue.pop(); levelSum += currentNode-\u0026gt;val; if (currentNode-\u0026gt;left != NULL) { queue.push(currentNode-\u0026gt;left); } if (currentNode-\u0026gt;right != NULL) { queue.push(currentNode-\u0026gt;right); } } result.push_back(levelSum / levelSize); } return result; }  Time Complexity : O(N)\nSpace Complexity : O(N)\n相似问题1：\n 求每一层的最大值,和最小值\n code：\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; findLevelLargestAndSmallest(TreeNode *root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; queue\u0026lt;TreeNode *\u0026gt; queue; if (root == NULL) { return result; } queue.push(root); while (!queue.empty()) { int levelSize = queue.size(); vector\u0026lt;int\u0026gt; currentLevel(levelSize); int maxValue = INT_MIN; int minValue = INT_MAX; for (int i = 0; i \u0026lt; levelSize; i++) { TreeNode *currentNode = queue.front(); queue.pop(); maxValue = max(maxValue, currentNode-\u0026gt;val); minValue = min(minValue, currentNode-\u0026gt;val); if (currentNode-\u0026gt;left != NULL) { queue.push(currentNode-\u0026gt;left); } if (currentNode-\u0026gt;right != NULL) { queue.push(currentNode-\u0026gt;right); } } result.push_back({maxValue, minValue}); } return result; }  Time Complexity : O(N)\nSpace Complexity : O(N)\n6、minimum depth of a binary tree  求二叉树最小深度\n code:\nint findMinDepth(TreeNode *root) { if (root == NULL) { return 0; } int minimumTreeDepth=0; queue\u0026lt;TreeNode*\u0026gt; queue; queue.push(root); while (!queue.empty()) { minimumTreeDepth++; int levelSize = queue.size(); for (int i = 0; i \u0026lt; levelSize; i++) { TreeNode *currentNode = queue.front(); queue.pop(); if(currentNode-\u0026gt;left==NULL\u0026amp;\u0026amp;currentNode-\u0026gt;right==NULL){ //一旦遇到叶子节点，结束 return minimumTreeDepth; } if (currentNode-\u0026gt;left != NULL) { queue.push(currentNode-\u0026gt;left); } if (currentNode-\u0026gt;right != NULL) { queue.push(currentNode-\u0026gt;right); } } } return minimumTreeDepth; }  Time Complexity : O(N)\nSpace Complexity : O(N)\n相似问题：\n 求二叉树最大深度\n code:\nint findMaxDepth(TreeNode *root) { if (root == NULL) { return 0; } int maximumTreeDepth = 0; queue\u0026lt;TreeNode *\u0026gt; queue; queue.push(root); while (!queue.empty()) { maximumTreeDepth++; int levelSize = queue.size(); for (int i = 0; i \u0026lt; levelSize; i++) { TreeNode *currentNode = queue.front(); queue.pop(); //一直遍历 if (currentNode-\u0026gt;left != NULL) { queue.push(currentNode-\u0026gt;left); } if (currentNode-\u0026gt;right != NULL) { queue.push(currentNode-\u0026gt;right); } } } return maximumTreeDepth; }  Time Complexity : O(N)\nSpace Complexity : O(N)\n7、level order successor  求层序遍历某一节点的后继\n code:\nTreeNode *findSuccessor(TreeNode *root, int key) { if (root == NULL) { return NULL; } queue\u0026lt;TreeNode *\u0026gt; queue; queue.push(root); while (!queue.empty()) { TreeNode *currentNode = queue.front(); queue.pop(); if (currentNode-\u0026gt;left != NULL) { queue.push(currentNode-\u0026gt;left); } if (currentNode-\u0026gt;right != NULL) { queue.push(currentNode-\u0026gt;right); } if (currentNode-\u0026gt;val == key) { break; } } return queue.front(); }  Time Complexity : O(N)\nSpace Complexity : O(N)\n8、connect level order siblings  让所有节点指向其层序遍历的后继，每一层最后一个节点指向NULL\n code:\nstruct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode *next; TreeNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {} }; void connect(TreeNode *root) { if (root == NULL) { return; } queue\u0026lt;TreeNode *\u0026gt; queue; queue.push(root); while (!queue.empty()) { TreeNode *previousNode = NULL; int levelSize = queue.size(); for (int i = 0; i \u0026lt; levelSize; i++) { TreeNode *currentNode = queue.front(); queue.pop(); if (previousNode != NULL) { previousNode-\u0026gt;next = currentNode; } previousNode = currentNode; if (currentNode-\u0026gt;left != NULL) { queue.push(currentNode-\u0026gt;left); } if (currentNode-\u0026gt;right != NULL) { queue.push(currentNode-\u0026gt;right); } } } }  Time Complexity : O(N)\nSpace Complexity : O(N)\n9、connect all level order siblings  连接层序遍历的后继节点\n code:\nstruct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode *next; TreeNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {} }; void connect(TreeNode *root) { if (root == NULL) { return; } queue\u0026lt;TreeNode *\u0026gt; queue; queue.push(root); TreeNode *previousNode = NULL; TreeNode *currentNode = NULL; while (!queue.empty()) { int levelSize = queue.size(); for (int i = 0; i \u0026lt; levelSize; i++) { currentNode = queue.front(); queue.pop(); if (previousNode != NULL) { previousNode-\u0026gt;next = currentNode; } previousNode = currentNode; if (currentNode-\u0026gt;left != NULL) { queue.push(currentNode-\u0026gt;left); } if (currentNode-\u0026gt;right != NULL) { queue.push(currentNode-\u0026gt;right); } } } }  Time Complexity : O(N)\nSpace Complexity : O(N)\n10、right view of a binary tree  求二叉树从右侧看到的所有节点\n code:\nvector\u0026lt;TreeNode *\u0026gt; traverse(TreeNode *root) { vector\u0026lt;TreeNode *\u0026gt; result; queue\u0026lt;TreeNode *\u0026gt; queue; if (root == NULL) { return result; } queue.push(root); while (!queue.empty()) { int levelSize = queue.size(); vector\u0026lt;int\u0026gt; currentLevel(levelSize); for (int i = 0; i \u0026lt; levelSize; i++) { TreeNode *currentNode = queue.front(); queue.pop(); //如果是这一层的最后一个节点放入result; if (i == levelSize - 1) { result.push_back(currentNode); } if (currentNode-\u0026gt;left != NULL) { queue.push(currentNode-\u0026gt;left); } if (currentNode-\u0026gt;right != NULL) { queue.push(currentNode-\u0026gt;right); } } } return result; }  Time Complexity : O(N)\nSpace Complexity : O(N)\n相似问题：\n 求二叉树从左侧看到的所有节点\n vector\u0026lt;TreeNode *\u0026gt; traverse(TreeNode *root) { vector\u0026lt;TreeNode *\u0026gt; result; queue\u0026lt;TreeNode *\u0026gt; queue; if (root == NULL) { return result; } queue.push(root); while (!queue.empty()) { int levelSize = queue.size(); vector\u0026lt;int\u0026gt; currentLevel(levelSize); for (int i = 0; i \u0026lt; levelSize; i++) { TreeNode *currentNode = queue.front(); queue.pop(); //如果是这一层的第一个节点放入result; if (i == 0) { result.push_back(currentNode); } if (currentNode-\u0026gt;left != NULL) { queue.push(currentNode-\u0026gt;left); } if (currentNode-\u0026gt;right != NULL) { queue.push(currentNode-\u0026gt;right); } } } return result; }  Time Complexity : O(N)\nSpace Complexity : O(N)\n11、tree boundary  逆时针输出二叉树的所有边界节点\n code:\nvector\u0026lt;TreeNode *\u0026gt; findLeavesDFS(TreeNode *root) { vector\u0026lt;TreeNode *\u0026gt; leaves; stack\u0026lt;TreeNode *\u0026gt; stack; stack.push(root); while (!stack.empty()) { TreeNode *currentNode = stack.top(); stack.pop(); if (currentNode-\u0026gt;left == NULL \u0026amp;\u0026amp; currentNode-\u0026gt;right == NULL) { leaves.push_back(currentNode); } if (currentNode-\u0026gt;right != NULL) { stack.push(currentNode-\u0026gt;right); } if (currentNode-\u0026gt;left != NULL) { stack.push(currentNode-\u0026gt;left); } } return leaves; } vector\u0026lt;TreeNode *\u0026gt; findBoundary(TreeNode *root) { if (root == NULL) { return vector\u0026lt;TreeNode *\u0026gt;(); } vector\u0026lt;TreeNode *\u0026gt; result; vector\u0026lt;TreeNode *\u0026gt; leftView; deque\u0026lt;TreeNode *\u0026gt; rightView; queue\u0026lt;TreeNode *\u0026gt; queue; queue.push(root); while (!queue.empty()) { int levelSize = queue.size(); vector\u0026lt;int\u0026gt; currentLevel(levelSize); for (int i = 0; i \u0026lt; levelSize; i++) { TreeNode *currentNode = queue.front(); queue.pop(); //如果是这一层的最后一个节点放入result; if (currentNode-\u0026gt;left == NULL \u0026amp;\u0026amp; currentNode-\u0026gt;right == NULL) { continue; } else if (i == 0) { leftView.push_back(currentNode); } else if (i == levelSize - 1) { rightView.push_front(currentNode); } if (currentNode-\u0026gt;left != NULL) { queue.push(currentNode-\u0026gt;left); } if (currentNode-\u0026gt;right != NULL) { queue.push(currentNode-\u0026gt;right); } } } vector\u0026lt;TreeNode *\u0026gt; leaves = findLeavesDFS(root); result.insert(result.end(), leftView.begin(), leftView.end()); result.insert(result.end(), leaves.begin(), leaves.end()); copy(begin(rightView), end(rightView), back_inserter(result)); return result; }  Time Complexity : O(N)\nSpace Complexity : O(N)\n","date":1590227419,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590227419,"objectID":"b8dd3e5932a548178f82a5a02813c536","permalink":"/code/pattern/tree-breadth-first-search/","publishdate":"2020-05-23T17:50:19+08:00","relpermalink":"/code/pattern/tree-breadth-first-search/","section":"code","summary":"BFS","tags":["pattern"],"title":"Pattern-8 Tree Breadth First Search","type":"code"},{"authors":[],"categories":[],"content":" 1、introduction 解决原地逆转链表的问题\n2、reverse a linkedlist  逆转链表\n code:\nListNode *reverse(ListNode *head) { ListNode *current = head; ListNode *prev = NULL; ListNode *next = NULL; while (current != NULL) { next = current-\u0026gt;next; current-\u0026gt;next = prev; prev = current; current = next; } return prev; }  Time Complexity : O(N)\nSpace Complexity : O(1)\n3、reverse a sub-list  逆转链表第p个至第q个之间的元素\n code:\nListNode *reverse(ListNode *head, int p, int q) { if (p == q) { return head; } ListNode *current = head; ListNode *prev = NULL; //让current指向pth Node for (int i = 0; current != NULL \u0026amp;\u0026amp; i \u0026lt; p - 1; i++) { prev = current; current = current-\u0026gt;next; } //第p-1个元素 ListNode *lastNodeOfFirstPart = prev; //逆转部分最后一个 ListNode *lastNodeOfSubList = current; ListNode *next = NULL; for (int i = 0; current != NULL \u0026amp;\u0026amp; i \u0026lt; q - p + 1; i++) { next = current-\u0026gt;next; current-\u0026gt;next = prev; prev = current; current = next; } //链接第一部分 if (lastNodeOfFirstPart != NULL) { lastNodeOfFirstPart-\u0026gt;next = prev; } else { head = prev; } //链接后一部分 lastNodeOfSubList-\u0026gt;next = current; return head; }  Time Complexity : O(N)\nSpace Complexity : O(1)\n相似问题1\n 逆转前k个元素\n code：\nreverse(head, 1 ,n)  相似问题2\n 偶数个元素，逆转前1/2，后1/2；\n奇数个元素，逆转前1/2，后1/2，中间不变；\n 偶数 reverse(head, 1 ,n/2) reverse(head, 1/2 + 1 ,n) 奇数 reverse(head, 1 ,n/2) reverse(head, 1/2 + 2 ,n)  4、reverse every k-element sub-list  给定链表和整数K，每次逆转K个元素\n code：\nListNode *reverse(ListNode *head, int k) { if (k \u0026lt;= 1 || head == NULL) { return head; } ListNode *current = head; ListNode *prev = NULL; while (true) { ListNode *lastNodeOfPreviousPart = prev; ListNode *lastNodeOfSubList = current; ListNode *next = NULL; for (int i = 0; current != NULL \u0026amp;\u0026amp; i \u0026lt; k; i++) { next = current-\u0026gt;next; current-\u0026gt;next = prev; prev = current; current = next; } //链接第一部分 if (lastNodeOfPreviousPart != NULL) { lastNodeOfPreviousPart-\u0026gt;next = prev; } else { head = prev; } //链接后一部分 lastNodeOfSubList-\u0026gt;next = current; if (current == NULL) { break; } prev = lastNodeOfSubList; } return head; }  Time Complexity : O(N)\nSpace Complexity : O(1)\n5、reverse alternating k-element sub-list  给定链表和整数K，每次交替逆转K个元素，如果最后要逆转的部分小于k，也要逆转\n code:\nListNode *reverse(ListNode *head, int k) { if (k \u0026lt;= 1 || head == NULL) { return head; } ListNode *current = head; ListNode *prev = NULL; while (true) { ListNode *lastNodeOfPreviousPart = prev; ListNode *lastNodeOfSubList = current; ListNode *next = NULL; for (int i = 0; current != NULL \u0026amp;\u0026amp; i \u0026lt; k; i++) { next = current-\u0026gt;next; current-\u0026gt;next = prev; prev = current; current = next; } if (lastNodeOfPreviousPart != NULL) { lastNodeOfPreviousPart-\u0026gt;next = prev; } else { head = prev; } lastNodeOfSubList-\u0026gt;next = current; for (int i = 0; current != NULL \u0026amp;\u0026amp; i \u0026lt; k; i++) { prev = current; current = current-\u0026gt;next; } if (current == NULL) { break; } } return head; }  Time Complexity : O(N)\nSpace Complexity : O(1)\n6、rotate a linkedlist  给定链表和整数K，循环将前k元素移到后面\n code:\nListNode *rotate(ListNode *head, int rotations) { if (head == NULL || head-\u0026gt;next == NULL || rotations \u0026lt;= 0) { return head; } ListNode *lastNode = head; int listLength = 1; while (lastNode-\u0026gt;next != NULL) { lastNode = lastNode-\u0026gt;next; listLength++; } lastNode-\u0026gt;next = head; rotations %= listLength; int skipLength = listLength - rotations; ListNode *lastNodeOfRotatedList = head; for (int i = 0; i \u0026lt; skipLength - 1; i++) { lastNodeOfRotatedList = lastNodeOfRotatedList-\u0026gt;next; } head = lastNodeOfRotatedList-\u0026gt;next; lastNodeOfRotatedList-\u0026gt;next = NULL; return head; }  Time Complexity : O(N)\nSpace Complexity : O(1)\n","date":1590227364,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590227364,"objectID":"6f5d9dd7bb718857a548113a8c32a2df","permalink":"/code/pattern/in-place-reversal-of-a-linked-list/","publishdate":"2020-05-23T17:49:24+08:00","relpermalink":"/code/pattern/in-place-reversal-of-a-linked-list/","section":"code","summary":"链表翻转","tags":["pattern"],"title":"Pattern-7 In Place Reversal of a Linked List","type":"code"},{"authors":[],"categories":[],"content":" 1、introduction  常用来解决数组元素的值在一定范围内的问题\n 2、cyclic sort  给定长度为n，所有元素的值在[1,n]内，不重复。原地排序\n input:\t[3, 1, 5, 4, 2] output:\t[1, 2, 3, 4, 5]  input:\t[2, 6, 4, 3, 1, 5] output:\t[1, 2, 3, 4, 5, 6]  code:\nvoid mySwap(vector\u0026lt;int\u0026gt; \u0026amp;arr,int i,int j){ int temp=arr[i]; arr[i]=arr[j]; arr[j]=temp; } void sort(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int i = 0; //如果nums[i]不在正确位置上，将交换到正确位置上 while (i \u0026lt; nums.size()) { //j代表num[i]的正确索引位置 int j = nums[i] - 1; if (nums[i] != nums[j]) { mySwap(nums,j,i); //swap(nums[j], nums[i]); } else { i++; } } }  Time Complexity : O(N)\nSpace Complexity : O(1)\n3、find the Missing number  给定长度为n的数组，元素值的范围在[0,n], 不重复，求未包含在其中的数字\n input:\t[4, 0, 3, 1] output:\t2  input:\t[8, 3, 5, 2, 4, 6, 0, 1] output:\t7  code:\nvoid mySwap(vector\u0026lt;int\u0026gt; \u0026amp;arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } int findMissingNumber(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int i = 0; while (i \u0026lt; nums.size()) { //把nums[i]放到到索引为nums[i]的位置上， //如 nums[6] -\u0026gt; index=nums[6] // 忽略n if (nums[i] \u0026lt; nums.size() \u0026amp;\u0026amp; nums[i] != nums[nums[i]]) { //交换索引位置上的值 //也就是swap(nums[i], nums[nums[i]]); mySwap(nums, i, nums[i]); } else { i++; } } for (int i = 0; i \u0026lt; nums.size(); i++) { if (nums[i] != i) { return i; } } return nums.size(); }  Time Complexity : O(N)\nSpace Complexity : O(1)\n4、find all missing numbers  给定长度为n的数组，元素值的范围在[1,n], 有重复，求所有未包含在其中的数字\n input:\t[2, 3, 1, 8, 2, 3, 5, 1] output:\t[4, 6, 7]  input:\t[2, 4, 1, 2] output:\t[3]  void mySwap(vector\u0026lt;int\u0026gt; \u0026amp;arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } vector\u0026lt;int\u0026gt; findMissingNumbers(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int i = 0; vector\u0026lt;int\u0026gt; missingNumbers; while (i \u0026lt; nums.size()) { //nums[i] - 1 代表num[i]的正确索引位置 if (nums[i] != nums[nums[i] - 1]) { mySwap(nums, i, nums[i] - 1); //swap(nums[i],nums[nums[i] - 1]); } else { i++; } } for (int i = 0; i \u0026lt; nums.size(); i++) { if (nums[i] != i + 1) { missingNumbers.push_back(i + 1); } } return missingNumbers; }  Time Complexity : O(N)\nSpace Complexity : O(1)\n5、find the duplicate number  给定长度为n+1的数组，元素值的范围在[1,n], 只有一个元素有重复，可多次重复，求重复的数字\n input:\t[1, 4, 4, 3, 2] output:\t4  input:\t[2, 4, 4, 1, 4] output:\t4  code:\nvoid mySwap(vector\u0026lt;int\u0026gt; \u0026amp;arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } int findNUmber(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int i = 0; while (i \u0026lt; nums.size()) { if (nums[i] != i + 1) { if (nums[i] != nums[nums[i] - 1]) { mySwap(nums, i, nums[i] - 1); //swap(nums[i],nums[nums[i] - 1]); } else { //在交换了一次重复值后，再次碰到，一定是重复的元素 return nums[i]; } } else { i++; } } return -1; }  Time Complexity : O(N)\nSpace Complexity : O(1)\n相似问题：\n 上述问题，不能改变数组，且要求O(1)空间\n用快慢指针\n code：\nint findStart(const vector\u0026lt;int\u0026gt; \u0026amp;arr, int cycleLenghth) { int pointer1 = arr[0]; int pointer2 = arr[0]; while (cycleLenghth \u0026gt; 0) { pointer2 = arr[pointer2]; cycleLenghth--; } while (pointer1 != pointer2) { pointer1 = arr[pointer1]; pointer2 = arr[pointer2]; } return pointer1; } int findDuplicate(const vector\u0026lt;int\u0026gt; \u0026amp;arr) { int fast = 0; int slow = 0; do { slow = arr[slow]; fast = arr[arr[fast]]; } while (slow != fast); int current = arr[slow]; int cycleLength = 0; do { current = arr[current]; cycleLength++; } while (current != arr[slow]); return findStart(arr, cycleLength); }  Time Complexity : O(N)\nSpace Complexity : O(1)\n6、find all duplicate numbers  给定长度为n的数组，元素值的范围在[1,n], 有多个有重复，求所有重复的数字，不使用额外空间\n input:\t[3, 4, 4, 5, 5] output:\t[5, 4]  input:\t[5, 4, 7, 2, 3, 5, 3] output:\t[3, 5]  code:\nvoid mySwap(vector\u0026lt;int\u0026gt; \u0026amp;arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } vector\u0026lt;int\u0026gt; findNumbers(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int i = 0; vector\u0026lt;int\u0026gt; duplicates; while (i \u0026lt; nums.size()) { if (nums[i] != nums[nums[i] - 1]) { mySwap(nums, i, nums[i] - 1); //swap(nums[i],nums[nums[i] - 1]); } else { i++; } } for (int i = 0; i \u0026lt; nums.size(); i++) { if (nums[i] != i + 1) { duplicates.push_back(nums[i]); } } return duplicates; }  Time Complexity : O(N)\nSpace Complexity : O(1)\n7、find the corrupt pair  给定长度为n的数组，元素值的范围在[1,n], 一个元素有重复且重复一次，求重复的数字和缺失的数字\n input:\t[3, 1, 2, 5, 2] output:\t[2, 4] explanation: 2重复，4缺失  input:\t[3, 1, 2, 3, 6, 4] output:\t[3, 5] explanation: 3重复，5缺失  code:\nvector\u0026lt;int\u0026gt; findNumbers(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int i = 0; while (i \u0026lt; nums.size()) { if (nums[i] != nums[nums[i] - 1]) { mySwap(nums, i, nums[i] - 1); //swap(nums[i],nums[nums[i] - 1]); } else { i++; } } for (int i = 0; i \u0026lt; nums.size(); i++) { if (nums[i] != i + 1) { return vector\u0026lt;int\u0026gt;{nums[i], i + 1}; } } return vector\u0026lt;int\u0026gt;{-1, -1}; }  Time Complexity : O(N)\nSpace Complexity : O(1)\n8、find the smallest missing positive number  给定整数数组，元素值无范围限制，求最小缺失的正整数\n input:\t[-3, 1, 5, 4, 2] output:\t3  input:\t[3, -2, 0, 1, 2] output:\t4  input:\t[3, 2, 5, 1] output:\t4  code:\nvoid mySwap(vector\u0026lt;int\u0026gt; \u0026amp;arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } int findNumber(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int i = 0; while (i \u0026lt; nums.size()) { if (nums[i] \u0026gt; 0 \u0026amp;\u0026amp; nums[i] \u0026lt;= nums.size() \u0026amp;\u0026amp; nums[i] != nums[nums[i] - 1]) { mySwap(nums, i, nums[i] - 1); //swap(nums[i],nums[nums[i] - 1]); } else { i++; } } for (int i = 0; i \u0026lt; nums.size(); i++) { if (nums[i] != i + 1) { return i + 1; } } return nums.size() + 1; }  Time Complexity : O(N)\nSpace Complexity : O(1)\n9、find the first k missing positive numbers  给定整数数组和K值，元素值无范围限制，求最小的前K个缺失的正整数\n input:\t[3, -1, 4, 5, 5] ,K=3 output:\t[1, 2, 6]  input:\t[2, 3 ,4] ,K=3 output:\t[1, 5, 6]  input:\t[-2, -3 ,4] ,K=2 output:\t[1, 2]  code:\nvoid mySwap(vector\u0026lt;int\u0026gt; \u0026amp;arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } vector\u0026lt;int\u0026gt; findNumbers(vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) { int i = 0; vector\u0026lt;int\u0026gt; missingNUmbers; unordered_set\u0026lt;int\u0026gt; extraNumbers; while (i \u0026lt; nums.size()) { if (nums[i] \u0026gt; 0 \u0026amp;\u0026amp; nums[i] \u0026lt;= nums.size() \u0026amp;\u0026amp; nums[i] != nums[nums[i] - 1]) { mySwap(nums, i, nums[i] - 1); //swap(nums[i],nums[nums[i] - 1]); } else { i++; } } for (int i = 0; i \u0026lt; nums.size() \u0026amp;\u0026amp; missingNUmbers.size() \u0026lt; k; i++) { if (nums[i] != i + 1) { missingNUmbers.push_back(i + 1); extraNumbers.insert(nums[i]); } } for (int i = 1; missingNUmbers.size() \u0026lt; k; i++) { int candidateNumber = i + nums.size(); if (extraNumbers.find(candidateNumber) == extraNumbers.end()) { missingNUmbers.push_back(candidateNumber); } } return missingNUmbers; }  Time Complexity : O(N + K]\nSpace Complexity : O(K)\n","date":1590227304,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590227304,"objectID":"1e4c97e3f3338b163ad3c02fef0e77c5","permalink":"/code/pattern/cyclic-sort/","publishdate":"2020-05-23T17:48:24+08:00","relpermalink":"/code/pattern/cyclic-sort/","section":"code","summary":"循环排序","tags":["pattern"],"title":"Pattern-6 Cyclic Sort","type":"code"},{"authors":[],"categories":[],"content":" 1、introduction 常用来解决重叠区间问题，如求重叠的区间或合并有重叠的区间\n区间 a , b 的6种重叠方式\n2、merge interval  给定一组区间，合并重叠的区间\n code:\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; merge(const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;intervals) { if (intervals.size() \u0026lt; 1) { return intervals; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; mergedResult; mergedResult.push_back(intervals[0]); for (int i = 1; i \u0026lt; intervals.size(); i++) { if (intervals[i][0] \u0026lt;= mergedResult.back()[1]) { mergedResult.back()[1] = max(mergedResult.back()[1], intervals[i][1]); } else { mergedResult.push_back(intervals[i]); } } return mergedResult; }  Time Complexity : O(N * log N )\nSpace Complexity : O(N)\n相似问题：\n 判断一组区间是否重合\n input:\t[[1, 4], [2, 5], [7, 9]] output:\ttrue  code：\nbool isMerge(const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;intervals) { if (intervals.size() \u0026lt; 1) { return false; } vector\u0026lt;int\u0026gt; temp=intervals[0]; for (int i = 1; i \u0026lt; intervals.size(); i++) { if (intervals[i][0] \u0026lt;= temp[1]) { return true; } else { temp=intervals[i]; } } return false; }  3、insert interval  给定一组不重叠区间（按照起始位置排序）和一个区间，合并，生成新的不重叠的区间\n code:\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; insertInterval(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; intervals, vector\u0026lt;int\u0026gt; newInterval) { if (intervals.empty()) { return vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;{newInterval}; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; int i = 0; while (i \u0026lt; intervals.size() \u0026amp;\u0026amp; intervals[i][1] \u0026lt; newInterval[0]) { result.push_back(intervals[i]); i++; } while (i \u0026lt; intervals.size() \u0026amp;\u0026amp; intervals[i][0] \u0026lt;= newInterval[1]) { newInterval[0] = min(intervals[i][0], newInterval[0]); newInterval[1] = max(intervals[i][1], newInterval[1]); i++; } result.push_back(newInterval); while (i \u0026lt; intervals.size()) { result.push_back(intervals[i]); i++; } return result; }  Time Complexity : O(N)\nSpace Complexity : O(N)\n4、intervals intersection  给定两组区间（每组不重叠，按起始位置排序），求其相交区间\n code:\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; merge(const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;arr1, const vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;arr2) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; int i = 0, j = 0; while (i \u0026lt; arr1.size() \u0026amp;\u0026amp; j \u0026lt; arr2.size()) { if ((arr1[i][0] \u0026gt;= arr2[j][0] \u0026amp;\u0026amp; arr1[i][0] \u0026lt;= arr2[j][1]) || (arr2[j][0] \u0026gt;= arr1[i][0] \u0026amp;\u0026amp; arr2[j][0] \u0026lt;= arr1[i][1])) { result.push_back({max(arr1[i][0], arr2[j][0]), min(arr1[i][1], arr2[j][1])}); } if (arr1[i][1] \u0026lt; arr2[j][1]) { i++; } else { j++; } } return result; }  Time Complexity : O(N + M)\nSpace Complexity : O(1)\n5、conflicting appointments  给定一组区间代表一组会议持续时间，判断某人是否能够参加所有的会议\n input:\t[[1, 4], [2, 5], [7, 9]] output:\tfalse  input:\t[[6, 7], [2, 4], [8, 12]] output:\ttrue  input:\t[[4, 5], [2, 3], [3, 6]] output:\tfalse  code:\nbool canAttendAllAppointments(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;nums) { sort(nums.begin(), nums.end()); for (int i = 1; i \u0026lt; nums.size(); i++) { if (nums[i][0] \u0026lt; nums[i - 1][1]) { return false; } } return true; }  Time Complexity : O(N * log N )\nSpace Complexity : O(N)\n相似问题\n 给定一组区间代表一组会议持续时间，求所有冲突的会议\n 待写  6、minimum meeting rooms  给定一组区间代表一些会议，求能举办这些会议的最小会议室\n code:\nstruct cmp_greater { bool operator()(const vector\u0026lt;int\u0026gt; \u0026amp;x, const vector\u0026lt;int\u0026gt; \u0026amp;y) { return x[1] \u0026gt; y[1]; } }; int minimumMeetingRooms(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;meetings) { if (meetings.empty()) { return 0; } sort(meetings.begin(), meetings.end()); int minRooms = 0; priority_queue\u0026lt;vector\u0026lt;int\u0026gt;, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;, cmp_greater\u0026gt; minHeap; for (auto m: meetings) { while (!minHeap.empty() \u0026amp;\u0026amp; m[0] \u0026gt;= minHeap.top()[1]) { minHeap.pop(); } minHeap.push(m); minRooms = max(minRooms, (int) minHeap.size()); } return minRooms; }  Time Complexity : O(N * log N )\nSpace Complexity : O(N)\n7、maximum cpu load  没看懂\n 8、employee free time  待看\n ","date":1590227276,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590227276,"objectID":"fe65cdf0d602d9e51001b6790bd8ce2e","permalink":"/code/pattern/merge-intervals/","publishdate":"2020-05-23T17:47:56+08:00","relpermalink":"/code/pattern/merge-intervals/","section":"code","summary":"区间合并","tags":["pattern"],"title":"Pattern-5 Merge Intervals","type":"code"},{"authors":[],"categories":[],"content":" 1、introduction 移动两个速度不同的指针，常在环形数组和链表问题中使用。\n2、linkedlist cycle  判断链表是否有环\n code:\nbool hasCycle(ListNode *head) { ListNode *fast = head; ListNode *slow = head; while (fast != NULL \u0026amp;\u0026amp; fast-\u0026gt;next != NULL) { fast = fast-\u0026gt;next-\u0026gt;next; slow = slow-\u0026gt;next; if (slow == fast) { return true; } } return false; }  Time Complexity : O(N)\nSpace Complexity : O(1)\n相似问题：\n 求带环链表环的长度\n code：\nint calculateLength(ListNode *slow) { ListNode *current = slow; int cycleLength = 0; do { current = current-\u0026gt;next; cycleLength++; } while (current != slow); return cycleLength; } int findCycleLength(ListNode *head) { ListNode *fast = head; ListNode *slow = head; while (fast != NULL \u0026amp;\u0026amp; fast-\u0026gt;next != NULL) { fast = fast-\u0026gt;next-\u0026gt;next; slow = slow-\u0026gt;next; if (slow == fast) { return calculateLength(slow); } } return 0; }  Time Complexity : O(N)\nSpace Complexity : O(1)\n3、start of linkedlist cycle  求带环链表的起点\n code:\nListNode *findStart(ListNode *head, int cycleLenghth) { ListNode *pointer1 = head; ListNode *pointer2 = head; while (cycleLenghth \u0026gt; 0) { pointer2 = pointer2-\u0026gt;next; cycleLenghth--; } while (pointer1 != pointer2) { pointer1 = pointer1-\u0026gt;next; pointer2 = pointer2-\u0026gt;next; } return pointer1; } int calculateLength(ListNode *slow) { ListNode *current = slow; int cycleLength = 0; do { current = current-\u0026gt;next; cycleLength++; } while (current != slow); return cycleLength; } ListNode *findCycleStart(ListNode *head) { int cycleLength = 0; ListNode *fast = head; ListNode *slow = head; while (fast != NULL \u0026amp;\u0026amp; fast-\u0026gt;next != NULL) { fast = fast-\u0026gt;next-\u0026gt;next; slow = slow-\u0026gt;next; if (slow == fast) { cycleLength = calculateLength(slow); break; } } return findStart(head, cycleLength); }  Time Complexity : O(N)\nSpace Complexity : O(1)\n4、happy number  判断整数是否是happy number\n快乐数（happy number）有以下的特性：在给定的进位制下，该数字所有数位(digits)的平方和，得到的新数再次求所有数位的平方和，如此重复进行，最终结果必为1\n input:\t23 output:\ttrue explanations: 2*2 + 3*3 = 4 + 9 = 13 1*1 + 3*3 = 1 + 9 = 10 1*1 + 0*0 = 1 + 0 = 1  input:\t12 output:\tfalse explanations: 5-\u0026gt;25-\u0026gt;29-\u0026gt;85-\u0026gt;89-\u0026gt;145-\u0026gt;42-\u0026gt;20-\u0026gt;4-\u0026gt;16-\u0026gt;37-\u0026gt;58-\u0026gt;89 89重复  code：\nint findSquareSum(int num) { int sum = 0; int digit; while (num \u0026gt; 0) { digit = num % 10; sum += digit * digit; num /= 10; } return sum; } int find(int num) { //如果不是happy number，在不断生成新数中，定有重复 int slow = num; int fast = num; do { slow = findSquareSum(slow); fast = findSquareSum(findSquareSum(fast)); } while (slow != fast); return slow == 1; }  Time Complexity : O(log N)\nSpace Complexity : O(1)\n5、middle of the linkedlist  求链表的中间节点\n input:\t1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5-\u0026gt; NULL output:\t3  input:\t1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5-\u0026gt; 6 -\u0026gt; NULL output:\t4  code:\nListNode *findMiddle(ListNode *head) { ListNode *fast = head; ListNode *slow = head; while (fast != NULL \u0026amp;\u0026amp; fast-\u0026gt;next != NULL) { fast = fast-\u0026gt;next-\u0026gt;next; slow = slow-\u0026gt;next; } return slow; }  Time Complexity : O(N)\nSpace Complexity : O(1)\n6、palindrome linkedlist  判断链表是否对称\n input:\t2 -\u0026gt; 4 -\u0026gt; 6 -\u0026gt; 4 -\u0026gt; 2-\u0026gt; NULL output:\ttrue  input:\t2 -\u0026gt; 4 -\u0026gt; 6 -\u0026gt; 4 -\u0026gt; 2 -\u0026gt; 2 -\u0026gt; NULL output:\tfalse  code:\nListNode *reverse(ListNode *head) { ListNode *prev = NULL; while (head != NULL) { ListNode *next = head-\u0026gt;next; head-\u0026gt;next = prev; prev = head; head = next; } return prev; } bool isPalindrome(ListNode *head) { if (head == NULL || head-\u0026gt;next == NULL) { return true; } ListNode *fast = head; ListNode *slow = head; while (fast != NULL \u0026amp;\u0026amp; fast-\u0026gt;next != NULL) { fast = fast-\u0026gt;next-\u0026gt;next; slow = slow-\u0026gt;next; } ListNode *headSecondHalf = reverse(slow); ListNode *copyHeadSecondHalf = headSecondHalf; while (head != NULL \u0026amp;\u0026amp; headSecondHalf != NULL) { if (head-\u0026gt;val != headSecondHalf-\u0026gt;val) { break; } head = head-\u0026gt;next; headSecondHalf = headSecondHalf-\u0026gt;next; } reverse(copyHeadSecondHalf); if (head == NULL || headSecondHalf == NULL) { return true; } return false; }  Time Complexity : O(N)\nSpace Complexity : O(1)\n7、rearrange a linkedlist  给定一个单链表 L：L0→L1→…→Ln-1→Ln ， 将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n input:\t2 -\u0026gt; 4 -\u0026gt; 6 -\u0026gt; 8 -\u0026gt; 10-\u0026gt; 12 -\u0026gt; NULL output:\t2 -\u0026gt; 12 -\u0026gt; 4 -\u0026gt; 10-\u0026gt; 6 -\u0026gt; 8 -\u0026gt; NULL  input:\t2 -\u0026gt; 4 -\u0026gt; 6 -\u0026gt; 8 -\u0026gt; 10 -\u0026gt; NULL output:\t2 -\u0026gt; 10 -\u0026gt; 4 -\u0026gt; 8 -\u0026gt; 6 -\u0026gt; NULL  code:\nListNode *reverse(ListNode *head) { ListNode *prev = NULL; while (head != NULL) { ListNode *next = head-\u0026gt;next; head-\u0026gt;next = prev; prev = head; head = next; } return prev; } void reOrder(ListNode *head) { if (head == NULL || head-\u0026gt;next == NULL) { return; } ListNode *fast = head; ListNode *slow = head; while (fast != NULL \u0026amp;\u0026amp; fast-\u0026gt;next != NULL) { fast = fast-\u0026gt;next-\u0026gt;next; slow = slow-\u0026gt;next; } ListNode *headSecondHalf = reverse(slow); ListNode *headFirstHalf = head; while (headFirstHalf != NULL \u0026amp;\u0026amp; headSecondHalf != NULL) { ListNode *temp = headFirstHalf-\u0026gt;next; headFirstHalf-\u0026gt;next = headSecondHalf; headFirstHalf = temp; temp = headSecondHalf-\u0026gt;next; headSecondHalf-\u0026gt;next = headFirstHalf; headSecondHalf = temp; } if (headFirstHalf != NULL) { headFirstHalf-\u0026gt;next = NULL; } }  Time Complexity : O(N)\nSpace Complexity : O(1)\n8、cycle in a Circular array  没看懂题目\n ","date":1590227180,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590227180,"objectID":"71bb8141b1736c636d99e72f085a94dc","permalink":"/code/pattern/fast-and-slow-pointers/","publishdate":"2020-05-23T17:46:20+08:00","relpermalink":"/code/pattern/fast-and-slow-pointers/","section":"code","summary":"快慢指针","tags":["pattern"],"title":"Pattern-4 Fast and Slow Pointers","type":"code"},{"authors":[],"categories":[],"content":" 1、介绍 在有序数组或链表中查找出满足某些限定条件一组元素时，常用双指针法。\n2、pair with target sum  给定有序数组、目标值target，在数组中找到一对值，使得其和等于目标值\n返回满足条件的对值的索引\n input: [1,2,3,4,6] ,target=6 output:\t[1,3] 2+4=6，index=[1,3]  input: [2,5,9,11] ,target=11 output:\t[0,2] 2+9=6，index=[0,2]  code:\n双指针法：\npair\u0026lt;int, int\u0026gt; search(const vector\u0026lt;int\u0026gt; \u0026amp;arr, int targetSum) { //指向起始，结束位置。 int left = 0; int right = arr.size() - 1; while (right \u0026gt; left) { int currentSum = arr[left] + arr[right]; if (currentSum == targetSum) { return make_pair(left, right); } if (targetSum \u0026gt; currentSum) { left++; } if (targetSum \u0026lt; currentSum) { right--; } } return make_pair(-1, -1); }  Time: O(N)\nSpace: O(1)\n哈希表：\npair\u0026lt;int,int\u0026gt; searchhash(const vector\u0026lt;int\u0026gt; \u0026amp;arr,int targetSum){ unordered_map\u0026lt;int,int\u0026gt; nums; for(int i=0;i\u0026lt;arr.size();i++){ if(nums.find(targetSum-arr[i])!=nums.end()){ return make_pair(nums[targetSum-arr[i]],i); }else{ nums[arr[i]]=i; } } return make_pair(-1,-1); }  Time: O(N)\nSpace: O(N)\n3、remove Duplicates  删除有序数组中重复的元素，不准使用额外的存储空间，返回删除后的新数组长度\n input:\t[2,3,3,3,6,9,9] output: 4 after remove:[2,3,6,9]  code:\nint remove(vector\u0026lt;int\u0026gt; \u0026amp;arr) { //nextNonDuplicate前面全是不重复的元素，同时承担计数功能 //nextNonDuplicate和i都是指针 int nextNonDuplicate = 1; for (int i = 1; i \u0026lt; arr.size(); i++) { if (arr[nextNonDuplicate - 1] != arr[i]) { arr[nextNonDuplicate] = arr[i]; nextNonDuplicate++; } } return nextNonDuplicate; }  Time Complexity : O(N)\nSpace Complexity : O(1)\n相似问题：\n 删除有序数组中所有等于Target的元素，返回删除后的新数组长度\n input:\t[3, 2, 3, 6, 3, 10, 9, 3],key=3 output: 4 after remove:[2,3,10,9]  code:\nint removeTaget(vector\u0026lt;int\u0026gt; \u0026amp;arr, int key) { // nextElement代表不等于key的元素的新位置,同时计数 // nextElement和i都是指针 int nextElement = 0; for (int i = 0; i \u0026lt; arr.size(); i++) { if (arr[i] != key) { arr[nextElement] = arr[i]; nextElement++; } } return nextElement; }  Time Complexity : O(N)\nSpace Complexity : O(1)\n4、squaring a sorted arrary  给定有序数组，将所有元素的平方有序输出\n input:\t[-2, -1, 0, 2, 3] output: [0 ,1 ,4 ,4 ,9]  input:\t[-3, -1, 0, 1, 2] output: [0 ,1 ,4 ,4 ,9]  code:\nvector\u0026lt;int\u0026gt; makeSqueare(vector\u0026lt;int\u0026gt; arr) { int n = arr.size(); vector\u0026lt;int\u0026gt; square(n); int highestSquareIndex = n - 1; //双指针 int right = n - 1; int left = 0; while (right \u0026gt;= left) { int leftSquare = arr[left] * arr[left]; int rightSquare = arr[right] * arr[right]; if (leftSquare \u0026gt; rightSquare) { square[highestSquareIndex] = leftSquare; highestSquareIndex--; left++; } else { square[highestSquareIndex] = rightSquare; highestSquareIndex--; right--; } } return square; }  Time Complexity : O(N)\nSpace Complexity : O(N)\n5、triplet sum to zero  给定未排序的整数数组，找出所有和为0、长度为3且不重复的子数组\nX+Y+Z=0 -\u0026gt; X+Y=_Z\n为了确保不重复，排序后的数组，重复元素相邻可略过\n input:\t[-3, 0, 1, 2, -1, 1, -2] output: [[-3 1 2 ][-2 0 2 ][-1 0 1 ]]  input:\t[-5, 2, -1, -2, 3] output: [[-5 2 3 ][-2 -1 3 ]]  code:\nvoid searchPair(const vector\u0026lt;int\u0026gt; \u0026amp;arr, int targetSum, int left, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;triplets) { //双指针 int right = arr.size() - 1; while (left \u0026lt; right) { int currentSum = arr[left] + arr[right]; if (currentSum == targetSum) { triplets.push_back({-targetSum, arr[left], arr[right]}); left++; right--; //略过重复元素 while (left \u0026lt; right \u0026amp;\u0026amp; arr[left] == arr[left - 1]) { left++; } //略过重复元素 while (left \u0026lt; right \u0026amp;\u0026amp; arr[right] == arr[right]) { right--; } } else if (targetSum \u0026gt; currentSum) { left++; } else { right--; } } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; searchTriplets(vector\u0026lt;int\u0026gt; \u0026amp;arr) { sort(arr.begin(), arr.end()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; triplets; for (int i = 0; i \u0026lt; arr.size() - 2; i++) { //略过重复元素 if (i \u0026gt; 0 \u0026amp;\u0026amp; arr[i] == arr[i - 1]) { continue; } searchPair(arr, -arr[i], i + 1, triplets); } return triplets; }  Time Complexity : O(N^2)\nSpace Complexity : O(N)\n6、triplet sum close to target  给定未排序数组和target值，找出长度为3的子数组，使得子数组的和尽可能接近target，返回子数组的和\n input:\t[-2, 0, 1, 2],target=2 output: 1 triplet: [-2,1,2]  input:\t[-3, 1, 1, 2],target=1 output: 0 triplet: [-3,1,2]  code:\nint searchTriplet(vector\u0026lt;int\u0026gt; \u0026amp;arr, int targetSum) { sort(arr.begin(), arr.end()); int smallestDifference = INT_MAX; for (int i = 0; i \u0026lt; arr.size() - 2; i++) { int left = i + 1; int right = arr.size() - 1; while (left \u0026lt; right) { int targetDiff = targetSum - arr[i] - arr[left] - arr[right]; if (targetDiff == 0) { return targetSum - targetDiff; } if (abs(targetDiff) \u0026lt; abs(smallestDifference)) { smallestDifference = targetDiff; } if (targetDiff \u0026gt; 0) { left++; } else { right--; } } } return targetSum - smallestDifference; }  Time Complexity : O(N^2)\nSpace Complexity : O(N)\n7、triplets with smaller sum  给定未排序数组和target值，找出所有triplets，使得arr[i]+arr[j]+arr[k]\u0026lt; target，i,j,k不相等，返回满足条件的triplets的个数\n input:\t[-1, 0, 2, 3],target=3 output: 2 triplet: [-1,0,3], [-1,0,2]  input:\t[-1, 4, 2, 1, 3],target=5 output: 4 triplet: [-1,1,4], [-1,1,3], [-1,1,2], [-1,2,3]  code:\nint searchPair(const vector\u0026lt;int\u0026gt; \u0026amp;arr, int targetSum, int first) { int count = 0; int left = first + 1; int right = arr.size() - 1; while (left \u0026lt; right) { if (arr[left] + arr[right] \u0026lt; targetSum) { count += right - left; left++; } else { right--; } } return count; } int searchTriplets(vector\u0026lt;int\u0026gt; \u0026amp;arr, int target) { sort(arr.begin(), arr.end()); int count = 0; for (int i = 0; i \u0026lt; arr.size() - 2; i++) { count += searchPair(arr, target - arr[i], i); } return count; }  Time Complexity : O(N^2)\nSpace Complexity : O(N)\n相似问题：\n 返回所有的triplets\n input:\t[-1, 4, 2, 1, 3],target=5 output: [-1,1,4], [-1,1,3], [-1,1,2], [-1,2,3]  input:\t[-1, 0, 2, 3],target=3 output: [-1,0,3], [-1,0,2]  code:\nvoid searchPair(const vector\u0026lt;int\u0026gt; \u0026amp;arr, int targetSum, int first, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;triplets) { int left = first + 1; int right = arr.size() - 1; while (left \u0026lt; right) { if (arr[left] + arr[right] \u0026lt; targetSum) { for (int i = right; i \u0026gt; left; i--) { triplets.push_back({arr[first], arr[left], arr[i]}); } left++; } else { right--; } } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; searchTriplets(vector\u0026lt;int\u0026gt; \u0026amp;arr, int target) { sort(arr.begin(), arr.end()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; triplets; for (int i = 0; i \u0026lt; arr.size() - 2; i++) { searchPair(arr, target - arr[i], i, triplets); } return triplets; }  Time Complexity : O(N^3)\nSpace Complexity : O(N)\n8、subarrary with product less than a target  给定只包含正整数的数组和target值，寻找所有连续子数组，使得子数组的元素的乘积小于target\n input:\t[2, 5, 3, 10], target=30 output: [[2 ],[5 ],[2 5 ],[3 ],[5 3 ],[10 ]]  input:\t[8, 2, 6, 5], target50 output: [[8 ],[2 ],[8 2 ],[6 ],[2 6 ],[5 ],[6 5 ]]  code:\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; findSubarrary(const vector\u0026lt;int\u0026gt; \u0026amp;arr, int target) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; int product = 1; int left = 0; for (int right = 0; right \u0026lt; arr.size(); right++) { product *= arr[right]; while (product \u0026gt;= target \u0026amp;\u0026amp; left \u0026lt; arr.size()) { product /= arr[left]; left++; } deque\u0026lt;int\u0026gt; temList; //[left,right]区间内乘积小于target，区间内的子数组当然小于target， // 为了避免重复，只计算从arr[right]开始的子数组 for (int i = right; i \u0026gt;= left; i--) { temList.push_front(arr[i]); vector\u0026lt;int\u0026gt; resultVec; move(begin(temList), end(temList), back_inserter(resultVec)); result.push_back(resultVec); } } return result; }  Time Complexity : O(N^3)\nSpace Complexity : O(N)\n9、dutch National flag problem  给定只包含0,1,2的数组，原地排序，不准计算0,1,2的个数\n input:\t[1, 0, 2, 1, 0] output: [0, 0, 1, 1, 2]  input:\t[2, 2, 0, 1, 2, 0] output: [0, 0, 1, 2, 2, 2]  code:\nvoid swap(vector\u0026lt;int\u0026gt; \u0026amp;arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } void sort(vector\u0026lt;int\u0026gt; \u0026amp;arr) { //所有0在low左侧，所有2在high右侧 int low = 0; int high = arr.size() - 1; for (int i = 0; i \u0026lt;= high;) { if (arr[i] == 0) { swap(arr, i, low); i++; low++; } else if (arr[i] == 1) { i++; } else { swap(arr, i, high); high--; } } }  Time Complexity : O(N)\nSpace Complexity : O(N)\n10、quadruple sum to target  给定未排序数组和target值，找出所有不同的quadruple（长度为4的子数组），使得其和等于target\n input:\t[4, 1, 2, -1, 1, -3] output: [ [-3, -1, 1, 4 ], [-3, 1, 1, 2 ] ]  input:\t[2, 0, -1, 1, -2, 2 ] output:\t[[-2, 0, 2 ,2 ], [-1, 0 ,1, 2 ]]  code:\nvoid searchPair(const vector\u0026lt;int\u0026gt; \u0026amp;arr, int targetSum, int fist, int second, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;quadruplets) { int left = second + 1; int right = arr.size() - 1; while (left \u0026lt;= right) { int sum = arr[fist] + arr[second] + arr[left] + arr[right]; if (sum == targetSum) { quadruplets.push_back({arr[fist], arr[second], arr[left], arr[right]}); left++; right--; while (left \u0026lt; right \u0026amp;\u0026amp; arr[left] == arr[left - 1]) { left++; } while (left \u0026gt; right \u0026amp;\u0026amp; arr[right] == arr[right - 1]) { right--; } } else if (sum \u0026lt; targetSum) { left++; } else { right--; } } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; searchQuadruplets(vector\u0026lt;int\u0026gt; \u0026amp;arr, int target) { sort(arr.begin(), arr.end()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; quadruplets; for (int i = 0; i \u0026lt; arr.size() - 3; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; arr[i] == arr[i - 1]) { continue; } for (int j = i + 1; j \u0026lt; arr.size() - 2; j++) { if (j \u0026gt; i + 1 \u0026amp;\u0026amp; arr[j] == arr[j - 1]) { continue; } searchPair(arr, target, i, j, quadruplets); }; } return quadruplets; }  Time Complexity : O(N^3)\nSpace Complexity : O(N)\n11、comparing strings containing backspaces  给定两个包含退格键的字符串，判断他们是否相同，backspace用#表示\n input:\tstr1=\u0026quot;xy#z\u0026quot; ,str2=\u0026quot;xzz#\u0026quot; output:\ttrue after: str1=\u0026quot;xz\u0026quot; ,str2=\u0026quot;xz\u0026quot;  input:\tstr1=\u0026quot;xp#\u0026quot; ,str2=\u0026quot;xyz##\u0026quot; output:\ttrue after: str1=\u0026quot;x\u0026quot; ,str2=\u0026quot;x\u0026quot;  input:\tstr1=\u0026quot;xy#z\u0026quot; ,str2=\u0026quot;xyz#\u0026quot; output:\tfalse after: str1=\u0026quot;xz\u0026quot; ,str2=\u0026quot;xy\u0026quot;  code:\nint getNextValidCharIndex(const string \u0026amp;str, int index) { int backspacesCount = 0; while (index \u0026gt;= 0) { if (str[index] == '#') { backspacesCount++; } else if (backspacesCount \u0026gt; 0) { backspacesCount--; } else { break; } index--; } return index; } bool compare(const string \u0026amp;str1, const string \u0026amp;str2) { int index1 = str1.length() - 1; int index2 = str2.length() - 1; while (index1 \u0026gt;= 0 || index2 \u0026gt;= 0) { int i1 = getNextValidCharIndex(str1, index1); int i2 = getNextValidCharIndex(str2, index2); if (i1 \u0026lt; 0 \u0026amp;\u0026amp; i2 \u0026lt; 0) { return true; } if (i1 \u0026lt; 0 || i2 \u0026lt; 0) { return false; } if (str1[i1] != str2[i2]) { return false; } index1 = i1 - 1; index2 = i2 - 1; } return true; }  Time Complexity : O(N+M)\nSpace Complexity : O(1)\n12、mininum window sort  求最短子数组的长度，子数组满足条件：当子数组排序后，整个数组是有序的\n input:\t[1, 2, 5, 3, 7, 10, 9, 12] output:\t5 subarray:[5, 3, 7, 10, 9 ]  input:\t[1, 3, 2, 0, -1, 7, 10] output:\t5 subarray:[ 3, 2, 0, -1, 7 ]  input:\t[1, 2, 3] output:\t0  input:\t[3, 2, 1] output:\t3  code:\nint sort(const vector\u0026lt;int\u0026gt; \u0026amp;arr) { int low = 0; int high = arr.size() - 1; int subarrayMax = INT_MIN; int subarrayMin = INT_MAX; while (low \u0026lt; arr.size() - 1 \u0026amp;\u0026amp; arr[low] \u0026lt; arr[low + 1]) { low++; } if (low == arr.size() - 1) { return 0; } while (high \u0026gt; 0 \u0026amp;\u0026amp; arr[high] \u0026gt;= arr[high - 1]) { high--; } for (int k = low; k \u0026lt;= high; k++) { subarrayMax = max(subarrayMax, arr[k]); subarrayMin = min(subarrayMin, arr[k]); } while (low \u0026gt; 0 \u0026amp;\u0026amp; arr[low - 1] \u0026gt; subarrayMin) { low--; } while (high \u0026lt; arr.size() - 1 \u0026amp;\u0026amp; arr[high + 1] \u0026lt; subarrayMax) { high++; } return high - low + 1; }  Time Complexity : O(N)\nSpace Complexity : O(1)\n","date":1590227110,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590227110,"objectID":"9145b3d9ad5a5c6e45d9dcd5d4a00ce0","permalink":"/code/pattern/two-pointers/","publishdate":"2020-05-23T17:45:10+08:00","relpermalink":"/code/pattern/two-pointers/","section":"code","summary":"双指针","tags":["pattern"],"title":"Pattern-3 Two Pointers","type":"code"},{"authors":[],"categories":[],"content":" 1、介绍 适用于求连续子数组\n2、average of subarrarys of size K  求长度为K的连续子数组的平均值\n input:\tarrary:[1,3,2,6,-1,4,1,8,2] ,K=5 output:\t[2.2,2.8,2.4,3.6,2,8]  code:\nvector\u0026lt;double\u0026gt; averageOfSubarrayOfSizeK(int k,vector\u0026lt;int\u0026gt; \u0026amp;arr){ vector\u0026lt;double\u0026gt; result(arr.size() -k +1); int windowStart =0; double windowSum =0; for(int windowEnd =0 ; windowEnd\u0026lt;arr.size() ;windowEnd++){ //加上下一个元素 windowSum += arr[windowEnd]; //到达sizeK，滑动窗口 if(windowEnd \u0026gt;=k-1){ result[windowStart]=windowSum/k; //计算平均值 windowSum -=arr[windowStart]; //减去第一个窗口值 windowStart++; //滑动窗口 } } return result; }  2、maximum sum of subarray of size K  求长度为K的连续子数组的最大值\n其中数组元素为正数，K为正数\n input:\t[2,1,5,1,3,2], k=3 output:\t9 subarray:[5,1,3]  input:\t[2,3,4,1,5] ,k=2 output:\t7 subarray:[3,4]  code:\nint maxSumSubarrayOfSizeK(int k ,vector\u0026lt;int\u0026gt; \u0026amp;arr){ int windowStart =0; int windowSum=0; int maxSum=0; for(int windowEnd =0; windowEnd\u0026lt;arr.size() ;windowEnd++){ windowSum +=arr[windowEnd]; if (windowEnd\u0026gt;=k-1){ maxSum=max(maxSum,windowSum); windowSum -= arr[windowStart]; windowStart++; } } return maxSum; }  Time: O(N)\nSpace: O(1)\n3、smallest subarray whose sum is greater than or equal to S  求最短长度的子数组，使得其和大于等于 S\n其中数组元素为正数，S 为正数；如果子数组不存在，返回0\n input:\t[2,1,5,2,3,2], S=7 output:\t2 subarray:[5,2]  input:\t[3,4,1,1,6],S=8 output:\t3 subarray:[3,4,1],[1,1,6]  code：\nint findMinSubarray(int k, vector\u0026lt;int\u0026gt; \u0026amp;arr){ int windowSum = 0; int minLength = INT_MAX; int windowStart = 0; for (int windowEnd = 0; windowEnd \u0026lt; arr.size(); windowEnd++){ windowSum += arr[windowEnd]; //当和大于等于K时候，减小窗口大小 //不确定减去窗口第一个值后，是否满足要求，所以不断减，直到满足K while (windowSum \u0026gt;= k){ //记录满足条件的最小窗口长度 minLength = min(minLength, windowEnd - windowStart + 1); windowSum -= arr[windowStart]; windowStart++; } } return minLength == INT_MAX ? 0 : minLength; }  Time: O(N)\nSpace: O(1)\n4、longest subarrary with no more than K distinct characters  求包含 不超过K个不同字符 的最长子串的长度\n input:\tstring=\u0026quot;araaci\u0026quot; ,k=2 output：\t4 substring:\u0026quot;araa\u0026quot;  input:\tstring=\u0026quot;cbbebi\u0026quot; ,k=3 output：\t5 substring:\u0026quot;cbbeb\u0026quot; \u0026quot;bbebi\u0026quot;  code:\nint findLength(int k, const string \u0026amp;str) { int maxLength = 0; int windowStart = 0; //记录处理过的字符的频率 unordered_map\u0026lt;char, int\u0026gt; mp; for (int windowEnd = 0; windowEnd \u0026lt; str.length(); windowEnd++) { char rightchar = str[windowEnd]; mp[rightchar]++; //不断减小窗口长度，直到满足K个不同字符 while (mp.size() \u0026gt; k) { char leftchar = str[windowStart]; mp[leftchar]--; //删除值为0的键 if (mp[leftchar] == 0) { mp.erase(leftchar); } windowStart++; } //记录满足K的最大长度 maxLength = max(maxLength, windowEnd - windowStart + 1); } return maxLength; }  Time: O(N)\nSpace: O(K)\n5、maximum number of fruits in each basket  字符数组，每个字符代表一种果树，给2个篮子，每个篮子只能装一种水果\n可以从数组任意位置装，不能回头，遇到第三种水果结束\n求两个篮子能装水果的最大值\n同4 ，K=2\n code:\nint findLength(int k, const string \u0026amp;str) { int maxLength = 0; int windowStart = 0; //记录处理过的字符的频率 unordered_map\u0026lt;char, int\u0026gt; mp; for (int windowEnd = 0; windowEnd \u0026lt; str.length(); windowEnd++) { mp[str[windowEnd]]++; //不断减小窗口长度，直到满足K个不同字符 while (mp.size() \u0026gt; k) { mp[str[windowStart]]--; //删除值为0的键 if (mp[str[windowStart]] == 0) { mp.erase(str[windowStart]); } windowStart++; } //记录满足K的最大长度 maxLength = max(maxLength, windowEnd - windowStart + 1); } return maxLength; }  6、no repeat substring  求无重复字符的子串的最大长度\n input:\tstring=\u0026quot;aabccbb\u0026quot; output:\t3 substring:\u0026quot;abc\u0026quot;  input:\tstring=\u0026quot;abccde\u0026quot; output:\t3 substring:\u0026quot;abc\u0026quot; \u0026quot;cde\u0026quot;  code:\nint findlength(const string \u0026amp;str) { int windowStart = 0; int maxLength = 0; //记录处理后每个字符的最后索引位置，是索引位置，不是频率 unordered_map\u0026lt;char, int\u0026gt; mp; for (int windowEnd = 0; windowEnd \u0026lt; str.size(); windowEnd++) { char rightChar = str[windowEnd]; //如果mp中已经包含rightchar,从windowStart侧缩小窗口 if (mp.find(rightChar) != mp.end()) { //此时窗口还未添加重复元素，改变窗口起始位，比较重复原元素后一位和windowStar大小 windowStart = max(windowStart, mp[rightChar] + 1); } //插入rightChar mp[rightChar] = windowEnd; maxLength = max(maxLength, windowEnd - windowStart + 1); } return maxLength; }  Time: O(N)\nSpace: O(K)\n7、longest substring with same letters after replacement  取代不超过K个元素，求包含最长相同元素的字串\n其中字符串全是小写\n input:\tstring=\u0026quot;aabccbb\u0026quot; ,k=2 output:\t5 substring: bccbb-\u0026gt;bbbbb  input:\tstring=\u0026quot;abccde\u0026quot; ,k=1 output:\t3 substring: acc-\u0026gt;ccc ccd-\u0026gt;ccc  code:\nint findLength(const string \u0026amp;str, int k) { int windowStart = 0; int maxLength = 0; //记录每个窗口内重复最多的元素的个数 int maxRepeatLetterCount = 0; //频率 unordered_map\u0026lt;char, int\u0026gt; frequencyMap; for (int windowEnd = 0; windowEnd \u0026lt; str.size(); windowEnd++) { char rightChar = str[windowEnd]; frequencyMap[rightChar]++; maxRepeatLetterCount = max(maxRepeatLetterCount, frequencyMap[rightChar]); //窗口的长度减去最多重复的个数，剩下的是可以替换的个数，如果超过K，就要缩小窗口 if (windowEnd - windowStart + 1 - maxRepeatLetterCount \u0026gt; k) { char leftChar = str[windowStart]; frequencyMap[leftChar]--; windowStart++; } maxLength = max(maxLength, windowEnd - windowStart + 1); } return maxLength; }  Time: O(N)\nSpace: O(1)\n8、longest subarray with ones after replacement  数组只包含0和1，将不超过K个0取代为1，求最长连续只包含1的子数组\n同7\n input: arrary=[0,1,1,0,0,0,1,1,0,1,1],k=2 output:\t6 index=5,8; 0-\u0026gt;1  input: arrary=[0,1,0,0,1,1,0,1,1,0,0,1,1] ,k=3 output:\t9 index=6,9,10; 0-\u0026gt;1  code:\nint findLength(const vector\u0026lt;int\u0026gt; \u0026amp;arr, int k) { int windowStart = 0; int maxLength = 0; //记录每个窗口中1的个数 int maxOnesCount = 0; for (int windowEnd = 0; windowEnd \u0026lt; arr.size(); windowEnd++) { if (arr[windowEnd] == 1) { maxOnesCount++; } if (windowEnd - windowStart + 1 - maxOnesCount \u0026gt; k) { if (arr[windowStart] == 1) { maxOnesCount--; } windowStart++; } maxLength = max(maxLength, windowEnd - windowStart + 1); } return maxLength; }  Time: O(N)\nSpace: O(1)\n9、permutation in a string  文本串和模式串，判断文本串中是否包含模式串的排列\n串的排列：str=“abc”，排列：“abc\u0026rdquo;,\u0026ldquo;acb\u0026rdquo;,\u0026ldquo;bac\u0026rdquo;,\u0026ldquo;bca\u0026rdquo;,\u0026ldquo;cab\u0026rdquo;,\u0026ldquo;cba\u0026rdquo;\n input:string=\u0026quot;oidbcaf\u0026quot;,pattern=\u0026quot;abc\u0026quot; output: true permutation:bca\u0026lt;-\u0026gt;abc  input:string=\u0026quot;odicf\u0026quot;,pattern=\u0026quot;dc\u0026quot; output: false  code:\nbool findPermutation(const string \u0026amp;str, const string \u0026amp;pattern) { int windowStart = 0; int matched = 0; unordered_map\u0026lt;char, int\u0026gt; frequencyMap; for (auto c: pattern) { frequencyMap[c]++; } for (int windowEnd = 0; windowEnd \u0026lt; str.size(); windowEnd++) { char rightChar = str[windowEnd]; if (frequencyMap.find(rightChar) != frequencyMap.end()) { frequencyMap[rightChar]--; if (frequencyMap[rightChar] == 0) { matched++; } } if (matched == (int) frequencyMap.size()) { return true; } if (windowEnd \u0026gt;= pattern.length() - 1) { char leftChar = str[windowStart]; windowStart++; if (frequencyMap.find(leftChar) != frequencyMap.end()) { if (frequencyMap[leftChar] == 0) { matched--; } frequencyMap[leftChar]++; } } } return false; }  10、string anagrams  文本串和模式串，找出文本串中包含模式串的同文异构词的起始索引\n同文异构词就是全排列\n input:string=\u0026quot;ppqp\u0026quot;,pattern=\u0026quot;pq\u0026quot; output: [1,2] anagram:\u0026quot;pq\u0026quot;,\u0026quot;qp\u0026quot;,startIndex=[1,2]  input:string=\u0026quot;abbcabc\u0026quot;,pattern=\u0026quot;abc\u0026quot; output: [2,3,4] anagram:\u0026quot;bca\u0026quot;,\u0026quot;cab\u0026quot;,\u0026quot;abc\u0026quot;,startIndex=[3,4,5]  code：\nvector\u0026lt;int\u0026gt; findStringAnagrams(const string \u0026amp;str, const string \u0026amp;pattern) { int windowStart = 0; int matched = 0; unordered_map\u0026lt;char, int\u0026gt; frequencyMap; vector\u0026lt;int\u0026gt; resultIndices; for (auto c: pattern) { frequencyMap[c]++; } for (int windowEnd = 0; windowEnd \u0026lt; str.size(); windowEnd++) { char rightChar = str[windowEnd]; if (frequencyMap.find(rightChar) != frequencyMap.end()) { frequencyMap[rightChar]--; if (frequencyMap[rightChar] == 0) { matched++; } } if (matched == (int) frequencyMap.size()) { resultIndices.push_back(windowStart); } if (windowEnd \u0026gt;= pattern.length() - 1) { char leftChar = str[windowStart]; windowStart++; if (frequencyMap.find(leftChar) != frequencyMap.end()) { if (frequencyMap[leftChar] == 0) { matched--; } frequencyMap[leftChar]++; } } } return resultIndices; }  11、smallest window containing substring  文本串和模式串，找出最短的文本字串，使得字串包含模式串所有元素\n与9相似\n input:string=\u0026quot;aabdec\u0026quot;,pattern=\u0026quot;abc\u0026quot; output: \u0026quot;abdec\u0026quot;  input:string=\u0026quot;abdabca\u0026quot;,pattern=\u0026quot;abc\u0026quot; output: \u0026quot;abc\u0026quot;  code:\nstring findSubstring(const string \u0026amp;str, const string \u0026amp;pattern) { int windowStart = 0; int matched = 0; int minLength = str.length() + 1; int subStrStart = 0; unordered_map\u0026lt;char, int\u0026gt; frequencyMap; for (auto c: pattern) { frequencyMap[c]++; } for (int windowEnd = 0; windowEnd \u0026lt; str.size(); windowEnd++) { char rightChar = str[windowEnd]; if (frequencyMap.find(rightChar) != frequencyMap.end()) { frequencyMap[rightChar]--; if (frequencyMap[rightChar] == 0) { matched++; } } while (matched == (int) pattern.length()) { if (minLength \u0026gt; windowEnd - windowStart + 1) { minLength = windowEnd - windowStart + 1; subStrStart = windowStart; } char leftChar = str[windowStart]; windowStart++; if (frequencyMap.find(leftChar) != frequencyMap.end()) { if (frequencyMap[leftChar] == 0) { matched--; } frequencyMap[leftChar]++; } } } return minLength \u0026gt; str.length() ? \u0026quot;\u0026quot; : str.substr(subStrStart, minLength); }  12、words concatenation  给定一个字符串和一组相同长度的单词组成的字符串数组，在字符串中查找包含数组所有单词的子串，单词在字串中不重叠，求子串的起始位置\n input:string=\u0026quot;catfoxcat\u0026quot;,words=[\u0026quot;cat\u0026quot;,\u0026quot;fox\u0026quot;] output: [0,3] substring:\u0026quot;catfox\u0026quot; -\u0026gt; index=0 ;\u0026quot;foxcat\u0026quot; -\u0026gt;index=3  input:string=\u0026quot;catcatfoxfox\u0026quot;,words=[\u0026quot;cat\u0026quot;,\u0026quot;fox\u0026quot;] output: [3] substring:\u0026quot;catfox\u0026quot; -\u0026gt; index=3  code:\n程序有误  ","date":1590227043,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590227043,"objectID":"9dd3e4255c9d0342f87372e4e8a21ca5","permalink":"/code/pattern/sliding-window/","publishdate":"2020-05-23T17:44:03+08:00","relpermalink":"/code/pattern/sliding-window/","section":"code","summary":"滑动窗口","tags":["pattern"],"title":"Pattern-2 Sliding Window","type":"code"},{"authors":[],"categories":[],"content":"课程来源于：Grokking the Coding Interview: Patterns for Coding Questions\n课程将面试题目分为14种模式：\n","date":1589881001,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589881001,"objectID":"b92b06a379dc1dd5f217ba033ba7b508","permalink":"/code/pattern/introduction/","publishdate":"2020-05-19T17:36:41+08:00","relpermalink":"/code/pattern/introduction/","section":"code","summary":"code interview patterns介绍","tags":["pattern"],"title":"Pattern-1 Introduction","type":"code"},{"authors":[],"categories":[],"content":"","date":1589879244,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589879244,"objectID":"5966636a9ddf0b68dece12636fce3d1d","permalink":"/mix/markdown/","publishdate":"2020-05-19T17:07:24+08:00","relpermalink":"/mix/markdown/","section":"mix","summary":"Markdown常用操作命令","tags":[],"title":"Markdown","type":"mix"},{"authors":[],"categories":[],"content":" 1、新建文件 例子1：三个文件在同一文件夹内，index后缀默认路由 hugo new -kind=post post/post-name/index.md //路由：http://www.example.com/post-name/ hugo new -kind=post post/post-name/a.md //路由：http://www.example.com/post-name/a/ hugo new -kind=post post/post-name/b.md //路由：http://www.example.com/post-name/b/ 例子2： hugo new -kind=post post/post-name.md //路由：http://www.example.com/post-name -kind 可以省略  2、启动 hugo server  3、新建网站 hugo new site [path/name]  ","date":1589878254,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589878254,"objectID":"9abf8a437532ed2c7e981e965a10bb7b","permalink":"/mix/hugo/","publishdate":"2020-05-19T16:50:54+08:00","relpermalink":"/mix/hugo/","section":"mix","summary":"常用操作命令","tags":[],"title":"Hugo","type":"mix"},{"authors":[],"categories":[],"content":"int main(){ cout\u0026lt;\u0026lt;\u0026quot;hello world\u0026quot;; }  ","date":1575275397,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1575275397,"objectID":"90166e5fa4595957f4c4639711e6263a","permalink":"/mix/learngit/","publishdate":"2019-12-02T16:29:57+08:00","relpermalink":"/mix/learngit/","section":"mix","summary":"Git常用操作命令","tags":[],"title":"Learngit","type":"mix"},{"authors":[""],"categories":["interview"],"content":" Day 1. panic 和 defer 顺序 问：下面这段代码的打印顺序\npackage main import ( \u0026quot;fmt\u0026quot; ) func main() { defer_call() } func defer_call() { defer func() { fmt.Println(\u0026quot;打印前\u0026quot;) }() defer func() { fmt.Println(\u0026quot;打印中\u0026quot;) }() defer func() { fmt.Println(\u0026quot;打印后\u0026quot;) }() panic(\u0026quot;触发异常\u0026quot;) }  输出：\n打印后 打印中 打印前 panic:触发异常   defer 的执行顺序是先进后出，当初panic语句时，会先按照defer的后进先出的顺序执行，最后才执行panic\n若把panic 移动到defer 上 ，则只有 panic(\u0026ldquo;触发异常\u0026rdquo;) 。\n Day 2. for range 创建元素副本，非引用 问：代码的输出\npackage main import \u0026quot;fmt\u0026quot; func main() { slice := []int{0, 1, 2, 3} m := make(map[int]*int) for key, val := range slice { m[key] = \u0026amp;val } for k, v := range m { fmt.Println(k, \u0026quot;-\u0026gt;\u0026quot;, *v) } }  0 -\u0026gt; 3 1 -\u0026gt; 3 2 -\u0026gt; 3 3 -\u0026gt; 3   for range 循环的时候会创建每个元素的副本，而不是元素的引用，所以 m[key] = \u0026amp;val 取的都是变量 val 的地址，所以最后 map 中的所有元素的值都是变量 val 的地址，因为最后 val 被赋值为3，所有输出都是3.\n package main import \u0026quot;fmt\u0026quot; func main() { slice := []int{0, 1, 2, 3} m := make(map[int]*int) for key, val := range slice { value := val m[key] = \u0026amp;value } for k, v := range m { fmt.Println(k, \u0026quot;-\u0026gt;\u0026quot;, *v) } }  2 -\u0026gt; 2 3 -\u0026gt; 3 0 -\u0026gt; 0 1 -\u0026gt; 1  Day 3. append, 命名返回值, new和make区别 问1：代码输出\npackage main import \u0026quot;fmt\u0026quot; func main() { s1 := make([]int, 5) s1 = append(s1, 1, 2, 3, 4) s2 := make([]int, 0) s2 = append(s2, 1, 2, 3, 4) s3 := make([]int, 2) s3 = append(s3, 1, 2, 3, 4) fmt.Println(\u0026quot;s1: \u0026quot;, s1) fmt.Println(\u0026quot;s2: \u0026quot;, s2) fmt.Println(\u0026quot;s3: \u0026quot;, s3) }  s1: [0 0 0 0 0 1 2 3 4] s2: [1 2 3 4] s3: [0 0 1 2 3 4]  问2：代码缺陷错误\nfunc add(x,y int)(sum int, error){ return x+y,nil }   在函数有多个返回值时，只要有一个返回值有命名，其他的也必须命名。\n如果有多个返回值必须加上括号()；\n如果只有一个返回值且命名也必须加上括号()。\n这里的第一个返回值有命名 sum，第二个没有命名，所以错误。\n //对 func add(x,y int)(sum int, err error){ return x+y,nil }  问3: make 和 new 的区别\nnew(T) 和 make(T, args ) 是 Go 语言内建函数，用来分配内存，但适用的类型不同。\nnew(T) 会为 T 类型的新值分配已置零的内存空间，并返回地址（指针），即类型为 *T 的值。换句话说就是，返回一个指针，该指针指向新分配的、类型为 T 的零值。适用于值类型，如数组、结构体等。\nmake(T,args) 返回初始化之后的 T 类型的值，这个值并不是 T 类型的零值，也不是指针 *T，是经过初始化之后的 T 的引用。make() 只适用于 slice、map 和 channel.\nDay 4. append, := 问1：能否通过编译\npackage main import \u0026quot;fmt\u0026quot; //否 func main() { s1 := new([]int) s1 := append(s1, 2) fmt.Println(s1) }  不能对指针执行 append 操作,可以使用 make() 初始化之后再用。同样的，map 和 channel建议使用 make() 或字面量的方式初始化，不要用 new()\n问2：能否通过编译\npackage main import \u0026quot;fmt\u0026quot; //否 func main() { s1 := []int{1, 3, 2} s2 := []int{4, 5} s1 = append(s1, s2) fmt.Println(s1) }  不能，append() 的第二个参数不能直接使用 slice，需使用 … 操作符，将一个切片追加到另一个切片上：append(s1,s2…)。或者直接跟上元素，形如：append(s1,1,2,3)\npackage main import \u0026quot;fmt\u0026quot; func main() { s1 := []int{1, 3, 2} s2 := []int{4, 5} s1 = append(s1, s2...) fmt.Println(s1) }  [1 3 2 4 5]  问3：能否通过编译\nvar ( size := 1024 max_size := size*2 ) func main() fmt.Println(size,max_size) }  否，变量声明的简短模式，x := 100。但这种声明方式有限制：\n 必须使用显示初始化； 不能提供数据类型，编译器会自动推导； 只能在函数内部使用简短模式；  Day 5. 结构体比较 能否通过编译\npackage main import \u0026quot;fmt\u0026quot; func main() { st1 := struct { age int name string }{age: 3, name: \u0026quot;qq\u0026quot;} st2 := struct { age int name string }{age: 3, name: \u0026quot;qq\u0026quot;} //成员属性顺序不一样，也不能比较 st3 := struct { name string age int }{age: 3, name: \u0026quot;qq\u0026quot;} fmt.Println(st1 == st2) //fmt.Println(st3 == st1)编译错误 sm1 := struct { age int n map[string]string }{age: 5, n: map[string]string{\u0026quot;sd\u0026quot;: \u0026quot;sf\u0026quot;}} sm2 := struct { age int n map[string]string }{age: 5, n: map[string]string{\u0026quot;sd\u0026quot;: \u0026quot;sf\u0026quot;}} //fmt.Println(sm2 == sm1) 编译错误 }   结构体只能比较是否相等，但是不能比较大小。 相同类型的结构体才能够进行比较，结构体是否相同不但与属性类型有关，还与属性顺序相关，sn3 与 sn1 就是不同的结构体； 如果 struct 的所有成员都可以比较，则该 struct 就可以通过 == 或 != 进行比较是否相等，比较时逐个项进行比较，如果每一项都相等，则两个结构体才相等，否则不相等；  可比较： bool、数值型、字符、指针、数组等\n不可比较：切片、map、函数等。\nDay 6. 指针，类型别名与定义，值传递 问1.通过指针变量 p 访问其成员变量 name，有哪几种方式？\n A.p.name B.(\u0026amp;p).name C.(*p).name D.p-\u0026gt;name  答：AC\n问2：能否通过编译\npackage main import \u0026quot;fmt\u0026quot; type myInt1 int type myInt2 = int func main() { var i int = 0 var i1 myInt1 = i var i2 myInt2 = i fmt.Println(i1, i2) }  .\\day-6.go:10:6: cannot use i (type int) as type myInt1 in assignment  类型别名与类型定义的区别。\n第 5 行代码是基于类型 int 创建了新类型 MyInt1\n第 6 行代码是创建了 int 的类型别名 MyInt2，注意类型别名的定义时 = 。\n所以，第 10 行代码相当于是将 int 类型的变量赋值给 MyInt1 类型的变量，Go 是强类型语言，编译当然不通过；而 MyInt2 只是 int 的别名，本质上还是 int，可以赋值。\n第 10 行代码的赋值可以使用强制类型转化 var i1 MyInt1 = MyInt1(i).\n问3：输出是什么\npackage main import \u0026quot;fmt\u0026quot; func main() { a := []int{7, 8, 9} fmt.Printf(\u0026quot;%+v\\n\u0026quot;, a) ap(a) fmt.Printf(\u0026quot;%+v\\n\u0026quot;, a) app(a) fmt.Printf(\u0026quot;%+v\\n\u0026quot;, a) } func ap(a []int) { a = append(a, 10) } func app(a []int) { a[0] = 1 }  [7 8 9] [7 8 9] [1 8 9]  append 导致底层数组重新分配内存了,创建了新切片，ap 中的 a 这个slice 的底层数组和外面的不是一个，并没有改变外面的。app会修改底层数组内容，会改变\nDay 7. 字符串拼接，iota 问1： 关于字符串连接，下面语法正确的是？\n A. str := \u0026lsquo;abc\u0026rsquo; + \u0026lsquo;123\u0026rsquo; B. str := \u0026ldquo;abc\u0026rdquo; + \u0026ldquo;123\u0026rdquo; C. str := \u0026lsquo;123\u0026rsquo; + \u0026ldquo;abc\u0026rdquo; D. fmt.Sprintf(\u0026ldquo;abc%d\u0026rdquo;, 123)  答：BD。知识点：字符串连接。除了以上两种连接方式，还有 strings.Join()，buffer.WriteString()等。\n问2：输出什么\npackage main import \u0026quot;fmt\u0026quot; const ( x = iota _ y z = \u0026quot;zz\u0026quot; k p = iota ) func main() { fmt.Println(x, y, z, k, p) }  0 2 zz zz 5  iota详细\n1iota是golang语言的常量计数器,只能在常量的表达式中使用。\n每次 const 出现时，都会让 iota 初始化为0.【自增长】\nconst a = iota // a=0 const ( b = iota //b=0 c / /c=1 )  可以使用下划线跳过不想要的值\n中间插队\nconst ( i = iota j = 3.14 k = iota l ) //那么打印出来的结果是 i=0,j=3.14,k=2,l=3  问3：下面赋值正确的是()\n A. var x = nil B. var x interface{} = nil C. var x string = nil D. var x error = nil  参考答案及解析：BD。知识点：nil 值。nil 只能赋值给指针、chan、func、interface、map 或 slice 类型的变量。强调下 D 选项的 error 类型，它是一种内置接口类型，看下方贴出的源码就知道，所以 D 是对的。\ntype error interface { Error() string }  Day 8. init 函数, 类型选择 interface.(type) 问1：关于init函数，下面说法正确的是()\n A. 一个包中，可以包含多个 init 函数；\n B. 程序编译时，先执行依赖包的 init 函数，再执行 main 包内的 init 函数；\n C. main 包中，不能有 init 函数；\n D. init 函数可以被其他函数调用；\n  答：参考答案及解析：AB。关于 init() 函数有几个需要注意的地方：\n init() 函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等;\n 一个包可以出线多个 init() 函数,一个源文件也可以包含多个 init() 函数； 同一个包中多个 init() 函数的执行顺序没有明确定义，但是不同包的init函数是根据包导入的依赖关系决定的（看下图）; init() 函数在代码中不能被显示调用、不能被引用（赋值给函数变量），否则出现编译错误; 一个包被引用多次，如 A import B,C import B,A import C，B 被引用多次，但 B 包只会初始化一次； 引入包，不可出现死循坏。即 A import B,B import A，这种情况编译失败；  问2：代码输出什么\npackage main import \u0026quot;fmt\u0026quot; func hello() []string { return nil } func main() { h := hello if h == nil { fmt.Println(nil) } else { fmt.Println(\u0026quot;not nil\u0026quot;) } }   A. nil B. not nil C. compilation error  答案及解析：B。这道题目里面，是将 hello() 赋值给变量 h，而不是函数的返回值，所以输出 not nil。\n问3：能否编译通过\npackage main import \u0026quot;fmt\u0026quot; func getValue() int { return 1 } func main() { i := getValue() switch i.(type) { case int: fmt.Println(\u0026quot;int\u0026quot;) case string: fmt.Println(\u0026quot;string\u0026quot;) case interface{}: fmt.Println(\u0026quot;interface\u0026quot;) default: print(\u0026quot;default\u0026quot;) } }  .\\day-8.go:23:2: cannot type switch on non-interface value i (type int)  类型选择的语法形如：i.(type)，其中 i 是接口，type 是固定关键字，需要注意的是，只有接口类型才可以使用类型选择。看下关于接口的文章。\nDay 9. channel, 可变函数 ​\n问1：关于channel，下面语法正确的是()\n A. var ch chan int B. ch := make(chan int) C. \u0026lt;- ch D. ch \u0026lt;-  参考答案及解析：ABC。A、B都是声明 channel；C 读取 channel；写 channel 是必须带上值，所以 D 错误。\n问2：代码输出？\npackage main import \u0026quot;fmt\u0026quot; type person struct { name string } func main() { var m map[person]int p := person{ name: \u0026quot;lili\u0026quot;, } fmt.Println(m[p]) }   A. 0 B. 1 C. Compilation error  参考答案及解析：A。打印一个 map 中不存在的值时，返回元素类型的零值。这个例子中，m 的类型是 map[person]int，因为 m 中不存在 p，所以打印 int 类型的零值，即 0。\n问3：代码输出？\nfunc hello(num ...int) { num[0] = 18 } func main() { i := []int{5, 6, 7} hello(i...) fmt.Println(i[0]) }  18。知识点：可变函数。\nday 10. 比较，s[i: j: k]切片 问1：代码输出？\nfunc main() { a := 5 b := 8.1 fmt.Println(a + b) }   A. 13.1\n B. 13 C. compilation error\n  C。a 的类型是 int，b 的类型是 float，两个不同类型的数值不能相加，编译报错。\n问2：代码输出\npackage main import ( \u0026quot;fmt\u0026quot; ) func main() { a := [5]int{1, 2, 3, 4, 5} t := a[3:4:4] //t := a[3:4:6]编译错误 fmt.Println(t[0]) }   A. 3 B. 4 C. compilation error\n  B。知识点：操作符 [i,j]。基于数组（切片）可以使用操作符 [i,j] 创建新的切片，从索引 i，到索引 j 结束，截取已有数组（切片）的任意部分，返回新的切片，新切片的值包含原数组（切片）的 i 索引的值，但是不包含 j 索引的值。i、j 都是可选的，i 如果省略，默认是 0，j 如果省略，默认是原数组（切片）的长度。i、j 都不能超过这个长度值。\n假如底层数组的大小为 k，截取之后获得的切片的长度和容量的计算方法：长度：j-i，容量：k-i。\n截取操作符还可以有第三个参数，形如 [i,j,k]，第三个参数 k 用来限制新切片的容量，但不能超过原数组（切片）的底层数组大小。截取获得的切片的长度和容量分别是：j-i、k-i。\n所以例子中，切片 t 为 [4]，长度和容量都是 1。\n问3：代码输出？\nfunc main() { a := [2]int{5, 6} b := [3]int{5, 6} if a == b { fmt.Println(\u0026quot;equal\u0026quot;) } else { fmt.Println(\u0026quot;not equal\u0026quot;) } }   A. compilation error\n B. equal\n C. not equal  A。Go 中的数组是值类型，可比较，另外一方面，数组的长度也是数组类型的组成部分，所以 a 和 b 是不同的类型，是不能比较的，所以编译错误。\n​\nDay 11. cap(), interface, map删除 问1.关于 cap() 函数的适用类型，下面说法正确的是()\n A. array B. slice C. map D. channel  ABD。知识点：cap()，cap() 函数不适用 map。\n问2：代码输出？\nfunc main() { var i interface{} if i == nil { fmt.Println(\u0026quot;nil\u0026quot;) return } fmt.Println(\u0026quot;not nil\u0026quot;) }   A. nil B. not nil C. compilation error\n  A。当且仅当接口的动态值和动态类型都为 nil 时，接口类型值才为 nil。文章。\n问3：代码输出？\nfunc main() { s := make(map[string]int) delete(s, \u0026quot;h\u0026quot;) fmt.Println(s[\u0026quot;h\u0026quot;]) }   A. runtime panic B. 0 C. compilation error  B。删除 map 不存在的键值对时，不会报错，相当于没有任何作用；获取不存在的减值对时，返回值类型对应的零值，所以返回 0。\nday 12. 关键字，结构体嵌套 问1：下面属于关键字的是（）\n A. func B. struct C. class D. defer  ABD。知识点：Go 语言的关键字。Go 语言有 25 个关键字，看下图：\n问2：代码输出？\nfunc main() { i := -5 j := +5 fmt.Printf(\u0026quot;%+d %+d\u0026quot;, i, j) }   A. -5 +5 B. +5 +5 C. 0 0  A。%d表示输出十进制数字，+表示输出数值的符号。这里不表示取反。\n问3： 代码输出？\ntype People struct{} func (p *People) ShowA() { fmt.Println(\u0026quot;showA\u0026quot;) p.ShowB() } func (p *People) ShowB() { fmt.Println(\u0026quot;showB\u0026quot;) } type Teacher struct { People } func (t *Teacher) ShowB() { fmt.Println(\u0026quot;teacher showB\u0026quot;) } func main() { t := Teacher{} t.ShowB() }  teacher showB。\n知识点：结构体嵌套。在嵌套结构体中，People 称为内部类型，Teacher 称为外部类型；通过嵌套，内部类型的属性、方法，可以为外部类型所有，就好像是外部类型自己的一样。此外，外部类型还可以定义自己的属性和方法，甚至可以定义与内部相同的方法，这样内部类型的方法就会被“屏蔽”。这个例子中的 ShowB() 就是同名方法。\n关于结构体嵌套可以看下这篇文章。\nDay 13. 全局声明, defer, 结构体嵌套 问1：定义一个包内全局字符串变量，下面语法正确的是（）\n A. var str string B. str := \u0026ldquo;\u0026rdquo; C. str = \u0026ldquo;\u0026rdquo; D. var str = \u0026ldquo;\u0026rdquo;  ：AD。B 只支持局部变量声明；C 是赋值，str 必须在这之前已经声明；\n问2：下面这段代码输出什么?\nfunc hello(i int) { fmt.Println(i) } func main() { i := 5 defer hello(i) i = i + 10 }  5。这个例子中，hello() 函数的参数在执行 defer 语句的时候会保存一份副本，在实际调用 hello() 函数时用，所以是 5.\n问3：下面这段代码输出什么？\ntype People struct{} func (p *People) ShowA() { fmt.Println(\u0026quot;showA\u0026quot;) p.ShowB() } func (p *People) ShowB() { fmt.Println(\u0026quot;showB\u0026quot;) } type Teacher struct { People } func (t *Teacher) ShowB() { fmt.Println(\u0026quot;teacher showB\u0026quot;) } func main() { t := Teacher{} t.ShowA() }  showA showB\n结构体嵌套。这道题可以结合第 12 天的第三题一起看，Teacher 没有自己 ShowA()，所以调用内部类型 People 的同名方法，需要注意的是第 5 行代码调用的是 People 自己的 ShowB 方法。\nDay 14. 字符串常量, 可变函数 问1：代码输出？\nfunc main() { str := \u0026quot;hello\u0026quot; str[0] = 'x' fmt.Println(str) }   A. hello B. xello C. compilation error  C。知识点：常量，Go 语言中的字符串是只读的\n问2： 代码输出什么？\nfunc incr(p *int) int { *p++ return *p } func main() { p :=1 incr(\u0026amp;p) fmt.Println(p) }   A. 1 B. 2 C. 3  B。知识点：指针，incr() 函数里的 p 是 *int 类型的指针，指向的是 main() 函数的变量 p 的地址。第 2 行代码是将该地址的值执行一个自增操作，incr() 返回自增后的结果。\n参考下指针的文章\n问3：对 add() 函数调用正确的是（）\nfunc add(args ...int) int { sum := 0 for _, arg := range args { sum += arg } return sum }   A. add(1, 2) B. add(1, 3, 7) C. add([]int{1, 2}) D. add([]int{1, 3, 7}…}  ABD。知识点：可变函数。\nDay 15. nil 切片和空切片，实现接口 1.下面代码下划线处可以填入哪个选项？\nfunc main() { var s1 []int var s2 = []int{} if __ == nil { fmt.Println(\u0026quot;yes nil\u0026quot;) }else{ fmt.Println(\u0026quot;no nil\u0026quot;) } }   A. s1 B. s2 C. s1、s2 都可以  A。知识点：nil 切片和空切片。nil 切片和 nil 相等，一般用来表示一个不存在的切片；空切片和 nil 不相等，表示一个空的集合。\n2.下面这段代码输出什么？\nfunc main() { i := 65 fmt.Println(string(i)) }   A. A B. 65 C. compilation error  A。UTF-8 编码中，十进制数字 65 对应的符号是 A。\n3.下面这段代码输出什么？\ntype A interface { ShowA() int } type B interface { ShowB() int } type Work struct { i int } func (w Work) ShowA() int { return w.i + 10 } func (w Work) ShowB() int { return w.i + 20 } func main() { c := Work{3} var a A = c var b B = c fmt.Println(a.ShowA()) fmt.Println(b.ShowB()) }  13 23。\n接口。一种类型实现多个接口，结构体 Work 分别实现了接口 A、B，所以接口变量 a、b 调用各自的方法 ShowA() 和 ShowB()，输出 13、23\nDay 16. cap(),len(), 接口的静态类型, map初始化 1.切片 a、b、c 的长度和容量分别是多少？\nfunc main() { s := [3]int{1, 2, 3} a := s[:0] b := s[:2] c := s[1:2:cap(s)] }  2.下面代码中 A B 两处应该怎么修改才能顺利编译？\nfunc main() { var m map[string]int //A m[\u0026quot;a\u0026quot;] = 1 if v := m[\u0026quot;b\u0026quot;]; v != nil { //B fmt.Println(v) } }  3.下面代码输出什么？\ntype A interface { ShowA() int } type B interface { ShowB() int } type Work struct { i int } func (w Work) ShowA() int { return w.i + 10 } func (w Work) ShowB() int { return w.i + 20 } func main() { c := Work{3} var a A = c var b B = c fmt.Println(a.ShowB()) fmt.Println(b.ShowA()) }   A. 23 13 B. compilation error  解析：\n1.参考答案及解析：a、b、c 的长度和容量分别是 0 3、2 3、1 2。\n知识点：数组或切片的截取操作。截取操作有带 2 个或者 3 个参数，形如：[i:j] 和 [i:j:k]，假设截取对象的底层数组长度为 l。\n在操作符 [i:j] 中，如果 i 省略，默认 0，如果 j 省略，默认底层数组的长度，截取得到的切片长度和容量计算方法是 j-i、l-i。操作符 [i:j:k]，\nk 主要是用来限制切片的容量，但是不能大于数组的长度 l，截取得到的切片长度和容量计算方法是 j-i、k-i。\n2.参考答案及解析：\nfunc main() { m := make(map[string]int) m[\u0026quot;a\u0026quot;] = 1 if v,ok := m[\u0026quot;b\u0026quot;]; ok { fmt.Println(v) } }  在 A 处只声明了map m ,并没有分配内存空间，不能直接赋值，需要使用 make()，都提倡使用 make() 或者字面量的方式直接初始化 map。\nB 处，v,k := m[\u0026quot;b\u0026quot;] 当 key 为 b 的元素不存在的时候，v 会返回值类型对应的零值，k 返回 false。\n3.参考答案及解析：B。知识点：接口的静态类型。a、b 具有相同的动态类型和动态值，分别是结构体 work 和 {3}；a 的静态类型是 A，b 的静态类型是 B，接口 A 不包括方法 ShowB()，接口 B 也不包括方法 ShowA()，编译报错。看下编译错误：\na.ShowB undefined (type A has no field or method ShowB) b.ShowA undefined (type B has no field or method ShowA)  更多知识点看下接口的文章。\nDay 18. 变量声明，defer，接口 1.下面代码中，x 已声明，y 没有声明，判断每条语句的对错。\n1. x, _ := f() 2. x, _ = f() 3. x, y := f() 4. x, y = f()  2.下面代码输出什么？\nfunc increaseA() int { var i int defer func() { i++ }() return i } func increaseB() (r int) { defer func() { r++ }() return r } func main() { fmt.Println(increaseA()) fmt.Println(increaseB()) }   A. 1 1 B. 0 1 C. 1 0 D. 0 0  3.下面代码输出什么？\ntype A interface { ShowA() int } type B interface { ShowB() int } type Work struct { i int } func (w Work) ShowA() int { return w.i + 10 } func (w Work) ShowB() int { return w.i + 20 } func main() { var a A = Work{3} s := a.(Work) fmt.Println(s.ShowA()) fmt.Println(s.ShowB()) }   A. 13 23 B. compilation error  解析：\n1.参考答案及解析：错、对、对、错。知识点：变量的声明。1.错，x 已经声明，不能使用 :=；2.对；3.对，当多值赋值时，:= 左边的变量无论声明与否都可以；4.错，y 没有声明。\n2.参考答案及解析：B。知识点：defer、返回值。注意一下，increaseA() 的返回参数是匿名，increaseB() 是具名。\n3.参考答案及解析：A。知识点：类型断言。这道题可以和第 15 天的第三题 和第 16 天的第三题结合起来看，具体的解析看《Go 语言接口详解（二）》。\nDay 19. defer 1.下面代码段输出什么？\ntype Person struct { age int } func main() { person := \u0026amp;Person{28} // 1. defer fmt.Println(person.age) // 2. defer func(p *Person) { fmt.Println(p.age) }(person) // 3. defer func() { fmt.Println(person.age) }() person.age = 29 }  29 29 28。变量 person 是一个指针变量 。\n person.age 此时是将 28 当做 defer 函数的参数，会把 28 缓存在栈中，等到最后执行该 defer 语句的时候取出，即输出 28；\n defer 缓存的是结构体 Person{28} 的地址，最终 Person{28} 的 age 被重新赋值为 29，所以 defer 语句最后执行的时候，依靠缓存的地址取出的 age 便是 29，即输出 29；\n 闭包引用，输出 29；\n  又由于 defer 的执行顺序为先进后出，即 3 2 1，所以输出 29 29 28。\n 『GCTT 出品』Go 中 defer 的 5 个坑 - 第一部分 『GCTT 出品』Golang 中 defer 的五个坑 - 第二部分 Golang 中 defer 的五个坑 - 第三部分\n 5 年 Gopher 都不知道的 defer 细节，你别再掉进坑里！\n  Day 20. defer 1.下面这段代码正确的输出是什么？\nfunc f() { defer fmt.Println(\u0026quot;D\u0026quot;) fmt.Println(\u0026quot;F\u0026quot;) } func main() { f() fmt.Println(\u0026quot;M\u0026quot;) }   A. F M D B. D F M C. F D M  2.下面代码输出什么？\ntype Person struct { age int } func main() { person := \u0026amp;Person{28} // 1. defer fmt.Println(person.age) // 2. defer func(p *Person) { fmt.Println(p.age) }(person) // 3. defer func() { fmt.Println(person.age) }() person = \u0026amp;Person{29} }  解析：\n1.参考答案及解析：C。被调用函数里的 defer 语句在返回之前就会被执行，所以输出顺序是 F D M。\n2.参考答案及解析：29 28 28。\n这道题在第 19 天题目的基础上做了一点点小改动，前一题最后一行代码 person.age = 29 是修改引用对象的成员 age，这题最后一行代码 person = \u0026amp;Person{29} 是修改引用对象本身，来看看有什么区别。\n1处. person.age 这一行代码跟之前含义是一样的，此时是将 28 当做 defer 函数的参数，会把 28 缓存在栈中，等到最后执行该 defer 语句的时候取出，即输出 28；\n2处. defer 缓存的是结构体 Person{28} 的地址，这个地址指向的结构体没有被改变，最后 defer 语句后面的函数执行的时候取出仍是 28；\n3处. 闭包引用，person 的值已经被改变，指向结构体 Person{29}，所以输出 29.\n由于 defer 的执行顺序为先进后出，即 3 2 1，所以输出 29 28 28。\nDay 21. 切片声明，接口  下面的两个切片声明中有什么区别？哪个更可取？\nA. var a []int B. a := []int{}  A、B、C、D 哪些选项有语法错误？\ntype S struct { } func f(x interface{}) { } func g(x *interface{}) { } func main() { s := S{} p := \u0026amp;s f(s) //A g(s) //B f(p) //C g(p) //D }  下面 A、B 两处应该填入什么代码，才能确保顺利打印出结果？\ntype S struct { m string } func f() *S { return __ //A } func main() { p := __ //B fmt.Println(p.m) //print \u0026quot;foo\u0026quot; }   解析：\n1、参考答案及解析：A 声明的是 nil 切片；B 声明的是长度和容量都为 0 的空切片。第一种切片声明不会分配内存，优先选择。\n2、参考答案及解析：BD。函数参数为 interface{} 时可以接收任何类型的参数，包括用户自定义类型等，即使是接收指针类型也用 interface{}，而不是使用 *interface{}。\n 永远不要使用一个指针指向一个接口类型，因为它已经是一个指针。\n 3.参考答案及解析：\nA. \u0026amp;S{\u0026quot;foo\u0026quot;} B. *f() 或者 f()  f() 函数返回参数是指针类型，所以可以用 \u0026amp; 取结构体的指针；B 处，如果填 *f()，则 p 是 S 类型；如果填 f()，则 p 是 *S 类型，不过都可以使用 p.m 取得结构体的成员。\nDay 22. 字符串与nil，defer 1.下面的代码有几处语法问题，各是什么？\npackage main import ( \u0026quot;fmt\u0026quot; ) func main() { var x string = nil if x == nil { x = \u0026quot;default\u0026quot; } fmt.Println(x) }  2.return 之后的 defer 语句会执行吗，下面这段代码输出什么？\nvar a bool = true func main() { defer func(){ fmt.Println(\u0026quot;1\u0026quot;) }() if a == true { fmt.Println(\u0026quot;2\u0026quot;) return } defer func(){ fmt.Println(\u0026quot;3\u0026quot;) }() }  解析：**\n1.参考答案及解析：两个地方有语法问题。golang 的字符串类型是不能赋值 nil 的，也不能跟 nil 比较。\n2.参考答案及解析：2 1。defer 关键字后面的函数或者方法想要执行必须先注册，return 之后的 defer 是不能注册的， 也就不能执行后面的函数或方法。\nDay 23. 切片，代码块和变量作用域 1.下面这段代码输出什么？为什么？\nfunc main() { s1 := []int{1, 2, 3} s2 := s1[1:] s2[1] = 4 fmt.Println(s1) s2 = append(s2, 5, 6, 7) fmt.Println(s1) }  2.下面选项正确的是？\nfunc main() { if a := 1; false { } else if b := 2; false { } else { println(a, b) } }   A. 1 2 B. compilation error  1.参考答案及解析：\n[1 2 4] [1 2 4]  我们知道，golang 中切片底层的数据结构是数组。当使用 s1[1:] 获得切片 s2，和 s1 共享同一个底层数组，这会导致 s2[1] = 4 语句影响 s1。\n而 append 操作会导致底层数组扩容，生成新的数组，因此追加数据后的 s2 不会影响 s1。\n但是为什么对 s2 赋值后影响的却是 s1 的第三个元素呢？这是因为切片 s2 是从数组的第二个元素开始，s2 索引为 1 的元素对应的是 s1 索引为 2 的元素。\n2.参考答案及解析：A。知识点：代码块和变量作用域。推荐 TonyBai 老师的一篇文章，讲的很详细！\nDay 24. map ，defer 1.下面这段代码输出什么？\nfunc main() { m := map[int]string{0:\u0026quot;zero\u0026quot;,1:\u0026quot;one\u0026quot;} for k,v := range m { fmt.Println(k,v) } }  参考答案及解析：\n0 zero 1 one // 或者 1 one 0 zero  map 的输出是无序的。\n2.下面这段代码输出什么？\nfunc main() { a := 1 b := 2 defer calc(\u0026quot;1\u0026quot;, a, calc(\u0026quot;10\u0026quot;, a, b)) a = 0 defer calc(\u0026quot;2\u0026quot;, a, calc(\u0026quot;20\u0026quot;, a, b)) b = 1 } func calc(index string, a, b int) int { ret := a + b fmt.Println(index, a, b, ret) return ret }  参考答案及解析：\n10 1 2 3 20 0 2 2 2 0 2 2 1 1 3 4  程序执行到 main() 函数三行代码的时候，会先执行 calc() 函数的 b 参数calc(\u0026quot;10\u0026quot;,a,b)，输出：10 1 2 3，得到值 3，\n因为defer 定义的函数是延迟函数，故 calc(\u0026ldquo;1\u0026rdquo;,1,3) 会被延迟执行；\n程序执行到第五行的时候，同样先执行 calc(\u0026ldquo;20\u0026rdquo;,a,b) 输出：20 0 2 2 得到值 2，同样将 calc(\u0026ldquo;2\u0026rdquo;,0,2) 延迟执行；\n程序执行到末尾的时候，按照栈先进后出的方式依次执行：calc(\u0026ldquo;2\u0026rdquo;,0,2)，calc(\u0026ldquo;1\u0026rdquo;,1,3)，则就依次输出：2 0 2 2，1 1 3 4。\nDay 25. 类的方法，接口 1.下面这段代码输出什么？为什么？\nfunc (i int) PrintInt () { fmt.Println(i) } func main() { var i int = 1 i.PrintInt() }   A. 1 B. compilation error  参考答案及解析：B。基于类型创建的方法必须定义在同一个包内，上面的代码基于 int 类型创建了 PrintInt() 方法，由于 int 类型和方法 PrintInt() 定义在不同的包内，所以编译出错。\n解决的办法可以定义一种新的类型：\ntype Myint int func (i Myint) PrintInt () { fmt.Println(i) } func main() { var i Myint = 1 i.PrintInt() }  2.下面这段代码输出什么？为什么？\ntype People interface { Speak(string) string } type Student struct{} func (stu *Student) Speak(think string) (talk string) { if think == \u0026quot;speak\u0026quot; { talk = \u0026quot;speak\u0026quot; } else { talk = \u0026quot;hi\u0026quot; } return } func main() { var peo People = Student{} think := \u0026quot;speak\u0026quot; fmt.Println(peo.Speak(think)) }   A. speak B. compilation error  参考答案及解析：B。编译错误 Student does not implement People (Speak method has pointer receiver)，值类型 Student 没有实现接口的 Speak() 方法，而是指针类型 *Student 实现该方法。\nDay 26. iota，接口 1.下面这段代码输出什么？\nconst ( a = iota b = iota ) const ( name = \u0026quot;name\u0026quot; c = iota d = iota ) func main() { fmt.Println(a) fmt.Println(b) fmt.Println(c) fmt.Println(d) }  参考答案及解析：0 1 1 2。知识点：iota 的用法。\niota 是 golang 语言的常量计数器，只能在常量的表达式中使用。\niota 在 const 关键字出现时将被重置为0，const中每新增一行常量声明将使 iota 计数一次。\n推荐阅读： golang 使用 iota：https://studygolang.com/articles/2192\n2.下面这段代码输出什么？为什么？\ntype People interface { Show() } type Student struct{} func (stu *Student) Show() { } func main() { var s *Student if s == nil { fmt.Println(\u0026quot;s is nil\u0026quot;) } else { fmt.Println(\u0026quot;s is not nil\u0026quot;) } var p People = s if p == nil { fmt.Println(\u0026quot;p is nil\u0026quot;) } else { fmt.Println(\u0026quot;p is not nil\u0026quot;) } }  参考答案及解析：s is nil 和 p is not nil。这道题会不会有点诧异，我们分配给变量 p 的值明明是 nil，然而 p 却不是 nil。记住一点，当且仅当动态值和动态类型都为 nil 时，接口类型值才为 nil。上面的代码，给变量 p 赋值之后，p 的动态值是 nil，但是动态类型却是 *Student，是一个 nil 指针，所以相等条件不成立。\n更多细节可以参考Go 语言接口详解（一）\nDay 27. iota，map 1.下面这段代码输出什么？\ntype Direction int const ( North Direction = iota East South West ) func (d Direction) String() string { return [...]string{\u0026quot;North\u0026quot;, \u0026quot;East\u0026quot;, \u0026quot;South\u0026quot;, \u0026quot;West\u0026quot;}[d] } func main() { fmt.Println(South) }  参考答案及解析：South。知识点：iota 的用法、类型的 String() 方法。\n根据 iota 的用法推断出 South 的值是 3；另外，如果类型定义了 String() 方法，当使用 fmt.Printf()、fmt.Print() 和 fmt.Println() 会自动使用 String() 方法，实现字符串的打印。\n2.下面代码输出什么？\ntype Math struct { x, y int } var m = map[string]Math{ \u0026quot;foo\u0026quot;: Math{2, 3}, } func main() { m[\u0026quot;foo\u0026quot;].x = 4 fmt.Println(m[\u0026quot;foo\u0026quot;].x) }   A. 4 B. compilation error  参考答案及解析：B，编译报错 cannot assign to struct field m[\u0026quot;foo\u0026quot;].x in map。错误原因：对于类似 X = Y的赋值操作，必须知道 X 的地址，才能够将 Y 的值赋给 X，但 go 中的 map 的 value 本身是不可寻址的。\n有两个解决办法：\n1.使用临时变量\ntype Math struct { x, y int } var m = map[string]Math{ \u0026quot;foo\u0026quot;: Math{2, 3}, } func main() { tmp := m[\u0026quot;foo\u0026quot;] tmp.x = 4 m[\u0026quot;foo\u0026quot;] = tmp fmt.Println(m[\u0026quot;foo\u0026quot;].x) }  2.修改数据结构\ntype Math struct { x, y int } var m = map[string]*Math{ \u0026quot;foo\u0026quot;: \u0026amp;Math{2, 3}, } func main() { m[\u0026quot;foo\u0026quot;].x = 4 fmt.Println(m[\u0026quot;foo\u0026quot;].x) fmt.Printf(\u0026quot;%#v\u0026quot;, m[\u0026quot;foo\u0026quot;]) // %#v 格式化输出详细信息 }  Day 28. 比较，变量作用域 1.下面的代码有什么问题？\nfunc main() { fmt.Println([...]int{1} == [2]int{1}) fmt.Println([]int{1} == []int{1}) }  参考答案及解析：有两处错误\n go 中不同类型是不能比较的，而数组长度是数组类型的一部分，所以 […]int{1} 和 [2]int{1} 是两种不同的类型，不能比较； 切片是不能比较的  2.下面这段代码输出什么？\nvar p *int func foo() (*int, error) { var i int = 5 return \u0026amp;i, nil } func bar() { //use p fmt.Println(*p) } func main() { p, err := foo() if err != nil { fmt.Println(err) return } bar() fmt.Println(*p) }   A. 5 5 B. runtime error  参考答案及解析：B。知识点：变量作用域。问题出在操作符:=，对于使用:=定义的变量，如果新变量与同名已定义的变量不在同一个作用域中，那么 Go 会新定义这个变量。对于本例来说，main() 函数里的 p 是新定义的变量，会遮住全局变量 p，导致执行到bar()时程序，全局变量 p 依然还是 nil，程序随即 Crash。\n正确的做法是将 main() 函数修改为：\nfunc main() { var err error p, err = foo() if err != nil { fmt.Println(err) return } bar() fmt.Println(*p) }  这道题目引自 Tony Bai 老师的一篇文章，原文讲的很详细，推荐。 https://tonybai.com/2015/01/13/a-hole-about-variable-scope-in-golang/\nDay 29. for range 1.下面这段代码能否正常结束？\nfunc main() { v := []int{1, 2, 3} for i := range v { v = append(v, i) } }  参考答案及解析：不会出现死循环，能正常结束。 循环次数在循环开始前就已经确定，循环内改变切片的长度，不影响循环次数。\n2.下面这段代码输出什么？为什么？\nfunc main() { var m = [...]int{1, 2, 3} for i, v := range m { go func() { fmt.Println(i, v) }() } time.Sleep(time.Second * 3) }  参考答案及解析：\n2 3 2 3 2 3  for range 使用短变量声明(:=)的形式迭代变量，需要注意的是，变量 i、v 在每次循环体中都会被重用，而不是重新声明。\n各个 goroutine 中输出的 i、v 值都是 for range 循环结束后的 i、v 最终值，而不是各个goroutine启动时的i, v值。可以理解为闭包引用，使用的是上下文环境的值。\n两种可行的 fix 方法:\n1.使用函数传递\nfor i, v := range m { go func(i,v int) { fmt.Println(i, v) }(i,v) }  2.使用临时变量保留当前值\nfor i, v := range m { i := i // 这里的 := 会重新声明变量，而不是重用 v := v go func() { fmt.Println(i, v) }() }  引自：https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/\nDay 30. defer ，for range 1.下面这段代码输出什么？\nfunc f(n int) (r int) { defer func() { r += n recover() }() var f func() defer f() f = func() { r += 2 } return n + 1 } func main() { fmt.Println(f(3)) }  参考答案及解析：7。\n根据 5 年 Gopher 都不知道的 defer 细节，你别再掉进坑里！ 提到的“三步拆解法”，第一步执行r = n +1，接着执行第二个 defer，由于此时 f() 未定义，引发异常，随即执行第一个 defer，异常被 recover()，程序正常执行，最后 return。\n2.下面这段代码输出什么？\nfunc main() { var a = [5]int{1, 2, 3, 4, 5} var r [5]int for i, v := range a { if i == 0 { a[1] = 12 a[2] = 13 } r[i] = v } fmt.Println(\u0026quot;r = \u0026quot;, r) fmt.Println(\u0026quot;a = \u0026quot;, a) }  参考答案及解析：\nr = [1 2 3 4 5] a = [1 12 13 4 5]  range 表达式是副本参与循环，就是说例子中参与循环的是 a 的副本，而不是真正的 a。就这个例子来说，假设 b 是 a 的副本，则 range 循环代码是这样的：\nfor i, v := range b { if i == 0 { a[1] = 12 a[2] = 13 } r[i] = v }  因此无论 a 被如何修改，其副本 b 依旧保持原值，并且参与循环的是 b，因此 v 从 b 中取出的仍旧是 a 的原值，而非修改后的值。\n如果想要 r 和 a 一样输出，修复办法：\nfunc main() { var a = [5]int{1, 2, 3, 4, 5} var r [5]int for i, v := range \u0026amp;a { if i == 0 { a[1] = 12 a[2] = 13 } r[i] = v } fmt.Println(\u0026quot;r = \u0026quot;, r) fmt.Println(\u0026quot;a = \u0026quot;, a) }  输出：\nr = [1 12 13 4 5] a = [1 12 13 4 5]  修复代码中，使用 *[5]int 作为 range 表达式，其副本依旧是一个指向原数组 a 的指针，因此后续所有循环中均是 \u0026amp;a 指向的原数组亲自参与的，因此 v 能从 \u0026amp;a 指向的原数组中取出 a 修改后的值。\n引自：https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/\n","date":1575198917,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1575198917,"objectID":"033d070f0a72e21d4d413d015ea93894","permalink":"/go/interview/1-30/","publishdate":"2019-12-01T19:15:17+08:00","relpermalink":"/go/interview/1-30/","section":"go","summary":"Go语言面试题","tags":["Go"],"title":"Go语言中文网面试题 1-30","type":"go"}]