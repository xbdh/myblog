<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>pattern | 细胞的核</title>
    <link>/tags/pattern/</link>
      <atom:link href="/tags/pattern/index.xml" rel="self" type="application/rss+xml" />
    <description>pattern</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sun, 24 May 2020 12:30:08 +0800</lastBuildDate>
    <image>
      <url>/img/icon-192.png</url>
      <title>pattern</title>
      <link>/tags/pattern/</link>
    </image>
    
    <item>
      <title>Pattern-18 Miscellaneous</title>
      <link>/code/pattern/miscellaneous/</link>
      <pubDate>Sun, 24 May 2020 12:30:08 +0800</pubDate>
      <guid>/code/pattern/miscellaneous/</guid>
      <description>

&lt;h2 id=&#34;2号&#34;&gt;2号&lt;/h2&gt;

&lt;h3 id=&#34;3号&#34;&gt;3号&lt;/h3&gt;

&lt;h4 id=&#34;4号&#34;&gt;4号&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-19 Conclusion</title>
      <link>/code/pattern/conclusion/</link>
      <pubDate>Sat, 23 May 2020 18:01:15 +0800</pubDate>
      <guid>/code/pattern/conclusion/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Pattern-17 Topological Sort</title>
      <link>/code/pattern/topological-sort/</link>
      <pubDate>Sat, 23 May 2020 17:59:08 +0800</pubDate>
      <guid>/code/pattern/topological-sort/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Pattern-16 0-1 Knapsack</title>
      <link>/code/pattern/0-1-knapsack/</link>
      <pubDate>Sat, 23 May 2020 17:57:50 +0800</pubDate>
      <guid>/code/pattern/0-1-knapsack/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Pattern-15 K Way Merge</title>
      <link>/code/pattern/k-way-merge/</link>
      <pubDate>Sat, 23 May 2020 17:56:50 +0800</pubDate>
      <guid>/code/pattern/k-way-merge/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;p&gt;解决k个有序数组的合并、最值问题。用heap。&lt;/p&gt;

&lt;h2 id=&#34;2-merge-k-sorted-lists&#34;&gt;2、merge k sorted lists&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定K组有序链表，合成一个有序链表&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	l1=[2, 6, 8], l2=[3, 6, 7], l3=[1, 3, 4]
    
output:	[1, 2, 3, 3, 4, 6, 6, 7, 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	l1=[5, 8, 9] ,l2=[1, 7]
    
output:	[1, 5, 7, 8, 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct ListNode {
    int val;
    ListNode *next;

    ListNode(int data) : val(data), next(NULL) {};
};

struct cmp_greater {
    bool operator()(const ListNode *x, const ListNode *y) {
        return x-&amp;gt;val &amp;gt; y-&amp;gt;val;
    }
};

ListNode *merge(const vector&amp;lt;ListNode *&amp;gt; &amp;amp;lists) {

    priority_queue&amp;lt;ListNode *, vector&amp;lt;ListNode *&amp;gt;, cmp_greater&amp;gt; minHeap;

    for (auto root:lists) {
        if (root != NULL) {
            minHeap.push(root);
        }
    }

    ListNode *resultHead = NULL;
    ListNode *resultTail = NULL;

    while (!minHeap.empty()) {
        ListNode *node = minHeap.top();
        minHeap.pop();
        if (resultHead == NULL) {
            resultHead = node;
            resultTail = node;
        } else {
            resultTail-&amp;gt;next = node;
            resultTail = resultTail-&amp;gt;next;
            //resultTail=node;
        }

        if (node-&amp;gt;next != NULL) {
            minHeap.push(node-&amp;gt;next);
        }
    }

    return resultHead;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * log K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;3-kth-smallest-number-in-m-sorted-lists&#34;&gt;3、kth smallest number in m sorted lists&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定M个有序数组，求所有数组中第K小的元素&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	l1=[2, 6, 8], l2=[3, 6, 7], l3=[1, 3, 4],K=5
    
output:	4

explanations:[1, 2, 3, 3, 4, 6, 6, 7, 8] 5th-&amp;gt;4
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: l1=[5, 8, 9], l2=[1, 7],K=3
   
output:	7
    
explanations:[1, 5, 7, 8, 9] 3th-&amp;gt;7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_greater {
    bool operator()(const pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; &amp;amp;x, const pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; &amp;amp;y) {
        return x.first &amp;gt; y.first;
    }
};

int kthSmallest(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;lists, int k) {
    //pair&amp;lt;int,pair&amp;lt;int,int&amp;gt;&amp;gt;&amp;gt; 值，值所在第几个数组，值得索引
    priority_queue&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;, vector&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt;, cmp_greater&amp;gt; minHeap;
    for (int i = 0; i &amp;lt; lists.size(); i++) {
        if (!lists[i].empty()) {
            minHeap.push({lists[i][0], {i, 0}});
        }
    }

    int numberCount = 0, result = 0;

    while (!minHeap.empty()) {
        auto node = minHeap.top();
        minHeap.pop();

        result = node.first;

        if (++numberCount == k) {
            break;
        }

        //下一个node
        node.second.second++;

        //node 所在链表还有元素
        if (lists[node.second.first].size() &amp;gt; node.second.second) {
            node.first = lists[node.second.first][node.second.second];
            minHeap.push(node);
        }
    }

    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;K * log M&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;M&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;相似问题1：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;求m个有序数组、链表的平均值&lt;/p&gt;

&lt;p&gt;解：此时k=N/2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;相似问题1：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;合并m个有序数组&lt;/p&gt;

&lt;p&gt;解：同此题，要记录元素所在数组及索引&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;4-kth-smallest-number-in-a-sorted-matrix&#34;&gt;4、kth smallest number in a sorted matrix&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定矩阵和K值，每行每列增序，求第K小的数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	maxtrix=[
    [2, 6, 8],
    [3, 7, 10],
    [5, 8, 11]
	], k=5

output:	7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_greater {
    bool operator()(const pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; &amp;amp;x, const pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; &amp;amp;y) {
        return x.first &amp;gt; y.first;
    }
};

int kthSmallest(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;matrix, int k) {
    //pair&amp;lt;int,pair&amp;lt;int,int&amp;gt;&amp;gt;&amp;gt; 值，值所在第几个数组，值得索引
    priority_queue&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;, vector&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt;, cmp_greater&amp;gt; minHeap;

    //每行第一个元素放入heap，且不需要超过k个元素
    for (int i = 0; i &amp;lt; matrix.size() &amp;amp;&amp;amp; i &amp;lt; k; i++) {
        minHeap.push({matrix[i][0], {i, 0}});
    }

    int numberCount = 0, result = 0;

    while (!minHeap.empty()) {
        auto node = minHeap.top();
        minHeap.pop();

        result = node.first;

        if (++numberCount == k) {
            break;
        }

        //下一个node
        node.second.second++;

        //node 所在链表还有元素
        if (matrix.size() &amp;gt; node.second.second) {
            node.first = matrix[node.second.first][node.second.second];
            minHeap.push(node);
        }
    }

    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;min(K,N)&lt;/em&gt; + &lt;em&gt;K * log N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;二分查找的方法：&lt;/p&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;待看
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-smallest-number-range&#34;&gt;5、smallest number range&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定m个有序数组，求长度最小的范围区间，使得区间包含每个数组至少一个元素&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	l1=[1, 5, 8], l2=[4, 12], l3=[7, 8, 10]
    
output:	[4, 7]

explanation: l1:-&amp;gt;5,l2:-&amp;gt;4, l3:-&amp;gt;7
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	l1=[1, 9], l2=[4, 12], l3=[7, 10, 16]
    
output:	[9, 12]

explanation: l1:-&amp;gt;9 ,l2:-&amp;gt;12, l3:-&amp;gt;10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_greater {
    bool operator()(const pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; &amp;amp;x, const pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; &amp;amp;y) {
        return x.first &amp;gt; y.first;
    }
};

pair&amp;lt;int, int&amp;gt; smallestRange(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;lists) {
    //pair&amp;lt;int,pair&amp;lt;int,int&amp;gt;&amp;gt;&amp;gt; 值，值所在第几个数组，值得索引
    priority_queue&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;, vector&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt;, cmp_greater&amp;gt; minHeap;

    int rangeStart = 0, rangeEnd = INT_MAX;
    int currentMaxNumber = INT_MIN;

    for (int i = 0; i &amp;lt; lists.size(); i++) {
        if (!lists[i].empty()) {
            minHeap.push({lists[i][0], {i, 0}});
            //minHeap.push(make_pair(lists[i][0], make_pair(i, 0)));
            currentMaxNumber = max(lists[i][0], currentMaxNumber);
        }
    }


    while (minHeap.size() == lists.size()) {
        auto node = minHeap.top();
        minHeap.pop();

        if (rangeEnd - rangeStart &amp;gt; currentMaxNumber - node.first) {
            rangeStart = node.first;
            rangeEnd = currentMaxNumber;
        }

        //下一个node
        node.second.second++;

        //node 所在链表还有元素
        if (lists[node.second.first].size() &amp;gt; node.second.second) {
            node.first = lists[node.second.first][node.second.second];
            minHeap.push(node);
            currentMaxNumber = max(currentMaxNumber, node.first);
        }
    }

    return make_pair(rangeStart, rangeEnd);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * log M&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;M&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;6-k-pair-with-largest-sums&#34;&gt;6、k pair with largest sums&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定两个降序数组和k值，求和最大的K对数(每个数组各一个值，值允许重复)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	l1=[9, 8, 2], l2=[6, 3, 1], k=3
    
output:	[9, 3],[9, 6],[8, 6]

explanation: 和最大的三组
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	l1=[5, 2, 1], l2=[2, -1], k=3
    
output:	[5, 2],[5, -1], [2,2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_greater_sum{
    bool operator()(const pair&amp;lt;int,int&amp;gt; &amp;amp;x,const pair&amp;lt;int,int&amp;gt; &amp;amp;y){
        return x.first+x.second&amp;gt;y.second+y.first;
    }
};

vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; klargestPairs(const vector&amp;lt;int&amp;gt; &amp;amp;num1,const vector&amp;lt;int&amp;gt; &amp;amp;num2,int k) {
    priority_queue&amp;lt;pair&amp;lt;int,int&amp;gt;,vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt;,cmp_greater_sum&amp;gt; minHeap;

    for(int i=0;i&amp;lt;num1.size();i++){
        for(int j=0;i&amp;lt;num2.size();j++){
            if(minHeap.size()&amp;lt;k){
                minHeap.push(make_pair(num1[i],num2[j]));
            }else{
                if(num1[i]+num2[j]&amp;lt;minHeap.top().first+minHeap.top().second){
                    break;
                }else{
                    minHeap.pop();
                    minHeap.push(make_pair(num1[i],num2[j]));
                }
            }
        }
    }

    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;
    while(!minHeap.empty()){
        result.push_back({minHeap.top().first,minHeap.top().second});
        minHeap.pop();
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * M * log K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-14 Top K Elements</title>
      <link>/code/pattern/top-k-elements/</link>
      <pubDate>Sat, 23 May 2020 17:56:30 +0800</pubDate>
      <guid>/code/pattern/top-k-elements/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;p&gt;最大/最小/出现次数 的 第/前 K个元素，常用heap。&lt;/p&gt;

&lt;h2 id=&#34;2-top-k-numbers&#34;&gt;2、top k numbers&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定未排序数组和K值，求前K个大的元素&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, 1, 5, 12, 2, 11] ,K=3
    
output: [5, 12, 11]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[5, 12, 11, -1, 12] ,K=3
    
output: [5, 12, 12]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;int&amp;gt; findLargestNumbers(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) {
    priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; minHeap;
    vector&amp;lt;int&amp;gt; result;
    for (int i = 0; i &amp;lt; k; i++) {
        minHeap.push(nums[i]);
    }

    for (int i = k; i &amp;lt; nums.size(); i++) {
        if (nums[i] &amp;gt; minHeap.top()) {
            minHeap.pop();
            minHeap.push(nums[i]);
        }
    }
    for (int i = 0; i &amp;lt; k; i++) {
        result.push_back(minHeap.top());
        minHeap.pop();
    }
    return result;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;  * log &lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;3-kth-smallest-number&#34;&gt;3、kth smallest number&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定未排序数组和K值，求第K个小的元素&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 5, 12, 2, 11, 5] ,K=3
    
output: 5
    
explanations: 1 2 5 5 11 12
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 5, 12, 2, 11, 5] ,K=4
    
output: 5
    
explanations: 1 2 5 5 11 12
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[5, 11, 12, -1, 12] ,K=3
    
output: 11
    
explanations: -1 5  11 12 12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int kthSmallestNumber(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) {
    priority_queue&amp;lt;int&amp;gt; maxHeap;
    for (int i = 0; i &amp;lt; k; i++) {
        maxHeap.push(nums[i]);
    }

    for (int i = k; i &amp;lt; nums.size(); i++) {
        if (nums[i] &amp;lt; maxHeap.top()) {
            maxHeap.pop();
            maxHeap.push(nums[i]);
        }
    }
    return maxHeap.top();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;  * log &lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;使用小顶堆：&lt;/p&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int kthSmallestNumberUseMinHeap(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) {
    priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; minHeap;
    
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        minHeap.push(nums[i]);
    }

    for (int i = 0; i &amp;lt; k - 1; i++) {
        minHeap.pop();
    }
    
    return minHeap.top();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;  + &lt;em&gt;K&lt;/em&gt; log &lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;4-k-closest-points-to-the-origin&#34;&gt;4、k closest points to the origin&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定一组二位坐标点和K值，求前K个离原点最近的的点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[[1, 2], [1, 3]], k=1
    
output:	[[1, 2]]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[[1, 3], [3, 4], [2, -1]], k=2
    
output:	[[1, 3],[2, -1]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct Point {
    int x, y;

    Point(int _x, int _y) : x(_x), y(_y) {};
};

int distance(Point p) {
    return p.x * p.x + p.y + p.y;
}

bool operator&amp;lt;(Point a, Point b) {
    //return a.x*a.x +a.y*a.y &amp;gt; b.x*b.x+b.y+b.y;
    return distance(a) &amp;lt; distance(b);
}


vector&amp;lt;Point&amp;gt; findKthClosestPoints(const vector&amp;lt;Point&amp;gt; &amp;amp;Points, int k) {
    priority_queue&amp;lt;Point&amp;gt; maxHeap;

    vector&amp;lt;Point&amp;gt; result;
    for (int i = 0; i &amp;lt; k; i++) {
        maxHeap.push(Points[i]);
    }

    for (int i = k; i &amp;lt; Points.size(); i++) {
        if (distance(Points[i]) &amp;lt; distance(maxHeap.top())) {
            maxHeap.pop();
            maxHeap.push(Points[i]);
        }
    }
    for (int i = 0; i &amp;lt; k; i++) {
        result.push_back(maxHeap.top());
        maxHeap.pop();
    }
    return result;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;  * log &lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;5-connect-ropes&#34;&gt;5、connect ropes&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;把N段不同绳子连接成一段长绳子，使得cost最小&lt;/p&gt;

&lt;p&gt;连接两段绳子的cost= 两段绳子的长度和&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 3, 11, 5]

output: 33
    
explanations: cost1: 1 + 3 = 4; cost2: 4 + 5 = 9 ; cost3 :9 + 11 =20 ;totalcost: 4 + 9 + 20 = 33
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [3, 4, 5, 6]

output: 36
    
explanations: cost1: 3 + 4 = 7; cost2: 5 + 6 = 11 ; cost3 :7 + 11 =18 ;totalcost: 7 + 11 + 18 = 36
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 3, 11, 5, 2]

output: 42
    
explanations: cost1: 1 + 2 = 3; cost2: 3 + 3 = 6 ; cost3 :6 + 5 =11 ;cost4 :11 + 11 =22 ; totalcost: 3 +6  + 11 + 12 = 42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int minimumCostConnectRopes(const vector&amp;lt;int&amp;gt; &amp;amp;nums) {

    int result = 0;
    int temp = 0;

    priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; minHeap;

    for (int i = 0; i &amp;lt; nums.size(); i++) {
        minHeap.push(nums[i]);
    }

    while (minHeap.size() &amp;gt; 1) {
        temp = minHeap.top();
        minHeap.pop();
        temp += minHeap.top();
        minHeap.pop();
        result += temp;
        minHeap.push(temp);
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;  * log &lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;6-top-k-frequent-numbers&#34;&gt;6、top k frequent numbers&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定未排序数组和K值，求出现次数前K的数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 3, 5, 12, 11, 12, 11], k=2
    
output:	[12, 11]

explanations: 12(2), 11(2) , 其他1次
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [5, 12, 11, 3, 11], k=2
    
output:	[11, 5] 或[11, 12] 或[11, 3]

explanations: 11(2), 其他1次
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_greater {
    bool operator()(const pair&amp;lt;int, int&amp;gt; &amp;amp;x, const pair&amp;lt;int, int&amp;gt; &amp;amp;y) {
        return x.second &amp;gt; y.second;
    }
};

vector&amp;lt;int&amp;gt; findTopKFrequencyNumbers(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) {
    unordered_map&amp;lt;int, int&amp;gt; numFrequencyMap;
    for (auto n:nums) {
        numFrequencyMap[n]++;
    }

    priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;, cmp_greater&amp;gt; minHeap;

    for (auto entry: numFrequencyMap) {
        minHeap.push(entry);
        if (minHeap.size() &amp;gt; k) {
            minHeap.pop();
        }
    }

    vector&amp;lt;int&amp;gt; topNumbers;
    while (!minHeap.empty()) {
        topNumbers.push_back(minHeap.top().first);
        minHeap.pop();
    }

    return topNumbers;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; + &lt;em&gt;N&lt;/em&gt;  * log &lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;7-frequency-sort&#34;&gt;7、frequency sort&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定字符串，按照字符出现的次数降序排列&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;Programming&amp;quot;
    
output:	&amp;quot;rrggmmPiano&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;abcbab&amp;quot;
    
output:	&amp;quot;bbbaac&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_smaller {
    bool operator()(const pair&amp;lt;char, int&amp;gt; &amp;amp;x, const pair&amp;lt;char, int&amp;gt; &amp;amp;y) {
        return x.second &amp;lt; y.second;
    }
};

string sortCharacterByFrequency(const string &amp;amp;str) {
    unordered_map&amp;lt;char, int&amp;gt; characterFrequencyMap;
    for (char chr:str) {
        characterFrequencyMap[chr]++;
    }

    priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;, cmp_smaller&amp;gt; maxHeap;
    for (auto entry :characterFrequencyMap) {
        maxHeap.push(entry);
    }

    string sortedString = &amp;quot;&amp;quot;;
    while (!maxHeap.empty()) {
        auto entry = maxHeap.top();
        maxHeap.pop();
        for (int i = 0; i &amp;lt; entry.second; i++) {
            sortedString += entry.first;
        }
    }

    return sortedString;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;  * log &lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;8-kth-largest-number-in-a-stream&#34;&gt;8、kth largest number in a stream&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;设计一个类，求数据流中的最大值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;9-k-closest-numbers&#34;&gt;9、k closest numbers&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定排序的数组，及整数K和X。求数组中K个接近X的数，将返回的数排序，X不一定在原数组中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[5, 6, 7, 8, 9] , k=3 ,x=7
    
output:	[6, 7 , 8]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2 ,4 ,5 ,6 ,9] ,k=3 ,x=6
    
output:	[4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2, 4, 5, 6, 9] ,k=3 ,x=10
    
output:	[5, 6, 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_greater {
    bool operator()(const pair&amp;lt;int, int&amp;gt; &amp;amp;x, const pair&amp;lt;int, int&amp;gt; &amp;amp;y) {
        return x.first &amp;gt; y.first;
    }
};

int binarySearch(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int target) {

    int low = 0;
    int high = arr.size() - 1;

    while (low &amp;lt;= high) {

        int mid = low + (high - low) / 2;
        if (target = arr[mid]) {
            return mid;
        } else if (target &amp;gt; arr[mid]) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    if (low &amp;gt; 0) {
        return low - 1;
    }
    return low;
}

vector&amp;lt;int&amp;gt; findClosestElements(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int k, int x) {
    int index = binarySearch(arr, x);
    int low = index - k;
    int high = index + k;
    low = max(low, 0);
    high = min((int) arr.size() - 1, high);

    priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;, cmp_greater&amp;gt; minHeap;

    for (int i = low; i &amp;lt;= high; i++) {
        minHeap.push(make_pair(abs(arr[i] - x), i));
    }

    vector&amp;lt;int&amp;gt; result;
    for (int i = 0; i &amp;lt; k; i++) {
        result.push_back(arr[minHeap.top().second]);
        minHeap.pop();
    }

    sort(result.begin(), result.end());
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;( log &lt;em&gt;N&lt;/em&gt; + &lt;em&gt;K&lt;/em&gt;  * log &lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;双指针法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int binarySearch(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int target) {
    int low = 0;
    int high = arr.size() - 1;

    while (low &amp;lt;= high) {

        int mid = low + (high - low) / 2;
        if (target = arr[mid]) {
            return mid;
        } else if (target &amp;gt; arr[mid]) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }

    if (low &amp;gt; 0) {
        return low - 1;
    }
    return low;
}


vector&amp;lt;int&amp;gt; findClosestElements2(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int k, int x) {
    deque&amp;lt;int&amp;gt; result;
    int index = binarySearch(arr, x);
    int leftPointer = index;
    int rightPointer = index + 1;
    for (int i = 0; i &amp;lt; k; i++) {
        if (leftPointer &amp;gt;= 0 &amp;amp;&amp;amp; rightPointer &amp;lt; (int) arr.size()) {
            int diff1 = abs(x - arr[leftPointer]);
            int diff2 = abs(x - arr[rightPointer]);
            if (diff1 &amp;lt;= diff2) {
                result.push_back(arr[leftPointer]);
                leftPointer--;
            } else {
                result.push_back(arr[rightPointer++]);
            }
        } else if (leftPointer &amp;gt;= 0) {
            result.push_back(arr[leftPointer--]);
        } else if (rightPointer &amp;lt; (int) arr.size()) {
            result.push_back(arr[rightPointer++]);
        }
    }
    
    vector&amp;lt;int&amp;gt; resultvec;
    move(begin(result), end(result), back_inserter(resultvec));
    sort(resultvec.begin(), resultvec.end());
    return resultvec;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;K&lt;/em&gt;  + log &lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;1&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;10-maximum-distinct-elements&#34;&gt;10、maximum distinct elements&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定数组和K值，删除K个数后，求剩余的不重复的数的最大个数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./10-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_greater {
    bool operator()(const pair&amp;lt;int, int&amp;gt; &amp;amp;x, const pair&amp;lt;int, int&amp;gt; &amp;amp;y) {
        return x.second &amp;gt; y.second;
    }
};

int maximumDistinctElements(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) {
    int distinctElementsCount = 0;
    if (nums.size() &amp;lt;= k) {
        return distinctElementsCount;
    }

    unordered_map&amp;lt;int, int&amp;gt; numFrequencyMap;
    for (auto num:nums) {
        numFrequencyMap[num]++;
    }

    priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;, cmp_greater&amp;gt; minHeap;
    for (auto entry:numFrequencyMap) {
        if (entry.second == 1) {
            distinctElementsCount++;
        } else {
            minHeap.push(entry);
        }
    }

    while (k &amp;gt; 0 &amp;amp;&amp;amp; !minHeap.empty()) {
        auto entry = minHeap.top();
        minHeap.pop();
        k -= entry.second - 1;
        if (k &amp;gt;= 0) {
            distinctElementsCount++;
        }
    }

    if (k &amp;gt; 0) {
        distinctElementsCount -= k;
    }

    return distinctElementsCount;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;( &lt;em&gt;N&lt;/em&gt; * log &lt;em&gt;N&lt;/em&gt; + &lt;em&gt;K&lt;/em&gt;  * log &lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;11-sum-of-elements&#34;&gt;11、sum of elements&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定数组和K1、K2值，求第k1小和第k2小之间元素和&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1 ,3 ,12 ,5 ,15 ,11] , k1= 3, k2 = 6
    
output:	23
    
explanations:3th-&amp;gt;5,6th-&amp;gt;15   ,11(4th) + 12(5th) = 23
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, 5, 8, 7] , k1=1, k2 = 4
    
output:	12
    
explanations:1th-&amp;gt;3,4th-&amp;gt;8   ,5(2th) + 7(3th) = 12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int sumOfElements(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int k1, int k2) {
    int sum = 0;
    priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; minHeap;
    for (auto num:nums) {
        minHeap.push(num);
    }

    for (int i = 0; i &amp;lt; k1; i++) {
        minHeap.pop();
    }

    for (int i = 0; i &amp;lt; k2 - k1 - 1; i++) {
        sum += minHeap.top();
        minHeap.pop();
    }

    return sum;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;  * log &lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;大顶堆方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int sumOfElements2(const vector&amp;lt;int&amp;gt; &amp;amp;nums, int k1, int k2) {
    int sum = 0;
    priority_queue&amp;lt;int&amp;gt; maxHeap;
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        if (i &amp;lt; k2 - 1) {
            maxHeap.push(nums[i]);
        } else if (nums[i] &amp;lt; maxHeap.top()) {
            maxHeap.pop();
            maxHeap.push(nums[i]);
        }
    }
    
    for (int i = 0; i &amp;lt; k2 - k1 - 1; i++) {
        sum += maxHeap.top();
        maxHeap.pop();
    }

    return sum;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;  * log &lt;em&gt;K2&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;K2&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;12-rearrange-string&#34;&gt;12、rearrange string&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定字符串，重新排列，使得相同字符不在一起&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;aappp&amp;quot;
    
output:	&amp;quot;papap&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;Programming&amp;quot;
    
output:	&amp;quot;rgmrgmPiano&amp;quot;,或&amp;quot;gmringmrPoa&amp;quot;,等等
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;aapa&amp;quot;
    
output:	&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_smaller {
    bool operator()(const pair&amp;lt;char, int&amp;gt; &amp;amp;x, const pair&amp;lt;char, int&amp;gt; &amp;amp;y) {
        return x.second &amp;lt; y.second;
    }
};

string rearrangeString(const string &amp;amp;str) {
    unordered_map&amp;lt;char, int&amp;gt; charFrequencyMap;
    priority_queue&amp;lt;pair&amp;lt;char, int&amp;gt;, vector&amp;lt;pair&amp;lt;char, int&amp;gt;&amp;gt;, cmp_smaller&amp;gt; maxHeap;
    string resultString = &amp;quot;&amp;quot;;
    pair&amp;lt;char, int&amp;gt; previousEntry(-1, -1);

    for (auto chr:str) {
        charFrequencyMap[chr]++;
    }

    for (auto entry:charFrequencyMap) {
        maxHeap.push(entry);
    }

    while (!maxHeap.empty()) {
        pair&amp;lt;char, int&amp;gt; currentEntry = maxHeap.top();
        maxHeap.pop();
        if (previousEntry.second &amp;gt; 0) {
            maxHeap.push(previousEntry);
        }

        resultString += currentEntry.first;
        currentEntry.second--;
        previousEntry = currentEntry;
    }

    return resultString.length() == str.length() ? resultString : &amp;quot;&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;  * log &lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;13-rearrange-string-k-distance-apart&#34;&gt;13、rearrange string k distance apart&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定字符串和K值，重新排列字符串，使得相同字符至少相隔k个字符&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;mmpp&amp;quot;, k=2
    
output:	&amp;quot;mpmp&amp;quot; 或 &amp;quot;pmpm&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;aappa&amp;quot;, k=3
    
output:	&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;Programming&amp;quot;, k=3
    
output:	&amp;quot;rgmPrgmiano&amp;quot; 或 &amp;quot;gmrPagimnor&amp;quot; 等等
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_smaller {
    bool operator()(const pair&amp;lt;char, int&amp;gt; &amp;amp;x, const pair&amp;lt;char, int&amp;gt; &amp;amp;y) {
        return x.second &amp;lt; y.second;
    }
};

string reorganizeString(const string &amp;amp;str, int k) {
    unordered_map&amp;lt;char, int&amp;gt; charFrequencyMap;
    priority_queue&amp;lt;pair&amp;lt;char, int&amp;gt;, vector&amp;lt;pair&amp;lt;char, int&amp;gt;&amp;gt;, cmp_smaller&amp;gt; maxHeap;
    string resultString = &amp;quot;&amp;quot;;

    queue&amp;lt;pair&amp;lt;char, int&amp;gt;&amp;gt; queue;

    if (k &amp;lt;= 1) {
        return str;
    }

    for (auto chr:str) {
        charFrequencyMap[chr]++;
    }

    for (auto entry:charFrequencyMap) {
        maxHeap.push(entry);
    }

    while (!maxHeap.empty()) {
        pair&amp;lt;char, int&amp;gt; currentEntry = maxHeap.top();
        maxHeap.pop();

        resultString += currentEntry.first;
        currentEntry.second--;
        queue.push(currentEntry);
        if (queue.size() == k) {
            auto entry = queue.front();
            queue.pop();
            if (entry.second &amp;gt; 0) {
                maxHeap.push(entry);
            }
        }
    }
    return resultString.length() == str.length() ? resultString : &amp;quot;&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;  * log &lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;14-scheduling-tasks&#34;&gt;14、scheduling tasks&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;任务调度，给定一组任务和K值，一个任务执行后必须间隔K 段时间，求完成调度最小总时间，当任务不能调度时用idle&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./14-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_smaller {
    bool operator()(const pair&amp;lt;char, int&amp;gt; &amp;amp;x, const pair&amp;lt;char, int&amp;gt; &amp;amp;y) {
        return x.second &amp;lt; y.second;
    }
};

int scheduleTask(const vector&amp;lt;char&amp;gt; &amp;amp;task, int k) {
    int intervalCount = 0;
    unordered_map&amp;lt;char, int&amp;gt; charFrequencyMap;
    priority_queue&amp;lt;pair&amp;lt;char, int&amp;gt;, vector&amp;lt;pair&amp;lt;char, int&amp;gt;&amp;gt;, cmp_smaller&amp;gt; maxHeap;


    for (auto chr:task) {
        charFrequencyMap[chr]++;
    }

    for (auto entry:charFrequencyMap) {
        maxHeap.push(entry);
    }

    while (!maxHeap.empty()) {
        vector&amp;lt;pair&amp;lt;char, int&amp;gt;&amp;gt; waitList;
        int n = k + 1;
        for (; n &amp;gt; 0 &amp;amp;&amp;amp; !maxHeap.empty(); n--) {
            intervalCount++;
            auto currentEntry = maxHeap.top();
            maxHeap.pop();

            if (currentEntry.second &amp;gt; 1) {
                currentEntry.second--;
                waitList.push_back(currentEntry);
            }
        }

        for (auto w:waitList) {
            maxHeap.push(w);
        }

        if (!maxHeap.empty()) {
            intervalCount += n;
        }
    }
    return intervalCount;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;  * log &lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;15-frequency-stack&#34;&gt;15、frequency stack&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;设计类&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-13 Bitwise Xor</title>
      <link>/code/pattern/bitwise-xor/</link>
      <pubDate>Sat, 23 May 2020 17:55:41 +0800</pubDate>
      <guid>/code/pattern/bitwise-xor/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;p&gt;异或操作&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;异或性质：
    
1、自身异或为0：
    1 ^ 1 = 0, 29 ^ 29 = 0
 
2、与0异或为自身：
    1 ^ 0 = 1, 29 ^ 0 = 29  
    
3、交换律和结合律：
    (a ^ b) ^ c = a ^ (b ^ c)
    
    a ^ b = b ^ a
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-missing-number-and-single-number&#34;&gt;2、missing number and single number&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定数组（元素为n-1个），范围（1-n），求缺失的数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findMissingNumber(const vector&amp;lt;int&amp;gt; &amp;amp;arr) {
    int n = arr.size() + 1;
    int s1 = 1;
    for (int i = 2; i &amp;lt;= n; i++) {
        s1 ^= i;
    }

    int s2 = arr[0];
    for (int j = 1; j &amp;lt; n - 1; j++) {
        s2 ^= arr[j];
    }

    return s1 ^ s2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;p&gt;相似问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;非空数组，只有1个元素出现1次，其余出现2次，求出现一次的那个数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 4, 2, 1, 3, 2, 3]

output: 4
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [7, 9, 7]

output: 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int singleNumber(const vector&amp;lt;int&amp;gt; &amp;amp;arr) {
    int result = arr[0];
    //int result1=0; for循环：i=0
    for (int i = 1; i &amp;lt; arr.size(); i++) {
        result ^= arr[i];
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;3-two-single-number&#34;&gt;3、two single number&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;非空数组，有2个元素出现1次，其余出现2次，求出现1次的那2个数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 4, 2, 1, 3, 5, 6, 2,3, 5]

output: [4, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [2, 1, 3, 2]

output: [1, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;int&amp;gt; twoSingleNumber(const vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    int n1xn2 = 0;
    for (auto num: nums) {
        n1xn2 ^= num;
    }

    int rightMostSetBit = 1;
    while ((rightMostSetBit &amp;amp; n1xn2) == 0) {
        rightMostSetBit = rightMostSetBit &amp;lt;&amp;lt; 1;
    }

    int num1 = 0, num2 = 0;
    for (int num: nums) {
        if ((num &amp;amp; rightMostSetBit) != 0) {
            num1 ^= num;
        } else {
            num2 ^= num;
        }
    }
    return vector&amp;lt;int&amp;gt;{num1, num2};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;4-complement-of-base-10-number&#34;&gt;4、complement of base 10 number&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;10进制的正整数，转换为二进制，按位取反后，转化为10进制&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: 8

output: 7
    
explanations: 8 -&amp;gt; 1000 -&amp;gt; 0111 -&amp;gt; 7
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: 10

output: 5
    
explanations: 10 -&amp;gt; 1010 -&amp;gt; 0101 -&amp;gt; 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int bitwiseComplement(int num) {
    int bitCount = 0;
    int n = num;
    while (n &amp;gt; 0) {
        bitCount++;
        n = n &amp;gt;&amp;gt; 1;
    }

    int all_bits_set = pow(2, bitCount) - 1;
    return num ^ all_bits_set;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;b&lt;/em&gt;)，b:整数二进制的位数&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;5-flip-matrix&#34;&gt;5、flip matrix&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;没看懂&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-12 Modified Binary Search</title>
      <link>/code/pattern/modified-binary-search/</link>
      <pubDate>Sat, 23 May 2020 17:55:06 +0800</pubDate>
      <guid>/code/pattern/modified-binary-search/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;p&gt;在数组，链表，矩阵中查找特定的值&lt;/p&gt;

&lt;h2 id=&#34;2-order-agnostic-binary-search&#34;&gt;2、order-agnostic binary search&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定有序数组（不知升序，降序，有可能有重复）和Key值，判断key是否在数组中，返回其索引&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[4, 6, 10] ,key=10
    
output: 2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 2, 3, 4, 6] ,key=4
    
output: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int search(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int key) {
    int start = 0;
    int end = arr.size()-1;
    bool isAscending = arr[start] &amp;lt; arr[end];

    while (start &amp;lt;= end) {
        int mid = start + (end - start) / 2;

        if (key == arr[mid]) {
            return mid;
        }
        if (isAscending) {
            if (key &amp;lt; arr[mid]) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        } else {
            if (key &amp;gt; arr[mid]) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
    }
    return -1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./2-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(log&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;3-ceiling-of-a-number&#34;&gt;3、ceiling of a number&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定升序序列和key值，求ceiling of key（数组中最小的大于等于key的数），返回其索引&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[4, 6, 10] ,key=6
 
output:	1

explanations:	6-&amp;gt;index=1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 3, 8, 10, 15] ,key=12
 
output:	4

explanations:	15-&amp;gt;index=4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int searchCeilingOfANumber(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int key) {
    if (key &amp;gt; arr[arr.size() - 1]) {
        return -1;
    }

    int start = 0;
    int end = arr.size() - 1;
    while (start &amp;lt;= end) {
        int mid = start + (end - start) / 2;
        if (key &amp;lt; arr[mid]) {
            end = mid - 1;
        } else if (key &amp;gt; arr[mid]) {
            start = mid + 1;
        } else {
            return mid;
        }
    }
    //当循环结束时，start=end+1,没有找到等于key的元素，此时arr[start]
    //就是最小的大于等于key的值，
    //等同于 return end+1;
    return start;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./2-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(log&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;4-next-letter&#34;&gt;4、next letter&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定包含小写字母的升序序列和key，寻找最小的字母使得大于key，假定序列为循环序列（当key大于等于arr[arr.size()-1]时，返回arr[0]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[&#39;a&#39;,&#39;c&#39;,&#39;f&#39;,&#39;h&#39;] ,key=&#39;f&#39;
 
output:	&#39;h&#39;

explanations:	&#39;h&#39; &amp;gt; &#39;f&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[&#39;a&#39;,&#39;c&#39;,&#39;f&#39;,&#39;h&#39;] ,key=&#39;m&#39;
 
output:	&#39;a&#39;

explanations:循环后	&#39;a&#39; &amp;gt; &#39;m&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;char searchNextLetter(const vector&amp;lt;char&amp;gt; &amp;amp;letter, char key) {
    int n = letter.size();

    if (key &amp;lt; letter[0] || key &amp;gt;= letter[n - 1]) {
        return letter[0];
    }

    int start = 0;
    int end = n - 1;
    while (start &amp;lt;= end) {
        int mid = start + (end - start) / 2;
        if (key &amp;lt; letter[mid]) {
            end = mid - 1;
        } else {
            start = mid + 1;
        }
    }
    //start=end+1
    return letter[start];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(log&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;5-number-range&#34;&gt;5、number range&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定升序序列和key值，求key值得范围（key出现在序列中起始结束的索引）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[4, 6 ,6 ,6 ,9] ,key=6
 
output:	[1 ,3]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 3, 8, 10, 15] ,key=10
 
output:	[3 ,3]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 3, 8, 10, 15] ,key=112
 
output:	[-1 ,-1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int search(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int key, bool findMaxIndex) {
    //findMaxIndex:是否找最大索引，每次search 只能找最大索引或最小索引
    int keyIndex = -1;
    int start = 0;
    int end = arr.size() - 1;
    while (start &amp;lt;= end) {
        int mid = start + (end - start) / 2;
        if (key &amp;lt; arr[mid]) {
            end = mid - 1;
        } else if (key &amp;gt; arr[mid]) {
            start = mid + 1;
        } else {
            //记录最大索引或最小索引
            keyIndex = mid;
            if (findMaxIndex) {
                //向后找最大索引
                start = mid + 1;
            } else {
                //向前找最大索引
                end = mid - 1;
            }
        }
    }
    return keyIndex;
}

pair&amp;lt;int, int&amp;gt; findRange(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int key) {
    pair&amp;lt;int, int&amp;gt; result(-1, -1);
    result.first = search(arr, key, false);
    if (result.first != -1) {
        result.second = search(arr, key, true);
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(log&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;6-search-in-a-sorted-infinite-array&#34;&gt;6、search in a sorted infinite array&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定未知个数的升序序列和key，判断key是否在其中&lt;/p&gt;

&lt;p&gt;待看&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;7-minimum-difference-element&#34;&gt;7、minimum difference element&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定升序序列和key，求序列中与key 的差的绝对值差距最小的数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[4, 6 ,10] ,key=7
 
output:	6
    
explanations:|6-7|=1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[4, 6 ,10] ,key=4
 
output:	4
    
explanations:|4-4|=0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int searchMinimumDifference(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int key) {
    if (key &amp;lt; arr[0]) {
        return arr[0];
    }
    if (key &amp;gt; arr[arr.size() - 1]) {
        return arr[arr.size() - 1];
    }

    int start = 0;
    int end = arr.size() - 1;
    while (start &amp;lt;= end) {
        int mid = start + (end - start) / 2;
        if (key &amp;lt; arr[mid]) {
            end = mid - 1;
        } else if (key &amp;gt; arr[mid]) {
            start = mid + 1;
        } else {
            return arr[mid];
        }
    }
    if ((arr[start] - key) &amp;lt; (key - arr[end])) {
        return arr[start];
    }
    return arr[end];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(log&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;8-bitonic-array-maximum&#34;&gt;8、bitonic array maximum&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求bitonic数组中的最大值&lt;/p&gt;

&lt;p&gt;bitonic array：先单调递增，在单调递减，arr[i] != arr[i+1]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 3, 8, 12, 4, 2]

output:	12
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [3, 8, 3, 1]

output:	8
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 3, 8, 12]

output:	12
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [10, 9 , 8]

output:	10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int finMax(const vector&amp;lt;int&amp;gt; &amp;amp;arr) {
    int start = 0;
    int end = arr.size() - 1;
    while (start &amp;lt; end) {
        int mid = start + (end - start) / 2;
        //当arr[mid]&amp;gt;arr[mid+1]，位于后半段，最大值在mid前面
        if (arr[mid] &amp;gt; arr[mid + 1]) {
            end = mid;
        } else {
            //位于前半段，最大值在mid+1后面
            start = mid + 1;
        }
    }
    //循环结束start==end
    return arr[start];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(log&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;9-search-bitonic-array&#34;&gt;9、search bitonic array&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定bitonic数组和key值，判断key是否在其中，返回索引&lt;/p&gt;

&lt;p&gt;bitonic array：先单调递增，在单调递减，arr[i] != arr[i+1]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 3, 8, 4, 3],key=4

output:	3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [3, 8, 3, 1],key=8

output:	1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1, 3, 8, 12],key=12

output:	3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [10, 9 , 8],key=10

output:	0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int binarySearch(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int key, int start, int end) {

    bool isAscending = arr[start] &amp;lt; arr[end];

    while (start &amp;lt;= end) {
        int mid = start + (end - start) / 2;

        if (key == arr[mid]) {
            return mid;
        }
        if (isAscending) {
            if (key &amp;lt; arr[mid]) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        } else {
            if (key &amp;gt; arr[mid]) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
    }
    return -1;
}

//返回最大值得索引
int finMax(const vector&amp;lt;int&amp;gt; &amp;amp;arr) {
    int start = 0;
    int end = arr.size() - 1;
    while (start &amp;lt; end) {
        int mid = start + (end - start) / 2;
        //当arr[mid]&amp;gt;arr[mid+1]，位于后半段，最大值在mid前面
        if (arr[mid] &amp;gt; arr[mid + 1]) {
            end = mid;
        } else {
            //位于前半段，最大值在mid+1后面
            start = mid + 1;
        }
    }
    //循环结束start==end
    return start;
}

int search(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int key) {
    int maxIndex = finMax(arr);
    //前半段
    int keyIndex = binarySearch(arr, key, 0, maxIndex);
    if (keyIndex != -1) {
        return keyIndex;
    }
    //后半段
    return binarySearch(arr, key, maxIndex + 1, arr.size() - 1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(log&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;10-search-in-rotated-array&#34;&gt;10、search in rotated array&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定rotated array(不含重复)和key，判断key是否在其中，返回索引&lt;/p&gt;

&lt;p&gt;rotated array：旋转数组，有序数组旋转了有理数个位置，生成两段递增子数组&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./10-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int search(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int key) {
    int start = 0;
    int end = arr.size() - 1;

    while (start &amp;lt;= end) {
        int mid = start + (end - start) / 2;
        if (arr[mid] == key) {
            return mid;
        }
        //左开左开右闭区间
        //[start,mid]之间有序，较长段有序序列在前
        if (arr[start] &amp;lt;= arr[mid]) {
            //判断key在[start,mid]之间，还是在之后
            if (key &amp;gt;= arr[start] &amp;amp;&amp;amp; key &amp;lt; arr[mid]) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
            //[mid，end]之间有序，较长段有序序列在后
        } else {
            if (key &amp;gt; arr[mid] &amp;amp;&amp;amp; key &amp;lt;= arr[end]) {
                //判断key在[mid，end]之间，还是在之后
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
    }
    return -1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./10-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(log&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;p&gt;相似问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;给定rotated array(含重复)和key，判断key是否在其中，返回索引&lt;/p&gt;

&lt;p&gt;rotated array：旋转数组，有序数组旋转了有理数个位置，生成两段递增子数组&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./10-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int searchDuplicate(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int key) {
    int start = 0;
    int end = arr.size() - 1;

    while (start &amp;lt;= end) {
        int mid = start + (end - start) / 2;
        if (arr[mid] == key) {
            return mid;
        }
        //左开左开右闭区间

        //当arr[start]=arr[mid]==arr[end]时，无法分辨数组那一部分是有序的
        if((arr[start]==arr[mid])&amp;amp;&amp;amp;(arr[end]==arr[mid])){
            //跳过一位
            start++;
            end--;

            //[start,mid]之间有序，较长段有序序列在前
        }else if (arr[start] &amp;lt;= arr[mid]) {
            //判断key在[start,mid]之间，还是在之后
            if (key &amp;gt;= arr[start] &amp;amp;&amp;amp; key &amp;lt; arr[mid]) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
            
            //[mid，end]之间有序，较长段有序序列在后
        } else {
            if (key &amp;gt; arr[mid] &amp;amp;&amp;amp; key &amp;lt;= arr[end]) {
                //判断key在[mid，end]之间，还是在之后
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
    }
    return -1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(log&lt;em&gt;N&lt;/em&gt;)，最坏： &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;11-rotation-count&#34;&gt;11、rotation count&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求旋转数组(无重复)旋转了几个位置&lt;/p&gt;

&lt;p&gt;等同于求最小值的索引&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./11-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./11-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int countRotations(const vector&amp;lt;int&amp;gt; &amp;amp;arr) {
    int start = 0;
    int end = arr.size() - 1;

    while (start &amp;lt; end) {
        int mid = start + (end - start) / 2;

        //最小值前面全是比它大的元素
        if (mid &amp;lt; end &amp;amp;&amp;amp; arr[mid] &amp;gt; arr[mid + 1]) {
            return mid +1;
        }
        if (mid &amp;gt; start &amp;amp;&amp;amp; arr[mid - 1] &amp;gt; arr[mid]) {
            return mid;
        }

        //左侧有序，最小值在右面
        if (arr[start] &amp;lt; arr[mid]) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(log&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;p&gt;相似问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;求旋转数组(有重复)旋转了几个位置&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./11-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int countRotationsDuplicate(const vector&amp;lt;int&amp;gt; &amp;amp;arr) {
    int start = 0;
    int end = arr.size() - 1;

    while (start &amp;lt; end) {
        int mid = start + (end - start) / 2;

        //最小值前面全是比它大的元素
        if (mid &amp;lt; end &amp;amp;&amp;amp; arr[mid] &amp;gt; arr[mid + 1]) {
            return mid + 1;
        }
        if (mid &amp;gt; start &amp;amp;&amp;amp; arr[mid - 1] &amp;gt; arr[mid]) {
            return mid;
        }

        //arr[start] = arr[end] =arr[mid]，挑一步
        if (arr[start] == arr[end] &amp;amp;&amp;amp; arr[end] == arr[mid]) {
            if (arr[start] &amp;gt; arr[start + 1]) {
                return start + 1;
            }
            start++;
            if (arr[end - 1] &amp;gt; arr[end]) {
                return end;
            }
            end--;

            //左侧有序，最小值在右面
        } else if (arr[start] &amp;lt; arr[mid] || (arr[start] == arr[mid]) &amp;amp;&amp;amp; (arr[mid] &amp;gt; arr[end])) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(log&lt;em&gt;N&lt;/em&gt;)，最坏： &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>pattern-11 Subsets</title>
      <link>/code/pattern/subsets/</link>
      <pubDate>Sat, 23 May 2020 17:53:35 +0800</pubDate>
      <guid>/code/pattern/subsets/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;p&gt;解决排列和组合问题，使用广度优先算法&lt;/p&gt;

&lt;h2 id=&#34;2-subsets&#34;&gt;2、subsets&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定不含重复元素的集合，求其所有不同的子集&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 3]

output:	[], [1], [3], [1, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 5, 3]

output:	[], [1], [3], [5] ,[1, 3], [1, 5], [3 ,5],[1 ,3 ,5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; findSubsets(const vector&amp;lt;int&amp;gt;&amp;amp;nums){
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsets;
    subsets.push_back(vector&amp;lt;int&amp;gt;());
	//取已经有的子集，插入新的元素，生成新的子集
    for(auto currentNumber: nums){
        int n=subsets.size();
        for(int i=0;i&amp;lt;n;i++){
            vector&amp;lt;int&amp;gt; set(subsets[i]);
            set.push_back(currentNumber);
            subsets.push_back(set);
        }
    }
    return subsets;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(2^&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(2^&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;3-subsets-with-duplicates&#34;&gt;3、subsets with Duplicates&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定含重复元素的集合，求其所有不同的子集&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 3, 3]

output:	[], [1], [3], [1, 3], [3, 3], [1, 3, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 5, 3, 3]

output:	[], [1], [3], [5], [1, 5] ,[1, 3], [1, 5, 3], [3, 3], [1, 3, 3],[5 ,3], [3,3,5],[1, 5, 3, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; findSubsets(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    sort(nums.begin(), nums.end());
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsets;
    subsets.push_back(vector&amp;lt;int&amp;gt;());
    int startIndex = 0;
    int endIndex = 0;
    
    //当遇到重复的元素时，取上一步生成的子集，插入新的元素，生成新的子集
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        startIndex = 0;
        if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1]) {
            startIndex = endIndex + 1;
        }
        endIndex = subsets.size() - 1;
        for (int j = startIndex; j &amp;lt;= endIndex; j++) {
            vector&amp;lt;int&amp;gt; set(subsets[j]);
            set.push_back(nums[i]);
            subsets.push_back(set);
        }
    }
    return subsets;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./3-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(2^&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(2^&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;4-permutations&#34;&gt;4、permutations&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定不含重复元素的集合，求其所有排列&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 3, 5]

output:	[1, 3, 5], [1 ,5, 3], [3, 5, 1], [3, 1, 5], [5, 1, 3], [5, 3, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; findPermutations(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;
    queue&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permutations;

    permutations.push(vector&amp;lt;int&amp;gt;());
    for (auto currentNumber:nums) {
        int n = permutations.size();
        for (int i = 0; i &amp;lt; n; i++) {
            vector&amp;lt;int&amp;gt; oldPermutation = permutations.front();
            permutations.pop();
            
            //添加currentNumber ，到所有的position
            for (int j = 0; j &amp;lt;= oldPermutation.size(); j++) {
                vector&amp;lt;int&amp;gt; newPermutations(oldPermutation);
                newPermutations.insert(newPermutations.begin() + j, currentNumber);

                if (newPermutations.size() == nums.size()) {
                    result.push_back(newPermutations);
                } else {
                    permutations.push(newPermutations);
                }
            }
        }
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./4-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;递归的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void generatePermutationsRecursive(vector&amp;lt;int&amp;gt; &amp;amp;nums, int numsIndex,
                                   vector&amp;lt;int&amp;gt; &amp;amp;currentPermutation, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;result) {
    if (numsIndex == nums.size()) {
        result.push_back(currentPermutation);
    } else {
        for (int i = 0; i &amp;lt;= currentPermutation.size(); i++) {
            vector&amp;lt;int&amp;gt; newPermutation(currentPermutation);
            newPermutation.insert(newPermutation.begin() + i, nums[numsIndex]);
            generatePermutationsRecursive(nums, numsIndex + 1, newPermutation, result);

        }
    }
}

vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; generatePermutation(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;
    vector&amp;lt;int&amp;gt; currentPermutation;
    
    generatePermutationsRecursive(nums, 0, currentPermutation, result);
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; * &lt;em&gt;N !&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; * &lt;em&gt;N !&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;5-string-permutation-by-changing-case&#34;&gt;5、string permutation by changing case&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定字符串，保留原序列，只改变字母的大小写，求所有排列&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;ad52&amp;quot;
  
ouput:	&amp;quot;ad52&amp;quot; ,&amp;quot;Ad52&amp;quot;, &amp;quot;aD52&amp;quot;, &amp;quot;AD52&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;ab7c&amp;quot;
  
ouput:	&amp;quot;ab7c&amp;quot;, &amp;quot;Ab7c&amp;quot;,&amp;quot;aB7c&amp;quot;,&amp;quot;ab7C&amp;quot;,&amp;quot;AB7c&amp;quot;,&amp;quot;Ab7C&amp;quot;,&amp;quot;aB7C&amp;quot;,&amp;quot;AB7C&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;string&amp;gt; findLetterCaseStringPermutation(const string &amp;amp;str) {
    vector&amp;lt;string&amp;gt; permutations;
    if (str == &amp;quot;&amp;quot;) {
        return permutations;
    }
    permutations.push_back(str);

    for (int i = 0; i &amp;lt; str.length(); i++) {
        if (isalpha(str[i])) {
            int n = permutations.size();
            for (int j = 0; j &amp;lt; n; j++) {
                vector&amp;lt;char&amp;gt; chs(permutations[j].begin(), permutations[j].end());
                if (isupper(chs[i])) {
                    chs[i] = tolower(chs[i]);
                } else {
                    chs[i] = toupper(chs[i]);
                }

                permutations.push_back(string(chs.begin(), chs.end()));
            }
        }
    }
    return permutations;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./5-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; * 2^ &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; * 2^ &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;h2 id=&#34;6-balanced-parentheses&#34;&gt;6、balanced parentheses&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定N，求n对（）的合理的组合&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: N=2
    
output:	(()) ,()()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: N=3
    
output:	((())) ,()()(), (())(), ()(()), ((),())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct Parenthesese {
    string str;
    int openCount;
    int closeCount;

    Parenthesese(const string &amp;amp;str, int openCount, int closeCount) : str(str), openCount(openCount),
                                                                     closeCount(closeCount) {};
};

vector&amp;lt;string&amp;gt; generateValidParentheses(int num) {
    vector&amp;lt;string&amp;gt; result;
    queue&amp;lt;Parenthesese&amp;gt; queue;
    queue.push({&amp;quot;&amp;quot;, 0, 0});

    while (!queue.empty()) {
        Parenthesese ps = queue.front();
        queue.pop();

        if (ps.openCount == num &amp;amp;&amp;amp; ps.closeCount == num) {
            result.push_back(ps.str);
        } else {
            if (ps.openCount &amp;lt; num) {
                queue.push({ps.str + &amp;quot;(&amp;quot;, ps.openCount + 1, ps.closeCount});
            }
            if (ps.openCount &amp;gt; ps.closeCount) {
                queue.push({ps.str + &amp;quot;)&amp;quot;, ps.openCount, ps.closeCount + 1});
            }
        }
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :&lt;img src=&#34;./6-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; * 2^ &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;递归方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void generateValidParenthesesRecursive(int num, int openCount, int closeCount, int stringIndex,
                                       vector&amp;lt;char&amp;gt; &amp;amp;parenthesesString, vector&amp;lt;string&amp;gt; &amp;amp;result) {
    if (openCount == num &amp;amp;&amp;amp; closeCount == num) {
        result.push_back(string(parenthesesString.begin(), parenthesesString.end()));

    } else {
        if (openCount &amp;lt; num) {
            parenthesesString[stringIndex] = &#39;(&#39;;
            generateValidParenthesesRecursive(num, openCount+1, closeCount , stringIndex + 1, parenthesesString,
                                              result);
        }
        if (openCount &amp;gt; closeCount) {
            parenthesesString[stringIndex] = &#39;)&#39;;
            generateValidParenthesesRecursive(num, openCount, closeCount + 1, stringIndex + 1, parenthesesString,
                                              result);
        }
    }
}

vector&amp;lt;string&amp;gt; generateValidParentheses2(int num) {
    vector&amp;lt;string&amp;gt; result;
    vector&amp;lt;char&amp;gt; parenthesesString(2 * num);
    generateValidParenthesesRecursive(num, 0, 0, 0, parenthesesString, result);
    return result;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;7-unique-generalized-abbreviations&#34;&gt;7、unique generalized abbreviations&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;没看懂题目&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;8-evaluate-expression&#34;&gt;8、evaluate expression&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定只包含0-9和+ - *的表达式，计算表达式加上括号后所有合理的运算结果&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;1+2*3&amp;quot;
   
output:	7,9
  
explanations: 1+(2*3)=7, (1+2)*3=9
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	&amp;quot;2*3-4-5&amp;quot;
   
output:	8, -12, 7 ,-7 ,-3
  
explanations: 2*(3-(4-5)=8, 2*(3-4-5)=-12, 2*3-(4-5)=7, 2*(3-4)-5=-7, (2*3)-4-5=-3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;int&amp;gt; diffWaysToEvaluateExpression(const string &amp;amp;input) {
    vector&amp;lt;int&amp;gt; result;
    //有两个字符串a、b, 判断a字符串是否包含b字符串，用到string库中的find函数与npos参数。
    //string::npos参数：npos 是一个常数，用来表示不存在的位置
    if (input.find(&#39;+&#39;, 0) == string::npos &amp;amp;&amp;amp;
        input.find(&amp;quot;-&amp;quot;) == string::npos &amp;amp;&amp;amp; input.find(&amp;quot;*&amp;quot;) == string::npos) {

    }
    if (input.find(&amp;quot;+&amp;quot;) == string::npos &amp;amp;&amp;amp;
        input.find(&amp;quot;-&amp;quot;) == string::npos &amp;amp;&amp;amp; input.find(&amp;quot;*&amp;quot;) == string::npos) {

        result.push_back(stoi(input));
    } else {

        for (int i = 0; i &amp;lt; input.length(); i++) {
            char chr = input[i];
            if (!isdigit(chr)) {
                vector&amp;lt;int&amp;gt; leftParts = diffWaysToEvaluateExpression(input.substr(0, i));
                vector&amp;lt;int&amp;gt; rightParts = diffWaysToEvaluateExpression(input.substr(i + 1));
                for (auto part1:leftParts) {
                    for (auto part2:rightParts) {
                        if (chr == &#39;+&#39;) {
                            result.push_back(part1 + part2);
                        } else if (chr == &#39;-&#39;) {
                            result.push_back(part1 - part2);
                        } else if (chr == &#39;*&#39;) {
                            result.push_back(part1 * part2);
                        }
                    }
                }
            }

        }
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : 实际：&lt;img src=&#34;./6-1.png&#34; alt=&#34;&#34; /&gt;  估计：&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; * 2^ &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : 实际：&lt;img src=&#34;./6-1.png&#34; alt=&#34;&#34; /&gt;估计：O*( 2^ &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;节省空间的方法：&lt;/p&gt;

&lt;p&gt;有大量重复计算的值，用哈希表存储中间值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;unordered_map&amp;lt;string, vector&amp;lt;int&amp;gt;&amp;gt; map = unordered_map&amp;lt;string, vector&amp;lt;int&amp;gt;&amp;gt;();

vector&amp;lt;int&amp;gt; diffWaysToEvaluateExpression2(const string &amp;amp;input) {
    if (map.find(input) != map.end()) {
        return map[input];
    }
    vector&amp;lt;int&amp;gt; result;
    if (input.find(&amp;quot;+&amp;quot;) == string::npos &amp;amp;&amp;amp;
        input.find(&amp;quot;-&amp;quot;) == string::npos &amp;amp;&amp;amp; input.find(&amp;quot;*&amp;quot;) == string::npos) {

        result.push_back(stoi(input));
    } else {

        for (int i = 0; i &amp;lt; input.length(); i++) {
            char chr = input[i];
            if (!isdigit(chr)) {
                vector&amp;lt;int&amp;gt; leftParts = diffWaysToEvaluateExpression(input.substr(0, i));
                vector&amp;lt;int&amp;gt; rightParts = diffWaysToEvaluateExpression(input.substr(i + 1));
                for (auto part1:leftParts) {
                    for (auto part2:rightParts) {
                        if (chr == &#39;+&#39;) {
                            result.push_back(part1 + part2);
                        } else if (chr == &#39;-&#39;) {
                            result.push_back(part1 - part2);
                        } else if (chr == &#39;*&#39;) {
                            result.push_back(part1 * part2);
                        }
                    }
                }
            }
        }
    }
    map[input] = result;
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;9-structurally-unique-binary-search-trees&#34;&gt;9、structurally unique binary search trees&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定N，求节点值为1-n的二叉查找树&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./9-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./9-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;TreeNode *&amp;gt; findUniqueTreeRecursive(int start, int end) {
    vector&amp;lt;TreeNode *&amp;gt; result;

    if (start &amp;gt; end) {
        result.push_back(NULL);
        return result;
    }
    for (int i = start; i &amp;lt;= end; i++) {
        vector&amp;lt;TreeNode *&amp;gt; leftSubsets = findUniqueTreeRecursive(start, i - 1);
        vector&amp;lt;TreeNode *&amp;gt; rightSubsets = findUniqueTreeRecursive(i + 1, end);
        for (auto leftTree:leftSubsets) {
            for (auto rightTree :rightSubsets) {
                TreeNode *root = new TreeNode(i);
                root-&amp;gt;left = leftTree;
                root-&amp;gt;right = rightTree;
                result.push_back(root);
            }
        }
    }
    return result;
}

vector&amp;lt;TreeNode *&amp;gt; findUniqueTrees(int n) {
    if (n &amp;lt;= 0) {
        return vector&amp;lt;TreeNode *&amp;gt;();

    } else {
        return findUniqueTreeRecursive(1, n);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : 实际：&lt;img src=&#34;./6-1.png&#34; alt=&#34;&#34; /&gt;  估计：&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; * 2^ &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : 实际：&lt;img src=&#34;./6-1.png&#34; alt=&#34;&#34; /&gt;估计：O*( 2^ &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;h2 id=&#34;10-count-of-structurally-unique-binary-search-tree&#34;&gt;10、count of structurally unique binary search tree&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定N，求节点值为1-n的二叉查找树的个数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./10-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int countTrees(int n) {
    if (n &amp;lt;= 1) return 1;
    int count = 0;
    for (int i = 1; i &amp;lt;= n; i++) {
        int countOfLeftSubtrees = countTrees(i - 1);
        int countOfRightSubtrees = countTrees(n - i);
        count += countOfLeftSubtrees * countOfRightSubtrees;
    }
    return count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : 实际：&lt;img src=&#34;./6-1.png&#34; alt=&#34;&#34; /&gt;  估计：&lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; * 2^ &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : 实际：&lt;img src=&#34;./6-1.png&#34; alt=&#34;&#34; /&gt;估计：O*( 2^ &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;节省空间的方法：&lt;/p&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;unordered_map&amp;lt;int, int&amp;gt; map = unordered_map&amp;lt;int, int&amp;gt;();

int countTrees2(int n) {
    if (map.find(n) != map.end()) {
        return map[n];
    }
    if (n &amp;lt;= 1) return 1;
    int count = 0;
    for (int i = 1; i &amp;lt;= n; i++) {
        int countOfLeftSubtrees = countTrees(i - 1);
        int countOfRightSubtrees = countTrees(n - i);
        count += countOfLeftSubtrees * countOfRightSubtrees;
    }
    map[n] = n;
    return count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : O&lt;em&gt;(&lt;/em&gt; &lt;em&gt;N&lt;/em&gt; ^ 2)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-10 Two Heaps</title>
      <link>/code/pattern/two-heaps/</link>
      <pubDate>Sat, 23 May 2020 17:53:19 +0800</pubDate>
      <guid>/code/pattern/two-heaps/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;p&gt;给定一组可以划分成两个部分的元素，要求我们求一部分的最小元素，另一部分的最大元素，用two heaps ：Min Heap和Max Heap，可以解决这类的问题，。&lt;/p&gt;

&lt;h2 id=&#34;2-find-the-median-of-a-number-stream&#34;&gt;2、find the median of a number stream&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;设计一个类，能够计算数据流中的中位数，类必须包含两个函数：&lt;/p&gt;

&lt;p&gt;insertNum(int num) :存储数据&lt;/p&gt;

&lt;p&gt;findMedian() : 返回所有存储进类的数据流的中位数&lt;/p&gt;

&lt;p&gt;如果数据为奇数个，则中位数为中间两个数之和&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./2-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class MedianOfStream{
    priority_queue&amp;lt;int&amp;gt; maxHeap;
    priority_queue&amp;lt;int,vector&amp;lt;int&amp;gt;,greater&amp;lt;int&amp;gt;&amp;gt; minHeap;

    void insertNum(int num){
        //小数存储在大顶堆，大数存储在小顶堆
        //大顶堆个数==[小顶堆，小顶堆+1]
        if(maxHeap.empty()||maxHeap.top()&amp;gt;=num){
            maxHeap.push(num);
        } else{
            minHeap.push(num);
        }


        if(maxHeap.size()&amp;gt;minHeap.size()+1){
            minHeap.push(maxHeap.top());
            maxHeap.pop();
        }else if(maxHeap.size()&amp;lt;minHeap.size()){
            maxHeap.push(minHeap.top());
            minHeap.pop();
        }
    }

    double findMedian(){
        if(maxHeap.size()==minHeap.size()){
            return (maxHeap.top()+minHeap.top())/2.0
        }
        return maxHeap.top()
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-sliding-window-median&#34;&gt;3、sliding window median&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定数组和K值，求所有长度为k的连续子数组的中位数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 2, -1, 3, 5]， k=2
    
output:	[1.5, 0.5, 1.0, 4.0]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 2, -1, 3, 5]， k=3
    
output:	[1.0, 2.0, 3.0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;同上 + 滑动窗口 + 增加queue删除特定的值？
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N * K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;K&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;4-maximun-capital&#34;&gt;4、maximun capital&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定一组投资项目，已知项目所需投资资金，项目盈利、初始资金、投资的项目个数，求最大剩余的资金&lt;/p&gt;

&lt;p&gt;先前投资的（盈利+本钱）可作为后续投资的资金 ,&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	project capitals:[0, 1 ,2]
		project profits:[1, 2, 3]
		initial capital:1
		number of project:2
            
output:	6
    
explanations：
    1、先投资第2个(所需资金1，盈利2)项目。得到1+2=3(本金+盈利)投资基金
    2、再投资第3个(所需资金2，盈利3)项目。得到3+3=6(本金+盈利)投资基金
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	project capitals:[0, 1 ,2, 3]
		project profits:[1, 2, 3, 5]
		initial capital:0
		number of project:3
            
output:	8
    
explanations：
    1、先投资第1个(所需资金0，盈利1)项目。得到0+1=1(本金+盈利)投资基金
    2、再投资第2个(所需资金1，盈利2)项目。得到1+2=3(本金+盈利)投资基金
    3、再投资第4个(所需资金3，盈利5)项目。得到3+5=8(本金+盈利)投资基金
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_greater_capital {
    bool operator()(const pair&amp;lt;int, int&amp;gt; &amp;amp;x, const pair&amp;lt;int, int&amp;gt; &amp;amp;y) {
        return x.first &amp;gt; y.first;
    }
};

struct cmp_smaller_profit {
    bool operator()(const pair&amp;lt;int, int&amp;gt; &amp;amp;x, const pair&amp;lt;int, int&amp;gt; &amp;amp;y) {
        return x.first &amp;lt; y.first;
    }
};

int maximumCapitals(const vector&amp;lt;int&amp;gt; &amp;amp;capital, const vector&amp;lt;int&amp;gt; &amp;amp;profits, int numOfProject, int initialCapital) {
    int n = profits.size();
    priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;, cmp_greater_capital&amp;gt; minCapitalHeap;

    priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;, cmp_smaller_profit&amp;gt; maxProfitHeap;


    for (int i = 0; i &amp;lt; n; i++) {
        minCapitalHeap.push(make_pair(capital[i], i));
    }

    int result = initialCapital;

    for (int i = 0; i &amp;lt; numOfProject; i++) {
        while (!minCapitalHeap.empty() &amp;amp;&amp;amp; minCapitalHeap.top().first &amp;lt;= result) {
            auto capitalIndex = minCapitalHeap.top().second;
            minCapitalHeap.pop();
            maxProfitHeap.push({profits[capitalIndex], capitalIndex});
        }

        if (maxProfitHeap.empty()) {
            break;
        }

        result += maxProfitHeap.top().first;
        maxProfitHeap.pop();
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N log N&lt;/em&gt; + &lt;em&gt;K log K&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;5-next-interval&#34;&gt;5、next interval&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;没看懂&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-9 Tree Depth First Search</title>
      <link>/code/pattern/tree-depth-first-search/</link>
      <pubDate>Sat, 23 May 2020 17:51:56 +0800</pubDate>
      <guid>/code/pattern/tree-depth-first-search/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;深度遍历，树的一种遍历方式，在遍历过程中用递归或栈记录所有父节点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;2-binary-tree-path-sum&#34;&gt;2、binary tree path sum&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定二叉树和数S，判断是否有从根到叶子的路径，使得此路径所有节点的和等于S&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./2-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool hasPath(TreeNode *root, int sum) {
    if (root == NULL) {
        return false;
    }
    if (root-&amp;gt;val == sum &amp;amp;&amp;amp; root-&amp;gt;left == NULL &amp;amp;&amp;amp; root-&amp;gt;right == NULL) {
        return true;
    }

    return hasPath(root-&amp;gt;left, sum - root-&amp;gt;val) || 
           hasPath(root-&amp;gt;right, sum - root-&amp;gt;val);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./2-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h2 id=&#34;3-all-paths-for-a-sum&#34;&gt;3、all Paths for a sum&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定二叉树和数S，求所有从根到叶子的路径，路径所有节点的和等于S&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./3-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;
void findPathRecursive(TreeNode *currentNode, int sum,
           vector&amp;lt;int&amp;gt; &amp;amp;currentPath, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;allPaths) {

    if (currentNode == NULL) {
        return;
    }

    currentPath.push_back(currentNode-&amp;gt;val);
    if (currentNode-&amp;gt;val == sum &amp;amp;&amp;amp; currentNode-&amp;gt;left == NULL &amp;amp;&amp;amp; currentNode-&amp;gt;right == NULL) {
        allPaths.push_back(vector&amp;lt;int&amp;gt;(currentPath));

    } else {
        findPathRecursive(currentNode-&amp;gt;left, sum - currentNode-&amp;gt;val, currentPath, allPaths);
        
        findPathRecursive(currentNode-&amp;gt;right, sum - currentNode-&amp;gt;val, currentPath, allPaths);
    }
    //为了回溯,删除currentNode
    currentPath.pop_back();
}

vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; findPaths(TreeNode *root, int sum) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; allPaths;
    vector&amp;lt;int&amp;gt; currentPath;

    findPathRecursive(root, sum, currentPath, allPaths);
    
    return allPaths;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;^2)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; log&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;相似问题1：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;求所有根到叶子的路径&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void findAllPathRecursive(TreeNode *currentNode,
                       vector&amp;lt;int&amp;gt; &amp;amp;currentPath, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;allPaths) {

    if (currentNode == NULL) {
        return;
    }
    currentPath.push_back(currentNode-&amp;gt;val);

    if ( currentNode-&amp;gt;left == NULL &amp;amp;&amp;amp; currentNode-&amp;gt;right == NULL) {
        allPaths.push_back(vector&amp;lt;int&amp;gt;(currentPath));

    }else{
        findAllPathRecursive(currentNode-&amp;gt;left,  currentPath, allPaths);
        findAllPathRecursive(currentNode-&amp;gt;right, currentPath, allPaths);
    }
    
    //为了回溯，删除currentNode,
    currentPath.pop_back();
}

vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; findAllPaths(TreeNode *root) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; allPaths;
    vector&amp;lt;int&amp;gt; currentPath;

    findAllPathRecursive(root,currentPath, allPaths);

    return allPaths;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相似问题2：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;和最大的路径&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void findMaxPathRecursive(TreeNode *currentNode,
                          int &amp;amp;currentSum, int &amp;amp;maxPathSum) {

    if (currentNode == NULL) {
        return;
    }
    currentSum += currentNode-&amp;gt;val;

    if (currentNode-&amp;gt;left == NULL &amp;amp;&amp;amp; currentNode-&amp;gt;right == NULL) {
        maxPathSum = max(maxPathSum, currentSum);

    } else {
        findMaxPathRecursive(currentNode-&amp;gt;left, currentSum, maxPathSum);
        findMaxPathRecursive(currentNode-&amp;gt;right, currentSum, maxPathSum);
    }

    //为了回溯，删除currentNode-val,
    currentSum -= currentNode-&amp;gt;val;
}

int findMaxPath(TreeNode *root) {
    int maxPathSum = INT_MIN;
    int currentSum = 0;

    findMaxPathRecursive(root, currentSum, maxPathSum);

    return maxPathSum;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-sum-of-path-numbers&#34;&gt;4、sum of path numbers&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定二叉树，节点值在 0 - 9，从根到叶子节点的代表一个整数，求所有路径之和&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./4-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findRootToLeafPathNumbers(TreeNode *currentNode, int pathSum) {

    if (currentNode == NULL) {
        return 0;
    }

    pathSum = 10 * pathSum + currentNode-&amp;gt;val;

    if (currentNode-&amp;gt;left == NULL &amp;amp;&amp;amp; currentNode-&amp;gt;right == NULL) {
        return pathSum;

    }

    return findRootToLeafPathNumbers(currentNode-&amp;gt;left, pathSum) +
           findRootToLeafPathNumbers(currentNode-&amp;gt;right, pathSum);
}

int findSumOfPathNUmbers(TreeNode *root) {

    return findRootToLeafPathNumbers(root, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;5-path-with-given-sequence&#34;&gt;5、path with given sequence&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定二叉树和序列，序列代表从根到叶子节点的路径，判断序列代表的路径是否在树上&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./5-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;
bool findPathRecursive(TreeNode *currentNode, const vector&amp;lt;int&amp;gt; &amp;amp;sequence, int sequenceIndex) {
    if (currentNode == NULL) {
        return false;
    }
    

    if (sequenceIndex &amp;gt;= sequence.size() || currentNode-&amp;gt;val != sequence[sequenceIndex]) {
        return false;
    }
    if (currentNode-&amp;gt;left == NULL &amp;amp;&amp;amp; currentNode-&amp;gt;right == NULL &amp;amp;&amp;amp; sequenceIndex == sequence.size() - 1) {
        return true;
    }

    return findPathRecursive(currentNode-&amp;gt;left, sequence, sequenceIndex + 1) ||
           findPathRecursive(currentNode-&amp;gt;right, sequence, sequenceIndex + 1);

}

bool findPath(TreeNode *root, const vector&amp;lt;int&amp;gt; &amp;amp;sequence) {
    if (root == NULL) {
        return sequence.empty();
    }

    return findPathRecursive(root, sequence, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;6-tree-diameter&#34;&gt;6、tree diameter&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定二叉树，求其diameter(直径)：两叶子结点之间的最长路径。最长直径可能不经过根节点。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./6-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int calculateHeight(TreeNode *currentNode, int &amp;amp;treeDiameter) {
    if (currentNode == NULL) {
        return 0;
    }

    int leftTreeHeight = calculateHeight(currentNode-&amp;gt;left, treeDiameter);
    int rightTreeHeight = calculateHeight(currentNode-&amp;gt;right, treeDiameter);
    //currentNode的直径是左子树的高度+右子树的高度+1
    int diameter = leftTreeHeight + rightTreeHeight + 1;

    //更新整个树的最大直径
    treeDiameter = max(treeDiameter, diameter);

    return max(leftTreeHeight, rightTreeHeight) + 1;
}

int findDiameter(TreeNode *root) {
    int treeDiameter = 0;
    calculateHeight(root, treeDiameter);
    return treeDiameter;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;7-path-with-max-sum&#34;&gt;7、path with max sum&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定二叉树， 求任意两节点之间路径的最大和，不必经过根节点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./7-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findMaximumPathSumRecursive(TreeNode *currentNode, int &amp;amp;globalMaximumSum) {
    if (currentNode == NULL) {
        return 0;
    }

    int maxPathSumFromLeft = findMaximumPathSumRecursive(currentNode-&amp;gt;left, globalMaximumSum);
    int maxPathSumFromRight = findMaximumPathSumRecursive(currentNode-&amp;gt;right, globalMaximumSum);

    //忽略sum=0 的path
    maxPathSumFromLeft = max(maxPathSumFromLeft, 0);
    maxPathSumFromRight = max(maxPathSumFromRight, 0);

    //当前节点的maximumPathSum
    int localMaximumSum = maxPathSumFromLeft + maxPathSumFromRight + currentNode-&amp;gt;val;

    //更新全局maximum Sum
    globalMaximumSum = max(globalMaximumSum, localMaximumSum);

    //经过当前节点所有路径中最大的Sum
    return max(maxPathSumFromLeft, maxPathSumFromRight) + currentNode-&amp;gt;val;

}

int findMaximumPathSum(TreeNode *root) {
    int globalMaximum = INT_MIN;
    findMaximumPathSumRecursive(root, globalMaximum);
    return globalMaximum;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-8 Tree Breadth First Search</title>
      <link>/code/pattern/tree-breadth-first-search/</link>
      <pubDate>Sat, 23 May 2020 17:50:19 +0800</pubDate>
      <guid>/code/pattern/tree-breadth-first-search/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;p&gt;广度遍历，树的一种遍历方式，常用来解决需要一层一层遍历的问题&lt;/p&gt;

&lt;h2 id=&#34;2-binary-tree-level-order-traversal&#34;&gt;2、binary tree level order Traversal&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;层序遍历，每层单独放进数组，每层自顶向下，自左向右&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./2-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//struct TreeNode {
//    int val;
//    TreeNode *left;
//    TreeNode *right;

//    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
//};
vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; traverse(TreeNode *root) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;
    queue&amp;lt;TreeNode *&amp;gt; queue;
    
    if (root == NULL) {
        return result;
    }
    queue.push(root);
    while (!queue.empty()) {
        int levelSize = queue.size();
        vector&amp;lt;int&amp;gt; currentLevel;
        
        for (int i = 0; i &amp;lt; levelSize; i++) {
            TreeNode *currentNode = queue.front();
            queue.pop();
            currentLevel.push_back(currentNode-&amp;gt;val);
            
            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
        result.push_back(currentLevel);
    }
    return result;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./2-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h2 id=&#34;3-reverse-level-order-traversal&#34;&gt;3、reverse level order traversal&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;层序遍历，每层单独放进数组，每层自底向上，自左向右&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./3-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;deque&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; traverse(TreeNode *root) {
    deque&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;
    queue&amp;lt;TreeNode *&amp;gt; queue;

    if (root == NULL) {
        return result;
    }

    queue.push(root);
    while (!queue.empty()) {
        int levelSize = queue.size();
        vector&amp;lt;int&amp;gt; currentLevel;

        for (int i = 0; i &amp;lt; levelSize; i++) {
            TreeNode *currentNode = queue.front();
            queue.pop();
            currentLevel.push_back(currentNode-&amp;gt;val);

            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
        result.push_front(currentLevel);
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h2 id=&#34;4-zigzag-traversal&#34;&gt;4、zigzag traversal&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;层序遍历，每层单独放进数组，每层自顶向下，自左向右和自右向左交替进行&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./4-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; traverse(TreeNode *root) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;
    queue&amp;lt;TreeNode *&amp;gt; queue;
    bool leftToRight = true;

    if (root == NULL) {
        return result;
    }

    queue.push(root);
    while (!queue.empty()) {
        int levelSize = queue.size();
        vector&amp;lt;int&amp;gt; currentLevel(levelSize);

        for (int i = 0; i &amp;lt; levelSize; i++) {
            TreeNode *currentNode = queue.front();
            queue.pop();
            if (leftToRight) {
                currentLevel[i] = currentNode-&amp;gt;val;
            } else {
                currentLevel[levelSize - 1 - i] = currentNode-&amp;gt;val;
            }


            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
        result.push_back(currentLevel);
        leftToRight = !leftToRight;
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h2 id=&#34;5-level-averages-in-a-binary-tree&#34;&gt;5 、level averages in a binary tree&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;层序遍历，计算每一层的平均值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./5-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;double&amp;gt; findLevelAverages(TreeNode *root) {
    vector&amp;lt;double&amp;gt; result;
    queue&amp;lt;TreeNode *&amp;gt; queue;

    if (root == NULL) {
        return result;
    }

    queue.push(root);
    while (!queue.empty()) {
        int levelSize = queue.size();
        vector&amp;lt;int&amp;gt; currentLevel(levelSize);
        double levelSum = 0;

        for (int i = 0; i &amp;lt; levelSize; i++) {
            TreeNode *currentNode = queue.front();
            queue.pop();
            
            levelSum += currentNode-&amp;gt;val;

            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
        result.push_back(levelSum / levelSize);
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;相似问题1：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;求每一层的最大值,和最小值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; findLevelLargestAndSmallest(TreeNode *root) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;
    queue&amp;lt;TreeNode *&amp;gt; queue;

    if (root == NULL) {
        return result;
    }

    queue.push(root);
    while (!queue.empty()) {
        int levelSize = queue.size();
        vector&amp;lt;int&amp;gt; currentLevel(levelSize);
        int maxValue = INT_MIN;
        int minValue = INT_MAX;
        for (int i = 0; i &amp;lt; levelSize; i++) {
            TreeNode *currentNode = queue.front();
            queue.pop();

            maxValue = max(maxValue, currentNode-&amp;gt;val);
            minValue = min(minValue, currentNode-&amp;gt;val);
            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
        result.push_back({maxValue, minValue});
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h2 id=&#34;6-minimum-depth-of-a-binary-tree&#34;&gt;6、minimum depth of a binary tree&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求二叉树最小深度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./6-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int  findMinDepth(TreeNode *root) {
    if (root == NULL) {
        return 0;
    }

    int minimumTreeDepth=0;
    queue&amp;lt;TreeNode*&amp;gt; queue;

    queue.push(root);
    while (!queue.empty()) {
        minimumTreeDepth++;
        int levelSize = queue.size();
        
        for (int i = 0; i &amp;lt; levelSize; i++) {
            TreeNode *currentNode = queue.front();
            queue.pop();

            if(currentNode-&amp;gt;left==NULL&amp;amp;&amp;amp;currentNode-&amp;gt;right==NULL){
                //一旦遇到叶子节点，结束
                return minimumTreeDepth;
            }

            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
    }
    return minimumTreeDepth;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;相似问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;求二叉树最大深度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findMaxDepth(TreeNode *root) {
    if (root == NULL) {
        return 0;
    }

    int maximumTreeDepth = 0;
    queue&amp;lt;TreeNode *&amp;gt; queue;

    queue.push(root);
    while (!queue.empty()) {
        
        maximumTreeDepth++;
        int levelSize = queue.size();

        for (int i = 0; i &amp;lt; levelSize; i++) {
            TreeNode *currentNode = queue.front();
            queue.pop();
			//一直遍历
            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
    }
    return maximumTreeDepth;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h2 id=&#34;7-level-order-successor&#34;&gt;7、level order successor&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求层序遍历某一节点的后继&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./7-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;TreeNode *findSuccessor(TreeNode *root, int key) {
    if (root == NULL) {
        return NULL;
    }

    queue&amp;lt;TreeNode *&amp;gt; queue;

    queue.push(root);
    while (!queue.empty()) {

        TreeNode *currentNode = queue.front();
        queue.pop();

        if (currentNode-&amp;gt;left != NULL) {
            queue.push(currentNode-&amp;gt;left);
        }
        if (currentNode-&amp;gt;right != NULL) {
            queue.push(currentNode-&amp;gt;right);
        }
        if (currentNode-&amp;gt;val == key) {
            break;
        }
    }
    return queue.front();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h2 id=&#34;8-connect-level-order-siblings&#34;&gt;8、connect level order siblings&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;让所有节点指向其层序遍历的后继，每一层最后一个节点指向NULL&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./8-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode *next;

    TreeNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
};

void connect(TreeNode *root) {
    if (root == NULL) {
        return;
    }

    queue&amp;lt;TreeNode *&amp;gt; queue;

    queue.push(root);
    while (!queue.empty()) {
        TreeNode *previousNode = NULL;
        int levelSize = queue.size();

        for (int i = 0; i &amp;lt; levelSize; i++) {
            TreeNode *currentNode = queue.front();
            queue.pop();

            if (previousNode != NULL) {
                previousNode-&amp;gt;next = currentNode;
            }

            previousNode = currentNode;

            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h2 id=&#34;9-connect-all-level-order-siblings&#34;&gt;9、connect all level order siblings&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;连接层序遍历的后继节点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./9-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode *next;

    TreeNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
};

void connect(TreeNode *root) {
    if (root == NULL) {
        return;
    }

    queue&amp;lt;TreeNode *&amp;gt; queue;

    queue.push(root);
    TreeNode *previousNode = NULL;
    TreeNode *currentNode = NULL;
    while (!queue.empty()) {

        int levelSize = queue.size();

        for (int i = 0; i &amp;lt; levelSize; i++) {
            currentNode = queue.front();
            queue.pop();

            if (previousNode != NULL) {
                previousNode-&amp;gt;next = currentNode;
            }
            previousNode = currentNode;

            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h2 id=&#34;10-right-view-of-a-binary-tree&#34;&gt;10、right view of a binary tree&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求二叉树从右侧看到的所有节点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./10-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;TreeNode *&amp;gt; traverse(TreeNode *root) {
    vector&amp;lt;TreeNode *&amp;gt; result;
    queue&amp;lt;TreeNode *&amp;gt; queue;

    if (root == NULL) {
        return result;
    }

    queue.push(root);
    while (!queue.empty()) {
        int levelSize = queue.size();
        vector&amp;lt;int&amp;gt; currentLevel(levelSize);


        for (int i = 0; i &amp;lt; levelSize; i++) {
            TreeNode *currentNode = queue.front();
            queue.pop();

            //如果是这一层的最后一个节点放入result;
            if (i == levelSize - 1) {
                result.push_back(currentNode);
            }

            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;相似问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;求二叉树从左侧看到的所有节点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;TreeNode *&amp;gt; traverse(TreeNode *root) {
    vector&amp;lt;TreeNode *&amp;gt; result;
    queue&amp;lt;TreeNode *&amp;gt; queue;

    if (root == NULL) {
        return result;
    }

    queue.push(root);
    while (!queue.empty()) {
        int levelSize = queue.size();
        vector&amp;lt;int&amp;gt; currentLevel(levelSize);


        for (int i = 0; i &amp;lt; levelSize; i++) {
            TreeNode *currentNode = queue.front();
            queue.pop();

            //如果是这一层的第一个节点放入result;
            if (i == 0) {
                result.push_back(currentNode);
            }

            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h2 id=&#34;11-tree-boundary&#34;&gt;11、tree boundary&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;逆时针输出二叉树的所有边界节点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./11-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./11-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;TreeNode *&amp;gt; findLeavesDFS(TreeNode *root) {
    vector&amp;lt;TreeNode *&amp;gt; leaves;
    stack&amp;lt;TreeNode *&amp;gt; stack;
    stack.push(root);
    while (!stack.empty()) {
        TreeNode *currentNode = stack.top();
        stack.pop();
        if (currentNode-&amp;gt;left == NULL &amp;amp;&amp;amp; currentNode-&amp;gt;right == NULL) {
            leaves.push_back(currentNode);

        }
        if (currentNode-&amp;gt;right != NULL) {
            stack.push(currentNode-&amp;gt;right);
        }
        if (currentNode-&amp;gt;left != NULL) {
            stack.push(currentNode-&amp;gt;left);
        }

    }
    return leaves;

}

vector&amp;lt;TreeNode *&amp;gt; findBoundary(TreeNode *root) {
    if (root == NULL) {
        return vector&amp;lt;TreeNode *&amp;gt;();
    }
    vector&amp;lt;TreeNode *&amp;gt; result;
    vector&amp;lt;TreeNode *&amp;gt; leftView;
    deque&amp;lt;TreeNode *&amp;gt; rightView;

    queue&amp;lt;TreeNode *&amp;gt; queue;
    queue.push(root);
    while (!queue.empty()) {
        int levelSize = queue.size();
        vector&amp;lt;int&amp;gt; currentLevel(levelSize);


        for (int i = 0; i &amp;lt; levelSize; i++) {
            TreeNode *currentNode = queue.front();
            queue.pop();

            //如果是这一层的最后一个节点放入result;
            if (currentNode-&amp;gt;left == NULL &amp;amp;&amp;amp; currentNode-&amp;gt;right == NULL) {
                continue;
            } else if (i == 0) {
                leftView.push_back(currentNode);
            } else if (i == levelSize - 1) {
                rightView.push_front(currentNode);
            }

            if (currentNode-&amp;gt;left != NULL) {
                queue.push(currentNode-&amp;gt;left);
            }
            if (currentNode-&amp;gt;right != NULL) {
                queue.push(currentNode-&amp;gt;right);
            }
        }
    }
    vector&amp;lt;TreeNode *&amp;gt; leaves = findLeavesDFS(root);

    result.insert(result.end(), leftView.begin(), leftView.end());
    result.insert(result.end(), leaves.begin(), leaves.end());
    copy(begin(rightView), end(rightView), back_inserter(result));

    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-7 In Place Reversal of a Linked List</title>
      <link>/code/pattern/in-place-reversal-of-a-linked-list/</link>
      <pubDate>Sat, 23 May 2020 17:49:24 +0800</pubDate>
      <guid>/code/pattern/in-place-reversal-of-a-linked-list/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;p&gt;解决原地逆转链表的问题&lt;/p&gt;

&lt;h2 id=&#34;2-reverse-a-linkedlist&#34;&gt;2、reverse a linkedlist&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;逆转链表&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./2.png&#34; alt=&#34;reverse a linkedlis&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;
ListNode *reverse(ListNode *head) {
    ListNode *current = head;
    ListNode *prev = NULL;
    ListNode *next = NULL;
    while (current != NULL) {
        next = current-&amp;gt;next;
        current-&amp;gt;next = prev;
        prev = current;
        current = next;
    }
    return prev;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./2-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;3-reverse-a-sub-list&#34;&gt;3、reverse a sub-list&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;逆转链表第p个至第q个之间的元素&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./3-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ListNode *reverse(ListNode *head, int p, int q) {
    if (p == q) {
        return head;
    }

    ListNode *current = head;
    ListNode *prev = NULL;

    //让current指向pth Node
    for (int i = 0; current != NULL &amp;amp;&amp;amp; i &amp;lt; p - 1; i++) {
        prev = current;
        current = current-&amp;gt;next;
    }

    //第p-1个元素
    ListNode *lastNodeOfFirstPart = prev;
    //逆转部分最后一个
    ListNode *lastNodeOfSubList = current;
    ListNode *next = NULL;


    for (int i = 0; current != NULL &amp;amp;&amp;amp; i &amp;lt; q - p + 1; i++) {
        next = current-&amp;gt;next;
        current-&amp;gt;next = prev;
        prev = current;
        current = next;
    }

    //链接第一部分
    if (lastNodeOfFirstPart != NULL) {
        lastNodeOfFirstPart-&amp;gt;next = prev;

    } else {
        head = prev;
    }
    //链接后一部分
    lastNodeOfSubList-&amp;gt;next = current;
    return head;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;p&gt;相似问题1&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;逆转前k个元素&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;reverse(head, 1 ,n)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相似问题2&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;偶数个元素，逆转前1/2，后1/2；&lt;/p&gt;

&lt;p&gt;奇数个元素，逆转前1/2，后1/2，中间不变；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;偶数
reverse(head, 1 ,n/2)
reverse(head, 1/2 + 1 ,n)   
  
奇数
reverse(head, 1 ,n/2)
reverse(head, 1/2 + 2 ,n)    
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-reverse-every-k-element-sub-list&#34;&gt;4、reverse every  k-element sub-list&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定链表和整数K，每次逆转K个元素&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./4-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ListNode *reverse(ListNode *head, int k) {
    if (k &amp;lt;= 1 || head == NULL) {
        return head;
    }

    ListNode *current = head;
    ListNode *prev = NULL;

    while (true) {
        ListNode *lastNodeOfPreviousPart = prev;
        ListNode *lastNodeOfSubList = current;
        ListNode *next = NULL;

        for (int i = 0; current != NULL &amp;amp;&amp;amp; i &amp;lt; k; i++) {
            next = current-&amp;gt;next;
            current-&amp;gt;next = prev;
            prev = current;
            current = next;
        }

        //链接第一部分
        if (lastNodeOfPreviousPart != NULL) {
            lastNodeOfPreviousPart-&amp;gt;next = prev;

        } else {
            head = prev;
        }
        //链接后一部分
        lastNodeOfSubList-&amp;gt;next = current;
        if (current == NULL) {
            break;
        }
        prev = lastNodeOfSubList;

    }
    return head;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;5-reverse-alternating-k-element-sub-list&#34;&gt;5、reverse alternating k-element sub-list&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定链表和整数K，每次交替逆转K个元素，如果最后要逆转的部分小于k，也要逆转&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./5-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ListNode *reverse(ListNode *head, int k) {
    if (k &amp;lt;= 1 || head == NULL) {
        return head;
    }

    ListNode *current = head;
    ListNode *prev = NULL;

    while (true) {
        ListNode *lastNodeOfPreviousPart = prev;
        ListNode *lastNodeOfSubList = current;
        ListNode *next = NULL;


        for (int i = 0; current != NULL &amp;amp;&amp;amp; i &amp;lt; k; i++) {
            next = current-&amp;gt;next;
            current-&amp;gt;next = prev;
            prev = current;
            current = next;
        }

        if (lastNodeOfPreviousPart != NULL) {
            lastNodeOfPreviousPart-&amp;gt;next = prev;

        } else {
            head = prev;
        }

        lastNodeOfSubList-&amp;gt;next = current;

        for (int i = 0; current != NULL &amp;amp;&amp;amp; i &amp;lt; k; i++) {
            prev = current;
            current = current-&amp;gt;next;
        }

        if (current == NULL) {
            break;
        }
    }
    return head;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;6-rotate-a-linkedlist&#34;&gt;6、rotate a linkedlist&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定链表和整数K，循环将前k元素移到后面&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./6-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ListNode *rotate(ListNode *head, int rotations) {
    if (head == NULL || head-&amp;gt;next == NULL || rotations &amp;lt;= 0) {
        return head;
    }
    ListNode *lastNode = head;
    int listLength = 1;
    while (lastNode-&amp;gt;next != NULL) {
        lastNode = lastNode-&amp;gt;next;
        listLength++;
    }
    lastNode-&amp;gt;next = head;
    rotations %= listLength;
    int skipLength = listLength - rotations;
    ListNode *lastNodeOfRotatedList = head;
    
    for (int i = 0; i &amp;lt; skipLength - 1; i++) {
        lastNodeOfRotatedList = lastNodeOfRotatedList-&amp;gt;next;
    }

    head = lastNodeOfRotatedList-&amp;gt;next;
    lastNodeOfRotatedList-&amp;gt;next = NULL;
    return head;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-6 Cyclic Sort</title>
      <link>/code/pattern/cyclic-sort/</link>
      <pubDate>Sat, 23 May 2020 17:48:24 +0800</pubDate>
      <guid>/code/pattern/cyclic-sort/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;常用来解决数组元素的值在&lt;strong&gt;一定范围&lt;/strong&gt;内的问题&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;2-cyclic-sort&#34;&gt;2、cyclic sort&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定长度为n，所有元素的值在[1,n]内，不重复。原地排序&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, 1, 5, 4, 2]

output:	[1, 2, 3, 4, 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2, 6, 4, 3, 1, 5]

output:	[1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void mySwap(vector&amp;lt;int&amp;gt; &amp;amp;arr,int i,int j){
    int temp=arr[i];
    arr[i]=arr[j];
    arr[j]=temp;
}
void sort(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    int i = 0;
    //如果nums[i]不在正确位置上，将交换到正确位置上
    while (i &amp;lt; nums.size()) {
        //j代表num[i]的正确索引位置
        int j = nums[i] - 1;
        if (nums[i] != nums[j]) {
            mySwap(nums,j,i);
            //swap(nums[j], nums[i]);
        } else {
            i++;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./2-1.png&#34; alt=&#34;cyclic sort&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-2.png&#34; alt=&#34;cyclic sort&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;3-find-the-missing-number&#34;&gt;3、find the Missing number&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定长度为n的数组，元素值的范围在[0,n], 不重复，求未包含在其中的数字&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[4, 0, 3, 1]

output:	2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[8, 3, 5, 2, 4, 6, 0, 1]

output:	7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void mySwap(vector&amp;lt;int&amp;gt; &amp;amp;arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

int findMissingNumber(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    int i = 0;
    while (i &amp;lt; nums.size()) {
        //把nums[i]放到到索引为nums[i]的位置上，
        //如 nums[6] -&amp;gt; index=nums[6]
        // 忽略n
        if (nums[i] &amp;lt; nums.size() &amp;amp;&amp;amp; nums[i] != nums[nums[i]]) {
            //交换索引位置上的值
            //也就是swap(nums[i], nums[nums[i]]);
            mySwap(nums, i, nums[i]);
        } else {
            i++;
        }
    }

    for (int i = 0; i &amp;lt; nums.size(); i++) {
        if (nums[i] != i) {
            return i;
        }
    }
    return nums.size();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;4-find-all-missing-numbers&#34;&gt;4、find all missing numbers&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定长度为n的数组，元素值的范围在[1,n], 有重复，求所有未包含在其中的数字&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2, 3, 1, 8, 2, 3, 5, 1]

output:	[4, 6, 7]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2, 4, 1, 2]

output:	[3]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void mySwap(vector&amp;lt;int&amp;gt; &amp;amp;arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

vector&amp;lt;int&amp;gt; findMissingNumbers(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    int i = 0;
    vector&amp;lt;int&amp;gt; missingNumbers;

    while (i &amp;lt; nums.size()) {
        //nums[i] - 1 代表num[i]的正确索引位置
        if (nums[i] != nums[nums[i] - 1]) {
            mySwap(nums, i, nums[i] - 1);
            //swap(nums[i],nums[nums[i] - 1]);
        } else {
            i++;
        }
    }

    for (int i = 0; i &amp;lt; nums.size(); i++) {
        if (nums[i] != i + 1) {
            missingNumbers.push_back(i + 1);
        }
    }
    return missingNumbers;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;5-find-the-duplicate-number&#34;&gt;5、find the duplicate number&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定长度为n+1的数组，元素值的范围在[1,n], 只有一个元素有重复，可多次重复，求重复的数字&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 4, 4, 3, 2]

output:	4
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2, 4, 4, 1, 4]

output:	4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void mySwap(vector&amp;lt;int&amp;gt; &amp;amp;arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

int findNUmber(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    int i = 0;

    while (i &amp;lt; nums.size()) {
        if (nums[i] != i + 1) {
            if (nums[i] != nums[nums[i] - 1]) {
                mySwap(nums, i, nums[i] - 1);
                //swap(nums[i],nums[nums[i] - 1]);
            } else {
                //在交换了一次重复值后，再次碰到，一定是重复的元素
                return nums[i];
            }
        } else {
            i++;
        }
    }
    return -1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;p&gt;相似问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;上述问题，不能改变数组，且要求&lt;em&gt;O&lt;/em&gt;(1)空间&lt;/p&gt;

&lt;p&gt;用快慢指针&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findStart(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int cycleLenghth) {
    int pointer1 = arr[0];
    int pointer2 = arr[0];
    while (cycleLenghth &amp;gt; 0) {
        pointer2 = arr[pointer2];
        cycleLenghth--;
    }

    while (pointer1 != pointer2) {
        pointer1 = arr[pointer1];
        pointer2 = arr[pointer2];
    }
    return pointer1;
}


int findDuplicate(const vector&amp;lt;int&amp;gt; &amp;amp;arr) {
    int fast = 0;
    int slow = 0;
    do {
        slow = arr[slow];
        fast = arr[arr[fast]];
    } while (slow != fast);

    int current = arr[slow];
    int cycleLength = 0;
    do {
        current = arr[current];
        cycleLength++;
    } while (current != arr[slow]);
    
    return findStart(arr, cycleLength);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;6-find-all-duplicate-numbers&#34;&gt;6、find all duplicate numbers&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定长度为n的数组，元素值的范围在[1,n], 有多个有重复，求所有重复的数字，不使用额外空间&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, 4, 4, 5, 5]

output:	[5, 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[5, 4, 7, 2, 3, 5, 3]

output:	[3, 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void mySwap(vector&amp;lt;int&amp;gt; &amp;amp;arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

vector&amp;lt;int&amp;gt; findNumbers(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    int i = 0;
    vector&amp;lt;int&amp;gt; duplicates;

    while (i &amp;lt; nums.size()) {
        if (nums[i] != nums[nums[i] - 1]) {
            mySwap(nums, i, nums[i] - 1);
            //swap(nums[i],nums[nums[i] - 1]);
        } else {
            i++;
        }
    }
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        if (nums[i] != i + 1) {
            duplicates.push_back(nums[i]);
        }
    }
    return duplicates;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;7-find-the-corrupt-pair&#34;&gt;7、find the corrupt pair&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定长度为n的数组，元素值的范围在[1,n], 一个元素有重复且重复一次，求重复的数字和缺失的数字&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, 1, 2, 5, 2]

output:	[2, 4]

explanation: 2重复，4缺失
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, 1, 2, 3, 6, 4]

output:	[3, 5]

explanation: 3重复，5缺失
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;int&amp;gt; findNumbers(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    int i = 0;

    while (i &amp;lt; nums.size()) {
        if (nums[i] != nums[nums[i] - 1]) {
            mySwap(nums, i, nums[i] - 1);
            //swap(nums[i],nums[nums[i] - 1]);
        } else {
            i++;
        }
    }
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        if (nums[i] != i + 1) {
            return vector&amp;lt;int&amp;gt;{nums[i], i + 1};
        }
    }
    return vector&amp;lt;int&amp;gt;{-1, -1};
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;8-find-the-smallest-missing-positive-number&#34;&gt;8、find the smallest missing positive number&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定整数数组，元素值无范围限制，求最小缺失的正整数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-3, 1, 5, 4, 2]

output:	3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, -2, 0, 1, 2]

output:	4
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, 2, 5, 1]

output:	4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void mySwap(vector&amp;lt;int&amp;gt; &amp;amp;arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

int findNumber(vector&amp;lt;int&amp;gt; &amp;amp;nums) {
    int i = 0;

    while (i &amp;lt; nums.size()) {
        if (nums[i] &amp;gt; 0 &amp;amp;&amp;amp; nums[i] &amp;lt;= nums.size() &amp;amp;&amp;amp;
            nums[i] != nums[nums[i] - 1]) {

            mySwap(nums, i, nums[i] - 1);
            //swap(nums[i],nums[nums[i] - 1]);
        } else {
            i++;
        }
    }
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        if (nums[i] != i + 1) {
            return i + 1;
        }
    }
    return nums.size() + 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;9-find-the-first-k-missing-positive-numbers&#34;&gt;9、find the first k missing positive numbers&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定整数数组和K值，元素值无范围限制，求最小的前K个缺失的正整数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, -1, 4, 5, 5] ,K=3

output:	[1, 2, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2, 3 ,4] ,K=3

output:	[1, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-2, -3 ,4] ,K=2

output:	[1, 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void mySwap(vector&amp;lt;int&amp;gt; &amp;amp;arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

vector&amp;lt;int&amp;gt; findNumbers(vector&amp;lt;int&amp;gt; &amp;amp;nums, int k) {
    int i = 0;
    vector&amp;lt;int&amp;gt; missingNUmbers;
    unordered_set&amp;lt;int&amp;gt; extraNumbers;

    while (i &amp;lt; nums.size()) {
        if (nums[i] &amp;gt; 0 &amp;amp;&amp;amp; nums[i] &amp;lt;= nums.size() &amp;amp;&amp;amp;
            nums[i] != nums[nums[i] - 1]) {

            mySwap(nums, i, nums[i] - 1);
            //swap(nums[i],nums[nums[i] - 1]);
        } else {
            i++;
        }
    }
    for (int i = 0; i &amp;lt; nums.size() &amp;amp;&amp;amp; missingNUmbers.size() &amp;lt; k; i++) {
        if (nums[i] != i + 1) {
            missingNUmbers.push_back(i + 1);
            extraNumbers.insert(nums[i]);
        }
    }

    for (int i = 1; missingNUmbers.size() &amp;lt; k; i++) {
        int candidateNumber = i + nums.size();
        if (extraNumbers.find(candidateNumber) == extraNumbers.end()) {
            missingNUmbers.push_back(candidateNumber);
        }
    }
    return missingNUmbers;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N + K]&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(K)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-5 Merge Intervals</title>
      <link>/code/pattern/merge-intervals/</link>
      <pubDate>Sat, 23 May 2020 17:47:56 +0800</pubDate>
      <guid>/code/pattern/merge-intervals/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;p&gt;常用来解决重叠区间问题，如求重叠的区间或合并有重叠的区间&lt;/p&gt;

&lt;p&gt;区间 a , b 的6种重叠方式&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./1-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-merge-interval&#34;&gt;2、merge interval&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定一组区间，合并重叠的区间&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./2-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./2-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; merge(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) {
    if (intervals.size() &amp;lt; 1) {
        return intervals;
    }

    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; mergedResult;
    mergedResult.push_back(intervals[0]);

    for (int i = 1; i &amp;lt; intervals.size(); i++) {
        if (intervals[i][0] &amp;lt;= mergedResult.back()[1]) {

            mergedResult.back()[1] = max(mergedResult.back()[1], intervals[i][1]);
        } else {
            mergedResult.push_back(intervals[i]);
        }
    }
    return mergedResult;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; *  log &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;相似问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;判断一组区间是否重合&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[[1, 4], [2, 5], [7, 9]]

output:	true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool isMerge(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;intervals) {
    if (intervals.size() &amp;lt; 1) {
        return false;
    }

    vector&amp;lt;int&amp;gt; temp=intervals[0];

    for (int i = 1; i &amp;lt; intervals.size(); i++) {
        if (intervals[i][0] &amp;lt;= temp[1]) {
            return true;
        } else {
            temp=intervals[i];
        }
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-insert-interval&#34;&gt;3、insert interval&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定一组不重叠区间（按照起始位置排序）和一个区间，合并，生成新的不重叠的区间&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./3-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; insertInterval(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; intervals, vector&amp;lt;int&amp;gt; newInterval) {
    if (intervals.empty()) {
        return vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;{newInterval};
    }

    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;
    int i = 0;
    while (i &amp;lt; intervals.size() &amp;amp;&amp;amp; intervals[i][1] &amp;lt; newInterval[0]) {
        result.push_back(intervals[i]);
        i++;
    }

    while (i &amp;lt; intervals.size() &amp;amp;&amp;amp; intervals[i][0] &amp;lt;= newInterval[1]) {
        newInterval[0] = min(intervals[i][0], newInterval[0]);
        newInterval[1] = max(intervals[i][1], newInterval[1]);
        i++;
    }

    result.push_back(newInterval);

    while (i &amp;lt; intervals.size()) {
        result.push_back(intervals[i]);
        i++;
    }

    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;4-intervals-intersection&#34;&gt;4、intervals intersection&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定两组区间（每组不重叠，按起始位置排序），求其相交区间&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./4-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; merge(const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;arr1, const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;arr2) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;

    int i = 0, j = 0;

    while (i &amp;lt; arr1.size() &amp;amp;&amp;amp; j &amp;lt; arr2.size()) {

        if ((arr1[i][0] &amp;gt;= arr2[j][0] &amp;amp;&amp;amp; arr1[i][0] &amp;lt;= arr2[j][1]) ||
            (arr2[j][0] &amp;gt;= arr1[i][0] &amp;amp;&amp;amp; arr2[j][0] &amp;lt;= arr1[i][1])) {

            result.push_back({max(arr1[i][0], arr2[j][0]), min(arr1[i][1], arr2[j][1])});
        }

        if (arr1[i][1] &amp;lt; arr2[j][1]) {
            i++;
        } else {
            j++;
        }
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; + &lt;em&gt;M&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;1&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;5-conflicting-appointments&#34;&gt;5、conflicting appointments&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定一组区间代表一组会议持续时间，判断某人是否能够参加所有的会议&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[[1, 4], [2, 5], [7, 9]]

output:	false
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[[6, 7], [2, 4], [8, 12]]

output:	true
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[[4, 5], [2, 3], [3, 6]]

output:	false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool canAttendAllAppointments(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;nums) {
    sort(nums.begin(), nums.end());

    for (int i = 1; i &amp;lt; nums.size(); i++) {
        if (nums[i][0] &amp;lt; nums[i - 1][1]) {
            return false;
        }
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; *  log &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;相似问题&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;给定一组区间代表一组会议持续时间，求所有冲突的会议&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;待写
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;6-minimum-meeting-rooms&#34;&gt;6、minimum meeting rooms&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定一组区间代表一些会议，求能举办这些会议的最小会议室&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./6-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./6-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./6-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;struct cmp_greater {
    bool operator()(const vector&amp;lt;int&amp;gt; &amp;amp;x, const vector&amp;lt;int&amp;gt; &amp;amp;y) {
        return x[1] &amp;gt; y[1];
    }
};


int minimumMeetingRooms(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;meetings) {
    if (meetings.empty()) {
        return 0;
    }
    sort(meetings.begin(), meetings.end());
    int minRooms = 0;
    priority_queue&amp;lt;vector&amp;lt;int&amp;gt;, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;, cmp_greater&amp;gt; minHeap;

    for (auto m: meetings) {
        while (!minHeap.empty() &amp;amp;&amp;amp; m[0] &amp;gt;= minHeap.top()[1]) {
            minHeap.pop();
        }
        minHeap.push(m);
        minRooms = max(minRooms, (int) minHeap.size());
    }

    return minRooms;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt; *  log &lt;em&gt;N&lt;/em&gt; )&lt;/p&gt;

&lt;p&gt;Space Complexity : &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;N&lt;/em&gt;)&lt;/p&gt;

&lt;h2 id=&#34;7-maximum-cpu-load&#34;&gt;7、maximum cpu load&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;没看懂&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;8-employee-free-time&#34;&gt;8、employee free time&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;待看&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-4 Fast and Slow Pointers</title>
      <link>/code/pattern/fast-and-slow-pointers/</link>
      <pubDate>Sat, 23 May 2020 17:46:20 +0800</pubDate>
      <guid>/code/pattern/fast-and-slow-pointers/</guid>
      <description>

&lt;h2 id=&#34;1-introduction&#34;&gt;1、introduction&lt;/h2&gt;

&lt;p&gt;移动两个速度不同的指针，常在环形数组和链表问题中使用。&lt;/p&gt;

&lt;h2 id=&#34;2-linkedlist-cycle&#34;&gt;2、linkedlist cycle&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;判断链表是否有环&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./2.png&#34; alt=&#34;有无环的链表&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool hasCycle(ListNode *head) {
    ListNode *fast = head;
    ListNode *slow = head;
    
    while (fast != NULL &amp;amp;&amp;amp; fast-&amp;gt;next != NULL) {
        fast = fast-&amp;gt;next-&amp;gt;next;
        slow = slow-&amp;gt;next;
        if (slow == fast) {
            return true;
        }
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;p&gt;相似问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;求带环链表环的长度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int calculateLength(ListNode *slow) {
    ListNode *current = slow;
    int cycleLength = 0;
    do {
        current = current-&amp;gt;next;
        cycleLength++;
    } while (current != slow);
    return cycleLength;
}

int findCycleLength(ListNode *head) {
    ListNode *fast = head;
    ListNode *slow = head;
    while (fast != NULL &amp;amp;&amp;amp; fast-&amp;gt;next != NULL) {
        fast = fast-&amp;gt;next-&amp;gt;next;
        slow = slow-&amp;gt;next;
        if (slow == fast) {
            return calculateLength(slow);
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;3-start-of-linkedlist-cycle&#34;&gt;3、start of linkedlist cycle&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求带环链表的起点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;./3.png&#34; alt=&#34;带环链表起点&#34; /&gt;&lt;/p&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ListNode *findStart(ListNode *head, int cycleLenghth) {
    ListNode *pointer1 = head;
    ListNode *pointer2 = head;
    while (cycleLenghth &amp;gt; 0) {
        pointer2 = pointer2-&amp;gt;next;
        cycleLenghth--;
    }

    while (pointer1 != pointer2) {
        pointer1 = pointer1-&amp;gt;next;
        pointer2 = pointer2-&amp;gt;next;
    }
    return pointer1;
}

int calculateLength(ListNode *slow) {
    ListNode *current = slow;
    int cycleLength = 0;
    do {
        current = current-&amp;gt;next;
        cycleLength++;
    } while (current != slow);
    return cycleLength;
}

ListNode *findCycleStart(ListNode *head) {
    int cycleLength = 0;
    ListNode *fast = head;
    ListNode *slow = head;
    while (fast != NULL &amp;amp;&amp;amp; fast-&amp;gt;next != NULL) {
        fast = fast-&amp;gt;next-&amp;gt;next;
        slow = slow-&amp;gt;next;
        if (slow == fast) {
            cycleLength = calculateLength(slow);
            break;
        }
    }
    return findStart(head, cycleLength);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;./3-1.png&#34; alt=&#34;快慢指针&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;4-happy-number&#34;&gt;4、happy number&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;判断整数是否是happy number&lt;/p&gt;

&lt;p&gt;快乐数（happy number）有以下的特性：在给定的进位制下，该数字所有数位(digits)的平方和，得到的新数再次求所有数位的平方和，如此重复进行，最终结果必为1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	23
 
output:	true

explanations:  2*2 + 3*3 = 4 + 9 = 13
    		  1*1 + 3*3 = 1 + 9 = 10
    		  1*1 + 0*0 = 1 + 0 = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	12
 
output:	false

explanations: 5-&amp;gt;25-&amp;gt;29-&amp;gt;85-&amp;gt;89-&amp;gt;145-&amp;gt;42-&amp;gt;20-&amp;gt;4-&amp;gt;16-&amp;gt;37-&amp;gt;58-&amp;gt;89  89重复
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findSquareSum(int num) {
    int sum = 0;
    int digit;
    while (num &amp;gt; 0) {
        digit = num % 10;
        sum += digit * digit;
        num /= 10;
    }
    return sum;
}

int find(int num) {
    //如果不是happy number，在不断生成新数中，定有重复
    int slow = num;
    int fast = num;
    do {
        slow = findSquareSum(slow);
        fast = findSquareSum(findSquareSum(fast));
    } while (slow != fast);

    return slow == 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(log N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;5-middle-of-the-linkedlist&#34;&gt;5、middle of the linkedlist&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;求链表的中间节点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5-&amp;gt; NULL
 
output:	3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5-&amp;gt; 6 -&amp;gt; NULL
 
output:	4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ListNode *findMiddle(ListNode *head) {
    ListNode *fast = head;
    ListNode *slow = head;

    while (fast != NULL &amp;amp;&amp;amp; fast-&amp;gt;next != NULL) {
        fast = fast-&amp;gt;next-&amp;gt;next;
        slow = slow-&amp;gt;next;
    }
    return slow;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;6-palindrome-linkedlist&#34;&gt;6、palindrome linkedlist&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;判断链表是否对称&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	2 -&amp;gt; 4 -&amp;gt; 6 -&amp;gt; 4 -&amp;gt; 2-&amp;gt; NULL
 
output:	true
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	2 -&amp;gt; 4 -&amp;gt; 6 -&amp;gt; 4 -&amp;gt; 2 -&amp;gt; 2 -&amp;gt; NULL
 
output:	false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ListNode *reverse(ListNode *head) {
    ListNode *prev = NULL;
    while (head != NULL) {
        ListNode *next = head-&amp;gt;next;
        head-&amp;gt;next = prev;
        prev = head;
        head = next;
    }
    return prev;
}

bool isPalindrome(ListNode *head) {
    if (head == NULL || head-&amp;gt;next == NULL) {
        return true;
    }
    ListNode *fast = head;
    ListNode *slow = head;
    while (fast != NULL &amp;amp;&amp;amp; fast-&amp;gt;next != NULL) {
        fast = fast-&amp;gt;next-&amp;gt;next;
        slow = slow-&amp;gt;next;
    }

    ListNode *headSecondHalf = reverse(slow);
    ListNode *copyHeadSecondHalf = headSecondHalf;

    while (head != NULL &amp;amp;&amp;amp; headSecondHalf != NULL) {
        if (head-&amp;gt;val != headSecondHalf-&amp;gt;val) {
            break;
        }
        head = head-&amp;gt;next;
        headSecondHalf = headSecondHalf-&amp;gt;next;
    }


    reverse(copyHeadSecondHalf);
    if (head == NULL || headSecondHalf == NULL) {
        return true;
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;7-rearrange-a-linkedlist&#34;&gt;7、rearrange a linkedlist&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…&lt;/p&gt;

&lt;p&gt;你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	2 -&amp;gt; 4 -&amp;gt; 6 -&amp;gt; 8 -&amp;gt; 10-&amp;gt; 12 -&amp;gt; NULL
 
output:	2 -&amp;gt; 12 -&amp;gt; 4 -&amp;gt; 10-&amp;gt; 6 -&amp;gt; 8 -&amp;gt; NULL
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	2 -&amp;gt; 4 -&amp;gt; 6 -&amp;gt; 8 -&amp;gt; 10 -&amp;gt; NULL
 
output:	2 -&amp;gt; 10 -&amp;gt; 4 -&amp;gt; 8 -&amp;gt; 6 -&amp;gt; NULL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;ListNode *reverse(ListNode *head) {
    ListNode *prev = NULL;
    while (head != NULL) {
        ListNode *next = head-&amp;gt;next;
        head-&amp;gt;next = prev;
        prev = head;
        head = next;
    }
    return prev;
}

void reOrder(ListNode *head) {
    if (head == NULL || head-&amp;gt;next == NULL) {
        return;
    }
    ListNode *fast = head;
    ListNode *slow = head;
    while (fast != NULL &amp;amp;&amp;amp; fast-&amp;gt;next != NULL) {
        fast = fast-&amp;gt;next-&amp;gt;next;
        slow = slow-&amp;gt;next;
    }

    ListNode *headSecondHalf = reverse(slow);
    ListNode *headFirstHalf = head;

    while (headFirstHalf != NULL &amp;amp;&amp;amp; headSecondHalf != NULL) {
        ListNode *temp = headFirstHalf-&amp;gt;next;
        headFirstHalf-&amp;gt;next = headSecondHalf;
        headFirstHalf = temp;

        temp = headSecondHalf-&amp;gt;next;
        headSecondHalf-&amp;gt;next = headFirstHalf;
        headSecondHalf = temp;
    }

    if (headFirstHalf != NULL) {
        headFirstHalf-&amp;gt;next = NULL;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h2 id=&#34;8-cycle-in-a-circular-array&#34;&gt;8、cycle in a Circular array&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;没看懂题目&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-3 Two Pointers</title>
      <link>/code/pattern/two-pointers/</link>
      <pubDate>Sat, 23 May 2020 17:45:10 +0800</pubDate>
      <guid>/code/pattern/two-pointers/</guid>
      <description>

&lt;h1 id=&#34;1-介绍&#34;&gt;1、介绍&lt;/h1&gt;

&lt;p&gt;在&lt;strong&gt;有序&lt;/strong&gt;数组或链表中查找出满足某些限定条件一组元素时，常用双指针法。&lt;/p&gt;

&lt;h1 id=&#34;2-pair-with-target-sum&#34;&gt;2、pair with target sum&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;给定有序数组、目标值target，在数组中找到一对值，使得其和等于目标值&lt;/p&gt;

&lt;p&gt;返回满足条件的对值的索引&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [1,2,3,4,6] ,target=6

output:	[1,3]

2+4=6，index=[1,3]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: [2,5,9,11] ,target=11

output:	[0,2]

2+9=6，index=[0,2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;p&gt;双指针法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;pair&amp;lt;int, int&amp;gt; search(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int targetSum) {
    //指向起始，结束位置。
    int left = 0;
    int right = arr.size() - 1;
    
    while (right &amp;gt; left) {
        int currentSum = arr[left] + arr[right];
        if (currentSum == targetSum) {
            return make_pair(left, right);
        }
        if (targetSum &amp;gt; currentSum) {
            left++;
        }
        if (targetSum &amp;lt; currentSum) {
            right--;
        }
    }
    return make_pair(-1, -1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time:   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space:  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;p&gt;哈希表：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;pair&amp;lt;int,int&amp;gt; searchhash(const vector&amp;lt;int&amp;gt; &amp;amp;arr,int targetSum){
    unordered_map&amp;lt;int,int&amp;gt; nums;
    for(int i=0;i&amp;lt;arr.size();i++){
        if(nums.find(targetSum-arr[i])!=nums.end()){
            return make_pair(nums[targetSum-arr[i]],i);
        }else{
            nums[arr[i]]=i;
        }
    }
    return make_pair(-1,-1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time:   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space:  &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h1 id=&#34;3-remove-duplicates&#34;&gt;3、remove Duplicates&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;删除有序数组中重复的元素，不准使用额外的存储空间，返回删除后的新数组长度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2,3,3,3,6,9,9] 

output: 4

after remove:[2,3,6,9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int remove(vector&amp;lt;int&amp;gt; &amp;amp;arr) {
    //nextNonDuplicate前面全是不重复的元素，同时承担计数功能
    //nextNonDuplicate和i都是指针
    int nextNonDuplicate = 1;
    for (int i = 1; i &amp;lt; arr.size(); i++) {
        if (arr[nextNonDuplicate - 1] != arr[i]) {
            arr[nextNonDuplicate] = arr[i];
            nextNonDuplicate++;
        }
    }
    return nextNonDuplicate;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;p&gt;相似问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;删除有序数组中所有等于Target的元素，返回删除后的新数组长度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, 2, 3, 6, 3, 10, 9, 3],key=3

output: 4

after remove:[2,3,10,9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int removeTaget(vector&amp;lt;int&amp;gt; &amp;amp;arr, int key) {
    // nextElement代表不等于key的元素的新位置,同时计数
    // nextElement和i都是指针
    int nextElement = 0;
    for (int i = 0; i &amp;lt; arr.size(); i++) {
        if (arr[i] != key) {
            arr[nextElement] = arr[i];
            nextElement++;
        }
    }
    return nextElement;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h1 id=&#34;4-squaring-a-sorted-arrary&#34;&gt;4、squaring a sorted arrary&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;给定有序数组，将所有元素的平方有序输出&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-2, -1, 0, 2, 3]

output: [0 ,1 ,4 ,4 ,9]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-3, -1, 0, 1, 2]

output: [0 ,1 ,4 ,4 ,9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;int&amp;gt; makeSqueare(vector&amp;lt;int&amp;gt; arr) {
    int n = arr.size();
    vector&amp;lt;int&amp;gt; square(n);
    int highestSquareIndex = n - 1;
    //双指针
    int right = n - 1;
    int left = 0;
    
    while (right &amp;gt;= left) {
        int leftSquare = arr[left] * arr[left];
        int rightSquare = arr[right] * arr[right];
        if (leftSquare &amp;gt; rightSquare) {
            square[highestSquareIndex] = leftSquare;
            highestSquareIndex--;
            left++;
        } else {
            square[highestSquareIndex] = rightSquare;
            highestSquareIndex--;
            right--;
        }
    }
    return square;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h1 id=&#34;5-triplet-sum-to-zero&#34;&gt;5、triplet sum to zero&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;给定未排序的整数数组，找出所有和为0、长度为3且不重复的子数组&lt;/p&gt;

&lt;p&gt;X+Y+Z=0  -&amp;gt; X+Y=_Z&lt;/p&gt;

&lt;p&gt;为了确保不重复，排序后的数组，重复元素相邻可略过&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-3, 0, 1, 2, -1, 1, -2]

output: [[-3 1 2 ][-2 0 2 ][-1 0 1 ]]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-5, 2, -1, -2, 3]

output: [[-5 2 3 ][-2 -1 3 ]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void searchPair(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int targetSum, int left, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;triplets) {
    //双指针
    int right = arr.size() - 1;
    while (left &amp;lt; right) {
        int currentSum = arr[left] + arr[right];
        if (currentSum == targetSum) {
            triplets.push_back({-targetSum, arr[left], arr[right]});
            left++;
            right--;

            //略过重复元素
            while (left &amp;lt; right &amp;amp;&amp;amp; arr[left] == arr[left - 1]) {
                left++;
            }
            //略过重复元素
            while (left &amp;lt; right &amp;amp;&amp;amp; arr[right] == arr[right]) {
                right--;
            }
        } else if (targetSum &amp;gt; currentSum) {
            left++;
        } else {
            right--;
        }
    }
}

vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; searchTriplets(vector&amp;lt;int&amp;gt; &amp;amp;arr) {
    sort(arr.begin(), arr.end());
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; triplets;
    for (int i = 0; i &amp;lt; arr.size() - 2; i++) {
        //略过重复元素
        if (i &amp;gt; 0 &amp;amp;&amp;amp; arr[i] == arr[i - 1]) {
            continue;
        }
        searchPair(arr, -arr[i], i + 1, triplets);
    }
    return triplets;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N^2)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h1 id=&#34;6-triplet-sum-close-to-target&#34;&gt;6、triplet sum close to target&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;给定未排序数组和target值，找出长度为3的子数组，使得子数组的和尽可能接近target，返回子数组的和&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-2, 0, 1, 2],target=2

output: 1

triplet: [-2,1,2]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-3, 1, 1, 2],target=1

output: 0

triplet: [-3,1,2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int searchTriplet(vector&amp;lt;int&amp;gt; &amp;amp;arr, int targetSum) {
    sort(arr.begin(), arr.end());
    int smallestDifference = INT_MAX;
    for (int i = 0; i &amp;lt; arr.size() - 2; i++) {
        int left = i + 1;
        int right = arr.size() - 1;
        while (left &amp;lt; right) {
            int targetDiff = targetSum - arr[i] - arr[left] - arr[right];
            if (targetDiff == 0) {
                return targetSum - targetDiff;
            }
            if (abs(targetDiff) &amp;lt; abs(smallestDifference)) {
                smallestDifference = targetDiff;
            }
            if (targetDiff &amp;gt; 0) {
                left++;
            } else {
                right--;
            }
        }
    }
    return targetSum - smallestDifference;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N^2)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h1 id=&#34;7-triplets-with-smaller-sum&#34;&gt;7、triplets with smaller sum&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;给定未排序数组和target值，找出所有triplets，使得arr[i]+arr[j]+arr[k]&amp;lt; target，i,j,k不相等，返回满足条件的triplets的个数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-1, 0, 2, 3],target=3

output: 2

triplet: [-1,0,3], [-1,0,2]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-1, 4, 2, 1, 3],target=5

output: 4

triplet: [-1,1,4], [-1,1,3], [-1,1,2], [-1,2,3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int searchPair(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int targetSum, int first) {
    int count = 0;
    int left = first + 1;
    int right = arr.size() - 1;
    while (left &amp;lt; right) {
        if (arr[left] + arr[right] &amp;lt; targetSum) {
            count += right - left;
            left++;
        } else {
            right--;
        }
    }
    return count;
}

int searchTriplets(vector&amp;lt;int&amp;gt; &amp;amp;arr, int target) {
    sort(arr.begin(), arr.end());
    int count = 0;
    for (int i = 0; i &amp;lt; arr.size() - 2; i++) {
        count += searchPair(arr, target - arr[i], i);
    }
    return count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N^2)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;相似问题：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;返回所有的triplets&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-1, 4, 2, 1, 3],target=5

output: [-1,1,4], [-1,1,3], [-1,1,2], [-1,2,3]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[-1, 0, 2, 3],target=3

output: [-1,0,3], [-1,0,2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;
void searchPair(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int targetSum, 
                int first, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;triplets) {

    int left = first + 1;
    int right = arr.size() - 1;
    while (left &amp;lt; right) {
        if (arr[left] + arr[right] &amp;lt; targetSum) {
            for (int i = right; i &amp;gt; left; i--) {
                triplets.push_back({arr[first], arr[left], arr[i]});
            }
            left++;
        } else {
            right--;
        }
    }
}

vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; searchTriplets(vector&amp;lt;int&amp;gt; &amp;amp;arr, int target) {
    sort(arr.begin(), arr.end());
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; triplets;

    for (int i = 0; i &amp;lt; arr.size() - 2; i++) {
        searchPair(arr, target - arr[i], i, triplets);
    }
    return triplets;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N^3)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h1 id=&#34;8-subarrary-with-product-less-than-a-target&#34;&gt;8、subarrary with product less than a target&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;给定只包含正整数的数组和target值，寻找所有连续子数组，使得子数组的元素的乘积小于target&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2, 5, 3, 10], target=30

output: [[2 ],[5 ],[2 5 ],[3 ],[5 3 ],[10 ]]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[8, 2, 6, 5], target50

output: [[8 ],[2 ],[8 2 ],[6 ],[2 6 ],[5 ],[6 5 ]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; findSubarrary(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int target) {
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;
    int product = 1;
    int left = 0;
    for (int right = 0; right &amp;lt; arr.size(); right++) {
        product *= arr[right];
        while (product &amp;gt;= target &amp;amp;&amp;amp; left &amp;lt; arr.size()) {
            product /= arr[left];
            left++;
        }

        deque&amp;lt;int&amp;gt; temList;
        //[left,right]区间内乘积小于target，区间内的子数组当然小于target，
        // 为了避免重复，只计算从arr[right]开始的子数组
        for (int i = right; i &amp;gt;= left; i--) {
            temList.push_front(arr[i]);
            vector&amp;lt;int&amp;gt; resultVec;
            move(begin(temList), end(temList), back_inserter(resultVec));
            result.push_back(resultVec);
        }
    }
    return result;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N^3)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h1 id=&#34;9-dutch-national-flag-problem&#34;&gt;9、dutch National flag problem&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;给定只包含0,1,2的数组，原地排序，不准计算0,1,2的个数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 0, 2, 1, 0]

output: [0, 0, 1, 1, 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2, 2, 0, 1, 2, 0]

output: [0, 0, 1, 2, 2, 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void swap(vector&amp;lt;int&amp;gt; &amp;amp;arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

void sort(vector&amp;lt;int&amp;gt; &amp;amp;arr) {
    //所有0在low左侧，所有2在high右侧
    int low = 0;
    int high = arr.size() - 1;
    
    for (int i = 0; i &amp;lt;= high;) {
        if (arr[i] == 0) {
            swap(arr, i, low);
            i++;
            low++;
        } else if (arr[i] == 1) {
            i++;
        } else {
            swap(arr, i, high);
            high--;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h1 id=&#34;10-quadruple-sum-to-target&#34;&gt;10、quadruple sum to target&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;给定未排序数组和target值，找出所有不同的quadruple（长度为4的子数组），使得其和等于target&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[4, 1, 2, -1, 1, -3]

output: [ [-3, -1, 1, 4 ], [-3, 1, 1, 2 ] ]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2, 0, -1, 1, -2, 2 ]

output:	[[-2, 0, 2 ,2 ], [-1, 0 ,1, 2 ]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void searchPair(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int targetSum,
                int fist, int second, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;quadruplets) {

    int left = second + 1;
    int right = arr.size() - 1;
    while (left &amp;lt;= right) {
        int sum = arr[fist] + arr[second] + arr[left] + arr[right];
        if (sum == targetSum) {
            quadruplets.push_back({arr[fist], arr[second], arr[left], arr[right]});
            left++;
            right--;

            while (left &amp;lt; right &amp;amp;&amp;amp; arr[left] == arr[left - 1]) {
                left++;
            }
            while (left &amp;gt; right &amp;amp;&amp;amp; arr[right] == arr[right - 1]) {
                right--;
            }
        } else if (sum &amp;lt; targetSum) {
            left++;
        } else {
            right--;
        }
    }
}

vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; searchQuadruplets(vector&amp;lt;int&amp;gt; &amp;amp;arr, int target) {
    sort(arr.begin(), arr.end());
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; quadruplets;
    for (int i = 0; i &amp;lt; arr.size() - 3; i++) {
        if (i &amp;gt; 0 &amp;amp;&amp;amp; arr[i] == arr[i - 1]) {
            continue;
        }
        for (int j = i + 1; j &amp;lt; arr.size() - 2; j++) {
            if (j &amp;gt; i + 1 &amp;amp;&amp;amp; arr[j] == arr[j - 1]) {
                continue;
            }
            searchPair(arr, target, i, j, quadruplets);
        };
    }
    return quadruplets;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N^3)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;h1 id=&#34;11-comparing-strings-containing-backspaces&#34;&gt;11、comparing strings containing backspaces&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;给定两个包含退格键的字符串，判断他们是否相同，backspace用#表示&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	str1=&amp;quot;xy#z&amp;quot; ,str2=&amp;quot;xzz#&amp;quot;

output:	true

after: str1=&amp;quot;xz&amp;quot; ,str2=&amp;quot;xz&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	str1=&amp;quot;xp#&amp;quot;  ,str2=&amp;quot;xyz##&amp;quot;
    
output:	true
 
after: str1=&amp;quot;x&amp;quot; ,str2=&amp;quot;x&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	str1=&amp;quot;xy#z&amp;quot;  ,str2=&amp;quot;xyz#&amp;quot;
    
output:	false

after: str1=&amp;quot;xz&amp;quot; ,str2=&amp;quot;xy&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int getNextValidCharIndex(const string &amp;amp;str, int index) {
    int backspacesCount = 0;
    while (index &amp;gt;= 0) {
        if (str[index] == &#39;#&#39;) {
            backspacesCount++;
        } else if (backspacesCount &amp;gt; 0) {
            backspacesCount--;
        } else {
            break;
        }

        index--;
    }
    return index;
}

bool compare(const string &amp;amp;str1, const string &amp;amp;str2) {
    int index1 = str1.length() - 1;
    int index2 = str2.length() - 1;
    while (index1 &amp;gt;= 0 || index2 &amp;gt;= 0) {
        int i1 = getNextValidCharIndex(str1, index1);
        int i2 = getNextValidCharIndex(str2, index2);

        if (i1 &amp;lt; 0 &amp;amp;&amp;amp; i2 &amp;lt; 0) {
            return true;
        }

        if (i1 &amp;lt; 0 || i2 &amp;lt; 0) {
            return false;
        }
        if (str1[i1] != str2[i2]) {
            return false;
        }
        index1 = i1 - 1;
        index2 = i2 - 1;
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N+M)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h1 id=&#34;12-mininum-window-sort&#34;&gt;12、mininum window sort&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;求最短子数组的长度，子数组满足条件：当子数组排序后，整个数组是有序的&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 2, 5, 3, 7, 10, 9, 12]
    
output:	5

subarray:[5, 3, 7, 10, 9 ]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 3, 2, 0, -1, 7, 10]
    
output:	5

subarray:[ 3, 2, 0, -1, 7 ]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[1, 2, 3]
    
output:	0
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3, 2, 1]
    
output:	3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int sort(const vector&amp;lt;int&amp;gt; &amp;amp;arr) {
    int low = 0;
    int high = arr.size() - 1;
    int subarrayMax = INT_MIN;
    int subarrayMin = INT_MAX;

    while (low &amp;lt; arr.size() - 1 &amp;amp;&amp;amp; arr[low] &amp;lt; arr[low + 1]) {
        low++;
    }
    if (low == arr.size() - 1) {
        return 0;
    }
    while (high &amp;gt; 0 &amp;amp;&amp;amp; arr[high] &amp;gt;= arr[high - 1]) {
        high--;
    }

    for (int k = low; k &amp;lt;= high; k++) {
        subarrayMax = max(subarrayMax, arr[k]);
        subarrayMin = min(subarrayMin, arr[k]);
    }
    while (low &amp;gt; 0 &amp;amp;&amp;amp; arr[low - 1] &amp;gt; subarrayMin) {
        low--;
    }
    while (high &amp;lt; arr.size() - 1 &amp;amp;&amp;amp; arr[high + 1] &amp;lt; subarrayMax) {
        high++;
    }
    return high - low + 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time Complexity :   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space Complexity :  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-2 Sliding Window</title>
      <link>/code/pattern/sliding-window/</link>
      <pubDate>Sat, 23 May 2020 17:44:03 +0800</pubDate>
      <guid>/code/pattern/sliding-window/</guid>
      <description>

&lt;h3 id=&#34;1-介绍&#34;&gt;1、介绍&lt;/h3&gt;

&lt;p&gt;适用于求&lt;strong&gt;连续&lt;/strong&gt;子数组&lt;/p&gt;

&lt;h3 id=&#34;2-average-of-subarrarys-of-size-k&#34;&gt;2、average of subarrarys of size K&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;求长度为K的连续子数组的平均值&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	arrary:[1,3,2,6,-1,4,1,8,2] ,K=5
    
output:	[2.2,2.8,2.4,3.6,2,8]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;double&amp;gt; averageOfSubarrayOfSizeK(int k,vector&amp;lt;int&amp;gt; &amp;amp;arr){
    vector&amp;lt;double&amp;gt; result(arr.size() -k +1);
    int windowStart =0;
    double windowSum =0;
    
    for(int windowEnd =0 ; windowEnd&amp;lt;arr.size() ;windowEnd++){
        //加上下一个元素
        windowSum += arr[windowEnd];
        
        //到达sizeK，滑动窗口
        if(windowEnd &amp;gt;=k-1){
            result[windowStart]=windowSum/k; //计算平均值
            windowSum -=arr[windowStart];  //减去第一个窗口值
            windowStart++; //滑动窗口
        }
    }
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-maximum-sum-of-subarray-of-size-k&#34;&gt;2、maximum sum of subarray of size K&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;求长度为K的连续子数组的最大值&lt;/p&gt;

&lt;p&gt;其中数组元素为正数，K为正数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2,1,5,1,3,2], k=3

output:	9
    
subarray:[5,1,3]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2,3,4,1,5] ,k=2

output:	7
    
 subarray:[3,4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int maxSumSubarrayOfSizeK(int k ,vector&amp;lt;int&amp;gt; &amp;amp;arr){
    int windowStart =0;
    int windowSum=0;
    int maxSum=0;
    
    for(int windowEnd =0; windowEnd&amp;lt;arr.size() ;windowEnd++){
        windowSum +=arr[windowEnd];
        if (windowEnd&amp;gt;=k-1){
            maxSum=max(maxSum,windowSum);
            windowSum -= arr[windowStart];
            windowStart++;
        }
    }
    return maxSum;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time:   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space:  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h3 id=&#34;3-smallest-subarray-whose-sum-is-greater-than-or-equal-to-s&#34;&gt;3、smallest subarray whose sum is greater than or equal to S&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;求最短长度的子数组，使得其和大于等于 S&lt;/p&gt;

&lt;p&gt;其中数组元素为正数，S 为正数；如果子数组不存在，返回0&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[2,1,5,2,3,2], S=7
    
output:	2

subarray:[5,2]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	[3,4,1,1,6],S=8
    
output:	3
    
subarray:[3,4,1],[1,1,6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findMinSubarray(int k, vector&amp;lt;int&amp;gt; &amp;amp;arr){
    int windowSum = 0;
    int minLength = INT_MAX;
    int windowStart = 0;
    
    for (int windowEnd = 0; windowEnd &amp;lt; arr.size(); windowEnd++){
        windowSum += arr[windowEnd];
        
        //当和大于等于K时候，减小窗口大小
        //不确定减去窗口第一个值后，是否满足要求，所以不断减，直到满足K
        while (windowSum &amp;gt;= k){
            //记录满足条件的最小窗口长度
            minLength = min(minLength, windowEnd - windowStart + 1);
            windowSum -= arr[windowStart];
            windowStart++;
        }
    }
    return minLength == INT_MAX ? 0 : minLength;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time:   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space:  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h3 id=&#34;4-longest-subarrary-with-no-more-than-k-distinct-characters&#34;&gt;4、longest subarrary with no more than K distinct characters&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;求包含 不超过K个不同字符 的最长子串的长度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	string=&amp;quot;araaci&amp;quot; ,k=2

output：	4
    
substring:&amp;quot;araa&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	string=&amp;quot;cbbebi&amp;quot; ,k=3

output：	5
    
substring:&amp;quot;cbbeb&amp;quot; &amp;quot;bbebi&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findLength(int k, const string &amp;amp;str) {
    int maxLength = 0;
    int windowStart = 0;
    
    //记录处理过的字符的频率
    unordered_map&amp;lt;char, int&amp;gt; mp;
    
    for (int windowEnd = 0; windowEnd &amp;lt; str.length(); windowEnd++) {
        char rightchar = str[windowEnd];
        mp[rightchar]++;
        //不断减小窗口长度，直到满足K个不同字符
        while (mp.size() &amp;gt; k) {
            char leftchar = str[windowStart];
            mp[leftchar]--;
            //删除值为0的键
            if (mp[leftchar] == 0) {
                mp.erase(leftchar);
            }
            windowStart++;
        }
        //记录满足K的最大长度
        maxLength = max(maxLength, windowEnd - windowStart + 1);
    }
    return maxLength;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time:   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space:  &lt;em&gt;O&lt;/em&gt;(K)&lt;/p&gt;

&lt;h3 id=&#34;5-maximum-number-of-fruits-in-each-basket&#34;&gt;5、maximum number of fruits in each basket&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;字符数组，每个字符代表一种果树，给2个篮子，每个篮子只能装一种水果&lt;/p&gt;

&lt;p&gt;可以从数组任意位置装，不能回头，遇到第三种水果结束&lt;/p&gt;

&lt;p&gt;求两个篮子能装水果的最大值&lt;/p&gt;

&lt;p&gt;同4 ，K=2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findLength(int k, const string &amp;amp;str) {
    int maxLength = 0;
    int windowStart = 0;
    
    //记录处理过的字符的频率
    unordered_map&amp;lt;char, int&amp;gt; mp;
    
    for (int windowEnd = 0; windowEnd &amp;lt; str.length(); windowEnd++) {
        mp[str[windowEnd]]++;
        //不断减小窗口长度，直到满足K个不同字符
        while (mp.size() &amp;gt; k) {
            mp[str[windowStart]]--;
            //删除值为0的键
            if (mp[str[windowStart]] == 0) {
                mp.erase(str[windowStart]);
            }
            windowStart++;
        }
        //记录满足K的最大长度
        maxLength = max(maxLength, windowEnd - windowStart + 1);
    }
    return maxLength;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-no-repeat-substring&#34;&gt;6、no repeat substring&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;求无重复字符的子串的最大长度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	string=&amp;quot;aabccbb&amp;quot;

output:	3

substring:&amp;quot;abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	string=&amp;quot;abccde&amp;quot;

output:	3

substring:&amp;quot;abc&amp;quot; &amp;quot;cde&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findlength(const string &amp;amp;str) {
    int windowStart = 0;
    int maxLength = 0;

    //记录处理后每个字符的最后索引位置，是索引位置，不是频率
    unordered_map&amp;lt;char, int&amp;gt; mp;

    for (int windowEnd = 0; windowEnd &amp;lt; str.size(); windowEnd++) {
        char rightChar = str[windowEnd];

        //如果mp中已经包含rightchar,从windowStart侧缩小窗口
        if (mp.find(rightChar) != mp.end()) {

            //此时窗口还未添加重复元素，改变窗口起始位，比较重复原元素后一位和windowStar大小
            windowStart = max(windowStart, mp[rightChar] + 1);

        }
        //插入rightChar
        mp[rightChar] = windowEnd;
        maxLength = max(maxLength, windowEnd - windowStart + 1);
    }
    return maxLength;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time:   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space:  &lt;em&gt;O&lt;/em&gt;(K)&lt;/p&gt;

&lt;h3 id=&#34;7-longest-substring-with-same-letters-after-replacement&#34;&gt;7、longest substring with same letters after replacement&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;取代不超过K个元素，求包含最长相同元素的字串&lt;/p&gt;

&lt;p&gt;其中字符串全是小写&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	string=&amp;quot;aabccbb&amp;quot; ,k=2

output:	5

substring: bccbb-&amp;gt;bbbbb
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:	string=&amp;quot;abccde&amp;quot; ,k=1

output:	3

substring: acc-&amp;gt;ccc ccd-&amp;gt;ccc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findLength(const string &amp;amp;str, int k) {
    int windowStart = 0;
    int maxLength = 0;
    //记录每个窗口内重复最多的元素的个数
    int maxRepeatLetterCount = 0;
    //频率
    unordered_map&amp;lt;char, int&amp;gt; frequencyMap;

    for (int windowEnd = 0; windowEnd &amp;lt; str.size(); windowEnd++) {
        char rightChar = str[windowEnd];
        frequencyMap[rightChar]++;
        maxRepeatLetterCount = max(maxRepeatLetterCount, frequencyMap[rightChar]);

        //窗口的长度减去最多重复的个数，剩下的是可以替换的个数，如果超过K，就要缩小窗口
        if (windowEnd - windowStart + 1 - maxRepeatLetterCount &amp;gt; k) {
            char leftChar = str[windowStart];
            frequencyMap[leftChar]--;
            windowStart++;
        }
        maxLength = max(maxLength, windowEnd - windowStart + 1);
    }
    return maxLength;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time:   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space:  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h3 id=&#34;8-longest-subarray-with-ones-after-replacement&#34;&gt;8、longest subarray with ones after replacement&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;数组只包含0和1，将不超过K个0取代为1，求最长连续只包含1的子数组&lt;/p&gt;

&lt;p&gt;同7&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: arrary=[0,1,1,0,0,0,1,1,0,1,1],k=2

output:	6

index=5,8; 0-&amp;gt;1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input: arrary=[0,1,0,0,1,1,0,1,1,0,0,1,1] ,k=3

output:	9

index=6,9,10; 0-&amp;gt;1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int findLength(const vector&amp;lt;int&amp;gt; &amp;amp;arr, int k) {
    int windowStart = 0;
    int maxLength = 0;
    //记录每个窗口中1的个数
    int maxOnesCount = 0;

    for (int windowEnd = 0; windowEnd &amp;lt; arr.size(); windowEnd++) {
        if (arr[windowEnd] == 1) {
            maxOnesCount++;
        }
        if (windowEnd - windowStart + 1 - maxOnesCount &amp;gt; k) {
            if (arr[windowStart] == 1) {
                maxOnesCount--;
            }
            windowStart++;
        }
        maxLength = max(maxLength, windowEnd - windowStart + 1);
    }
    return maxLength;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time:   &lt;em&gt;O&lt;/em&gt;(N)&lt;/p&gt;

&lt;p&gt;Space:  &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;

&lt;h3 id=&#34;9-permutation-in-a-string&#34;&gt;9、permutation in a string&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;文本串和模式串，判断文本串中是否包含模式串的排列&lt;/p&gt;

&lt;p&gt;串的排列：str=“abc”，排列：“abc&amp;rdquo;,&amp;ldquo;acb&amp;rdquo;,&amp;ldquo;bac&amp;rdquo;,&amp;ldquo;bca&amp;rdquo;,&amp;ldquo;cab&amp;rdquo;,&amp;ldquo;cba&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:string=&amp;quot;oidbcaf&amp;quot;,pattern=&amp;quot;abc&amp;quot;
    
output: true
    
permutation:bca&amp;lt;-&amp;gt;abc
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:string=&amp;quot;odicf&amp;quot;,pattern=&amp;quot;dc&amp;quot;
    
output: false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;bool findPermutation(const string &amp;amp;str, const string &amp;amp;pattern) {
    int windowStart = 0;
    int matched = 0;
    unordered_map&amp;lt;char, int&amp;gt; frequencyMap;
    for (auto c: pattern) {
        frequencyMap[c]++;
    }

    for (int windowEnd = 0; windowEnd &amp;lt; str.size(); windowEnd++) {
        char rightChar = str[windowEnd];
        if (frequencyMap.find(rightChar) != frequencyMap.end()) {
            frequencyMap[rightChar]--;
            if (frequencyMap[rightChar] == 0) {
                matched++;
            }

        }
        if (matched == (int) frequencyMap.size()) {
            return true;
        }

        if (windowEnd &amp;gt;= pattern.length() - 1) {
            char leftChar = str[windowStart];
            windowStart++;
            if (frequencyMap.find(leftChar) != frequencyMap.end()) {
                if (frequencyMap[leftChar] == 0) {
                    matched--;
                }
                frequencyMap[leftChar]++;
            }
        }
    }
    return false;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;10-string-anagrams&#34;&gt;10、string anagrams&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;文本串和模式串，找出文本串中包含模式串的同文异构词的起始索引&lt;/p&gt;

&lt;p&gt;同文异构词就是全排列&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:string=&amp;quot;ppqp&amp;quot;,pattern=&amp;quot;pq&amp;quot;
    
output: [1,2]
    
anagram:&amp;quot;pq&amp;quot;,&amp;quot;qp&amp;quot;,startIndex=[1,2]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:string=&amp;quot;abbcabc&amp;quot;,pattern=&amp;quot;abc&amp;quot;
    
output: [2,3,4]
    
anagram:&amp;quot;bca&amp;quot;,&amp;quot;cab&amp;quot;,&amp;quot;abc&amp;quot;,startIndex=[3,4,5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;int&amp;gt; findStringAnagrams(const string &amp;amp;str, const string &amp;amp;pattern) {
    int windowStart = 0;
    int matched = 0;
    unordered_map&amp;lt;char, int&amp;gt; frequencyMap;
    vector&amp;lt;int&amp;gt; resultIndices;
    for (auto c: pattern) {
        frequencyMap[c]++;
    }

    for (int windowEnd = 0; windowEnd &amp;lt; str.size(); windowEnd++) {
        char rightChar = str[windowEnd];
        if (frequencyMap.find(rightChar) != frequencyMap.end()) {
            frequencyMap[rightChar]--;
            if (frequencyMap[rightChar] == 0) {
                matched++;
            }

        }
        if (matched == (int) frequencyMap.size()) {
            resultIndices.push_back(windowStart);
        }

        if (windowEnd &amp;gt;= pattern.length() - 1) {
            char leftChar = str[windowStart];
            windowStart++;
            if (frequencyMap.find(leftChar) != frequencyMap.end()) {
                if (frequencyMap[leftChar] == 0) {
                    matched--;
                }
                frequencyMap[leftChar]++;
            }
        }
    }
    return resultIndices;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;11-smallest-window-containing-substring&#34;&gt;11、smallest window containing substring&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;文本串和模式串，找出最短的文本字串，使得字串包含模式串所有元素&lt;/p&gt;

&lt;p&gt;与9相似&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:string=&amp;quot;aabdec&amp;quot;,pattern=&amp;quot;abc&amp;quot;
    
output: &amp;quot;abdec&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:string=&amp;quot;abdabca&amp;quot;,pattern=&amp;quot;abc&amp;quot;
    
output: &amp;quot;abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;string findSubstring(const string &amp;amp;str, const string &amp;amp;pattern) {
    int windowStart = 0;
    int matched = 0;
    int minLength = str.length() + 1;
    int subStrStart = 0;
    unordered_map&amp;lt;char, int&amp;gt; frequencyMap;

    for (auto c: pattern) {
        frequencyMap[c]++;
    }

    for (int windowEnd = 0; windowEnd &amp;lt; str.size(); windowEnd++) {
        char rightChar = str[windowEnd];
        if (frequencyMap.find(rightChar) != frequencyMap.end()) {
            frequencyMap[rightChar]--;
            if (frequencyMap[rightChar] == 0) {
                matched++;
            }

        }
        while (matched == (int) pattern.length()) {
            if (minLength &amp;gt; windowEnd - windowStart + 1) {
                minLength = windowEnd - windowStart + 1;
                subStrStart = windowStart;
            }
            char leftChar = str[windowStart];
            windowStart++;
            if (frequencyMap.find(leftChar) != frequencyMap.end()) {
                if (frequencyMap[leftChar] == 0) {
                    matched--;
                }
                frequencyMap[leftChar]++;
            }
        }
    }
    return minLength &amp;gt; str.length() ? &amp;quot;&amp;quot; : str.substr(subStrStart, minLength);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;12-words-concatenation&#34;&gt;12、words concatenation&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;给定一个字符串和一组相同长度的单词组成的字符串数组，在字符串中查找包含数组所有单词的子串，单词在字串中不重叠，求子串的起始位置&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:string=&amp;quot;catfoxcat&amp;quot;,words=[&amp;quot;cat&amp;quot;,&amp;quot;fox&amp;quot;]
    
output: [0,3]

substring:&amp;quot;catfox&amp;quot; -&amp;gt; index=0 ;&amp;quot;foxcat&amp;quot; -&amp;gt;index=3
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;input:string=&amp;quot;catcatfoxfox&amp;quot;,words=[&amp;quot;cat&amp;quot;,&amp;quot;fox&amp;quot;]
    
output: [3]

substring:&amp;quot;catfox&amp;quot; -&amp;gt; index=3 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;程序有误
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Pattern-1 Introduction</title>
      <link>/code/pattern/introduction/</link>
      <pubDate>Tue, 19 May 2020 17:36:41 +0800</pubDate>
      <guid>/code/pattern/introduction/</guid>
      <description>&lt;p&gt;课程来源于：&lt;a href=&#34;https://www.educative.io/courses/grokking-the-coding-interview&#34; target=&#34;_blank&#34;&gt;Grokking the Coding Interview: Patterns for Coding Questions&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;课程将面试题目分为14种模式：&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
