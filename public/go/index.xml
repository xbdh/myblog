<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gos | 细胞的核</title>
    <link>/go/</link>
      <atom:link href="/go/index.xml" rel="self" type="application/rss+xml" />
    <description>Gos</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Tue, 28 Jul 2020 23:35:06 +0800</lastBuildDate>
    <image>
      <url>/img/icon-192.png</url>
      <title>Gos</title>
      <link>/go/</link>
    </image>
    
    <item>
      <title>Go语言核心36讲面试题</title>
      <link>/go/interview/gocore36-interview/</link>
      <pubDate>Tue, 28 Jul 2020 23:35:06 +0800</pubDate>
      <guid>/go/interview/gocore36-interview/</guid>
      <description>

&lt;h2 id=&#34;1-工作区和gopath&#34;&gt;1. 工作区和GOPATH&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;问：你知道设置 GOPATH 有什么意义吗？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你可以把 GOPATH 简单理解成 Go 语言的工作目录，它的值是一个目录的路径，也可以是多个目录路径，每个目录都代表 Go 语言的一个工作区（workspace）。&lt;/p&gt;

&lt;p&gt;我们需要利于这些工作区，去放置 Go 语言的源码文件（source file），以及安装（install）后的归档文件（archive file，也就是以“.a”为扩展名的文件）和可执行文件（executable file）。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;事实上，由于 Go 语言项目在其生命周期内的所有操作（编码、依赖管理、构建、测试、安装等）基本上都是围绕着 GOPATH 和工作区进行的。所以，它的背后至少有 3 个知识点，&lt;/p&gt;

&lt;p&gt;分别是：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.1. Go 语言源码的组织方式是怎样的；&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Go 语言的源码也是以代码包为基本组织单位的。在文件系统中，这些代码包其实是与目录一一对应的。由于目录可以有子目录，所以代码包也可以有子包。&lt;/p&gt;

&lt;p&gt;一个代码包中可以包含任意个以.go 为扩展名的源码文件，这些源码文件都需要被声明属于同一个代码包。&lt;/p&gt;

&lt;p&gt;代码包的名称一般会与源码文件所在的目录同名。如果不同名，那么在构建、安装的过程中会以代码包名称为准。每个代码包都会有导入路径。代码包的导入路径是其他代码在使用该包中的程序实体时，需要引入的路径。在实际使用程序实体之前，我们必须先导入其所在的代码包。具体的方式就是import该代码包的导入路径。&lt;/p&gt;

&lt;p&gt;在工作区中，一个代码包的导入路径实际上就是从 src 子目录，到该包的实际存储位置的相对路径。&lt;/p&gt;

&lt;p&gt;所以说，Go 语言源码的组织方式就是以环境变量 GOPATH、工作区、src 目录和代码包为主线的。一般情况下，Go 语言的源码文件都需要被存放在环境变量 GOPATH 包含的某个工作区（目录）中的 src 目录下的某个代码包（目录）中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.2. 你是否了解源码安装后的结果（只有在安装后，Go 语言源码才能被我们或其他代码使&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;用）；&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;源码文件通常会被放在某个工作区的 src 子目录下。那么在安装后如果产生了归档文件（以“.a”为扩展名的文件），就会放进该工作区的 pkg子目录；如果产生了可执行文件，就可能会放进该工作区的 bin 子目录。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.3. 你是否理解构建和安装 Go 程序的过程（这在开发程序以及查找程序问题的时候都很有&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;用，否则你很可能会走弯路）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;构建使用命令go build，安装使用命令go install。构建和安装代码包的时候都会执行编译、打包等操作，并且，这些操作生成的任何文件都会先被保存到某个临时的目录中。&lt;/p&gt;

&lt;p&gt;如果构建的是库源码文件，那么操作后产生的结果文件只会存在于临时目录中。这里的构建的主要意义在于检查和验证。&lt;/p&gt;

&lt;p&gt;如果构建的是命令源码文件，那么操作的结果文件会被搬运到源码文件所在的目录中。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-命令源码文件&#34;&gt;2. 命令源码文件&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;问：命令源码文件的用途是什么，怎样编写它？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;命令源码文件是程序的运行入口，是每个可独立运行的程序必须拥有的。我们可以通过构建或安装，生成与其对应的可执行文件，后者一般会与该命令源码文件的直接父目录同名。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果一个源码文件声明属于&lt;code&gt;main&lt;/code&gt;包，并且包含一个无参数声明且无结果声明的&lt;code&gt;main&lt;/code&gt;函数，那么它就是命令源码文件。&lt;/strong&gt; 就像下面这段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
 
import &amp;quot;fmt&amp;quot;
 
func main() {
	fmt.Println(&amp;quot;Hello, world!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你把这段代码存成 demo1.go 文件，那么运行&lt;code&gt;go run demo1.go&lt;/code&gt;命令后就会在屏幕（标准输出）中看到&lt;code&gt;Hello, world!&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当需要模块化编程时，我们往往会将代码拆分到多个文件，甚至拆分到不同的代码包中。但无论怎样，对于一个独立的程序来说，命令源码文件永远只会也只能有一个。如果有与命令源码文件同包的源码文件，那么它们也应该声明属于&lt;code&gt;main&lt;/code&gt;包。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-库源码文件&#34;&gt;3. 库源码文件&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;库源码文件是不能被直接运行的源码文件，它仅用于存放程序实体，这些程序实体可以被其他代码使用（只要遵从 Go 语言规范的话）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里的“其他代码”可以与被使用的程序实体在同一个源码文件内，也可以在其他源码文件，甚至其他代码包中。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;那么程序实体是什么呢？在 Go 语言中，程序实体是变量、常量、函数、结构体和接口的统称。&lt;/p&gt;

&lt;p&gt;我们总是会先声明（或者说定义）程序实体，然后再去使用。比如在上一篇的例子中，我们先定义了变量&lt;code&gt;name&lt;/code&gt;，然后在&lt;code&gt;main&lt;/code&gt;函数中调用&lt;code&gt;fmt.Printf&lt;/code&gt;函数的时候用到了它。&lt;/p&gt;

&lt;p&gt;再多说一点，程序实体的名字被统称为标识符。标识符可以是任何 Unicode 编码可以表示的字母字符、数字以及下划线“_”，但是其首字母不能是数字。&lt;/p&gt;

&lt;p&gt;从规则上说，我们可以用中文作为变量的名字。但是，我觉得这种命名方式非常不好，自己也会在开发团队中明令禁止这种做法。作为一名合格的程序员，我们应该向着编写国际水准的程序无限逼近。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;问：怎样把命令源码文件中的代码拆分到其他库源码文件？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;第一条规则，同目录下的源码文件的代码包声明语句要一致。也就是说，它们要同属于一个代码包。这对于所有源码文件都是适用的。&lt;/p&gt;

&lt;p&gt;如果目录中有命令源码文件，那么其他种类的源码文件也应该声明属于&lt;code&gt;main&lt;/code&gt;包。这也是我们能够成功构建和运行它们的前提。&lt;/p&gt;

&lt;p&gt;第二条规则，源码文件声明的代码包的名称可以与其所在的目录的名称不同。在针对代码包进行构建时，生成的结果文件的主名称与其父目录的名称一致。&lt;/p&gt;

&lt;p&gt;对于命令源码文件而言，构建生成的可执行文件的主名称会与其父目录的名称相同，这在我前面的回答中也验证过了。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-程序实体的那些事儿-上&#34;&gt;4. 程序实体的那些事儿（上）&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Go 语言中的程序实体包括变量、常量、函数、结构体和接口。&lt;/strong&gt; Go 语言是静态类型的编程语言，所以我们在声明变量或常量的时候，都需要指定它们的类型，或者给予足够的信息，这样才可以让 Go 语言能够推导出它们的类型。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在 Go 语言中，变量的类型可以是其预定义的那些类型，也可以是程序自定义的函数、结构体或接口。常量的合法类型不多，只能是那些 Go 语言预定义的基本类型。它的声明方式也更简单一些&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;问：声明变量有几种方式？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个是你要知道 Go 语言中的类型推断，以及它在代码中的基本体现，另一个是短变量声明的用法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问：Go 语言的类型推断可以带来哪些好处？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Go 语言的类型推断可以明显提升程序的灵活性，使得代码重构变得更加容易，同时又不会给代码的维护带来额外负担（实际上，它恰恰可以避免散弹式的代码修改），更不会损失程序的运行效率。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问：2. 变量的重声明是什么意思？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这涉及了短变量声明。通过使用它，我们可以对同一个代码块中的变量进行重声明。其含义是对已经声明过的变量再次声明。变量重声明的前提条件如下。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;由于变量的类型在其初始化时就已经确定了，所以对它再次声明时赋予的类型必须与其原本的类型相同，否则会产生编译错误。&lt;/li&gt;
&lt;li&gt;变量的重声明只可能发生在某一个代码块中。如果与当前的变量重名的是外层代码块中的变量，那么就是另外一种含义了，我在下一篇文章中会讲到。&lt;/li&gt;
&lt;li&gt;变量的重声明只有在使用短变量声明时才会发生，否则也无法通过编译。如果要在此处声明全新的变量，那么就应该使用包含关键字&lt;code&gt;var&lt;/code&gt;的声明语句，但是这时就不能与同一个代码块中的任何变量有重名了。&lt;/li&gt;
&lt;li&gt;被“声明并赋值”的变量必须是多个，并且其中至少有一个是新的变量。这时我们才可以说对其中的旧变量进行了重声明。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样来看，变量重声明其实算是一个语法糖（或者叫便利措施）。它允许我们在使用短变量声明时不用理会被赋值的多个变量中是否包含旧变量。&lt;/p&gt;

&lt;h2 id=&#34;5-程序实体的那些事儿-中&#34;&gt;5. 程序实体的那些事儿（中）&lt;/h2&gt;

&lt;p&gt;程序实体的访问权限有三种：包级私有的、模块级私有的和公开的。这其实就是 Go 语言在语言层面，依据代码块对程序实体作用域进行的定义。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个程序实体的作用域总是会被限制在某个代码块中，而这个作用域最大的用处，就是对程序实体的访问权限的控制。&lt;/strong&gt;对“高内聚，低耦合”这种程序设计思想的实践，恰恰可以从这里开始。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问：如果一个变量与其外层代码块中的变量重名会出现什么状况&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
 
import &amp;quot;fmt&amp;quot;
 
var block = &amp;quot;package&amp;quot;
 
func main() {
	block := &amp;quot;function&amp;quot;
	{
		block := &amp;quot;inner&amp;quot;
		fmt.Printf(&amp;quot;The block is %s.\n&amp;quot;, block)
	}
	fmt.Printf(&amp;quot;The block is %s.\n&amp;quot;, block)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令源码文件中有四个代码块，它们是：全域代码块、&lt;code&gt;main&lt;/code&gt;包代表的代码块、&lt;code&gt;main&lt;/code&gt;函数代表的代码块，以及在&lt;code&gt;main&lt;/code&gt;函数中的一个用花括号包起来的代码块。&lt;/p&gt;

&lt;p&gt;能通过编译。运行后打印出的内容是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;The block is inner.
The block is function.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;首先，代码引用变量的时候总会最优先查找当前代码块中的那个变量。注意，这里的“当前代码块”仅仅是引用变量的代码所在的那个代码块，并不包含任何子代码块。&lt;/li&gt;
&lt;li&gt;其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接包含当前代码块的那个代码块开始，一层一层地查找。&lt;/li&gt;
&lt;li&gt;一般情况下，程序会一直查到当前代码包代表的代码块。如果仍然找不到，那么 Go 语言的编译器就会报错了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;问：不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为了方便描述，我就把不同代码块中的重名变量叫做“可重名变量”吧。&lt;/strong&gt;注意，在同一个代码块中不允许出现重名的变量，这违背了 Go 语言的语法。关于这两者的表象和机理，我们已经讨论得足够充分了。你现在可以说出几条区别？请想一想，然后再看下面的列表。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;变量重声明中的变量一定是在某一个代码块内的。注意，这里的“某一个代码块内”并不包含它的任何子代码块，否则就变成了“多个代码块之间”。而可重名变量指的正是在多个代码块之间由相同的标识符代表的变量。&lt;/li&gt;
&lt;li&gt;变量重声明是对同一个变量的多次声明，这里的变量只有一个。而可重名变量中涉及的变量肯定是有多个的。&lt;/li&gt;
&lt;li&gt;不论对变量重声明多少次，其类型必须始终一致，具体遵从它第一次被声明时给定的类型。而可重名变量之间不存在类似的限制，它们的类型可以是任意的。&lt;/li&gt;
&lt;li&gt;如果可重名变量所在的代码块之间，存在直接或间接的嵌套关系，那么它们之间一定会存在“屏蔽”的现象。但是这种现象绝对不会在变量重声明的场景下出现。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;./36-5-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;6-程序实体的那些事儿-下&#34;&gt;6. 程序实体的那些事儿 （下)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;问：怎样判断一个变量的类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;答案是使用“类型断言”表达式。具体怎么写呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;value, ok := interface{}(container).([]string)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里有一条赋值语句。在赋值符号的右边，是一个类型断言表达式。&lt;/p&gt;

&lt;p&gt;它包括了用来把&lt;code&gt;container&lt;/code&gt;变量的值转换为空接口值的&lt;code&gt;interface{}(container)&lt;/code&gt;。以及一个用于判断前者的类型是否为切片类型 &lt;code&gt;[]string&lt;/code&gt; 的 &lt;code&gt;.([]string)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这个表达式的结果可以被赋给两个变量，在这里由&lt;code&gt;value&lt;/code&gt;和&lt;code&gt;ok&lt;/code&gt;代表。变量&lt;code&gt;ok&lt;/code&gt;是布尔（bool）类型的，它将代表类型判断的结果，&lt;code&gt;true&lt;/code&gt;或&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果是&lt;code&gt;true&lt;/code&gt;，那么被判断的值将会被自动转换为&lt;code&gt;[]string&lt;/code&gt;类型的值，并赋给变量&lt;code&gt;value&lt;/code&gt;，否则&lt;code&gt;value&lt;/code&gt;将被赋予&lt;code&gt;nil&lt;/code&gt;（即“空”）。&lt;/p&gt;

&lt;p&gt;顺便提一下，这里的&lt;code&gt;ok&lt;/code&gt;也可以没有。也就是说，类型断言表达式的结果，可以只被赋给一个变量，在这里是&lt;code&gt;value&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;但是这样的话，当判断为否时就会引发异常。&lt;/p&gt;

&lt;p&gt;这种异常在 Go 语言中被叫做&lt;code&gt;panic&lt;/code&gt;，我把它翻译为运行时恐慌。因为它是一种在 Go 程序运行期间才会被抛出的异常，而“恐慌”二字是英文 Panic 的中文直译。&lt;/p&gt;

&lt;p&gt;除非显式地“恢复”这种“恐慌”，否则它会使 Go 程序崩溃并停止。所以，在一般情况下，我们还是应该使用带&lt;code&gt;ok&lt;/code&gt;变量的写法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题解析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;正式说明一下，类型断言表达式的语法形式是&lt;code&gt;x.(T)&lt;/code&gt;。其中的&lt;code&gt;x&lt;/code&gt;代表要被判断类型的值。这个值当下的类型必须是接口类型的，不过具体是哪个接口类型其实是无所谓的。&lt;/p&gt;

&lt;p&gt;所以，当这里的&lt;code&gt;container&lt;/code&gt;变量类型不是任何的接口类型时，我们就需要先把它转成某个接口类型的值。&lt;/p&gt;

&lt;p&gt;如果&lt;code&gt;container&lt;/code&gt;是某个接口类型的，那么这个类型断言表达式就可以是&lt;code&gt;container.([]string)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在 Go 语言中，&lt;code&gt;interface{}&lt;/code&gt;代表空接口，任何类型都是它的实现类型。现在你只要知道，任何类型的值都可以很方便地被转换成空接口的值就行了。&lt;/p&gt;

&lt;p&gt;其中的&lt;code&gt;x&lt;/code&gt;可以是一个变量，也可以是一个代表值的字面量（比如&lt;code&gt;1.23&lt;/code&gt;和&lt;code&gt;struct{}&lt;/code&gt;），还可以是一个表达式。&lt;/p&gt;

&lt;p&gt;注意，如果是表达式，那么该表达式的结果只能是一个值，而不能是多个值。在这个上下文中，&lt;code&gt;x&lt;/code&gt;可以被叫做源值，它的类型就是源类型，而那个&lt;code&gt;T&lt;/code&gt;代表的类型就是目标类型。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问：什么是别名类型？什么是潜在类型？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们可以用关键字&lt;code&gt;type&lt;/code&gt;声明自定义的各种类型。当然了，这些类型必须在 Go 语言基本类型和高级类型的范畴之内。在它们当中，有一种被叫做“别名类型”的类型。我们可以像下面这样声明它：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type MyString = string

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这条声明语句表示，&lt;code&gt;MyString&lt;/code&gt;是&lt;code&gt;string&lt;/code&gt;类型的别名类型。顾名思义，别名类型与其源类型的区别恐怕只是在名称上，它们是完全相同的。&lt;/p&gt;

&lt;p&gt;源类型与别名类型是一对概念，是两个对立的称呼。别名类型主要是为了代码重构而存在的。更详细的信息可参见 Go 语言官方的文档&lt;a href=&#34;https://golang.org/design/18130-type-alias&#34; target=&#34;_blank&#34;&gt;Proposal: Type Aliases&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Go 语言内建的基本类型中就存在两个别名类型。&lt;code&gt;byte&lt;/code&gt;是&lt;code&gt;uint8&lt;/code&gt;的别名类型，而&lt;code&gt;rune&lt;/code&gt;是&lt;code&gt;int32&lt;/code&gt;的别名类型。&lt;/p&gt;

&lt;p&gt;一定要注意，如果我这样声明：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type MyString2 string // 注意，这里没有等号。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;MyString2&lt;/code&gt;和&lt;code&gt;string&lt;/code&gt;就是两个不同的类型了。这里的&lt;code&gt;MyString2&lt;/code&gt;是一个新的类型，不同于其他任何类型。&lt;/p&gt;

&lt;p&gt;这种方式也可以被叫做对类型的再定义。我们刚刚把&lt;code&gt;string&lt;/code&gt;类型再定义成了另外一个类型&lt;code&gt;MyString2&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;7-数组和切片&#34;&gt;7.  数组和切片&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;数组类型的值（以下简称数组）的长度是固定的，而切片类型的值（以下简称切片）是可变长的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数组的长度在声明它的时候就必须给定，并且之后不会再改变。可以说，数组的长度是其类型的一部分。比如，&lt;code&gt;[1]string&lt;/code&gt;和&lt;code&gt;[2]string&lt;/code&gt;就是两个不同的数组类型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问：怎样正确估算切片的长度和容量？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当我们用&lt;code&gt;make&lt;/code&gt;函数初始化切片时，如果不指明其容量，那么它就会和长度一致。如果在初始化时指明了容量，那么切片的实际容量也就是它了。&lt;/p&gt;

&lt;p&gt;切片的容量代表了它的底层数组的长度，但这仅限于使用&lt;code&gt;make&lt;/code&gt;函数或者切片值字面量初始化切片的情况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问：怎样估算切片容量的增长？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一旦一个切片无法容纳更多的元素，Go 语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中。在一般的情况下，你可以简单地认为新切片的容量（以下简称新容量）将会是原切片容量（以下简称原容量）的 2 倍。&lt;/p&gt;

&lt;p&gt;但是，当原切片的长度（以下简称原长度）大于或等于&lt;code&gt;1024&lt;/code&gt;时，Go 语言将会以原容量的&lt;code&gt;1.25&lt;/code&gt;倍作为新容量的基准（以下新容量基准）。新容量基准会被调整（不断地与&lt;code&gt;1.25&lt;/code&gt;相乘），直到结果不小于原长度与要追加的元素数量之和（以下简称新长度）。最终，新容量往往会比新长度大一些，当然，相等也是可能的。&lt;/p&gt;

&lt;p&gt;另外，如果我们一次追加的元素过多，以至于使新长度比原容量的 2 倍还要大，那么新容量就会以新长度为基准。注意，与前面那种情况一样，最终的新容量在很多时候都要比新容量基准更大一些。更多细节可参见&lt;code&gt;runtime&lt;/code&gt;包中 slice.go 文件里的&lt;code&gt;growslice&lt;/code&gt;及相关函数的具体实现。&lt;/p&gt;

&lt;p&gt;我把展示上述扩容策略的一些例子都放到了 demo16.go 文件中。你可以去试运行看看。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问：切片的底层数组什么时候会被替换？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;确切地说，一个切片的底层数组永远不会被替换。为什么？虽然在扩容的时候 Go 语言一定会生成新的底层数组，但是它也同时生成了新的切片。&lt;/p&gt;

&lt;p&gt;它只是把新的切片作为了新底层数组的窗口，而没有对原切片，及其底层数组做任何改动。&lt;/p&gt;

&lt;p&gt;请记住，在无需扩容时，&lt;code&gt;append&lt;/code&gt;函数返回的是指向原底层数组的新切片，而在需要扩容时，&lt;code&gt;append&lt;/code&gt;函数返回的是指向新底层数组的新切片。所以，严格来讲，“扩容”这个词用在这里虽然形象但并不合适。不过鉴于这种称呼已经用得很广泛了，我们也没必要另找新词了。&lt;/p&gt;

&lt;p&gt;顺便说一下，只要新长度不会超过切片的原容量，那么使用&lt;code&gt;append&lt;/code&gt;函数对其追加元素的时候就不会引起扩容。这只会使紧邻切片窗口右边的（底层数组中的）元素被新的元素替换掉。&lt;/p&gt;

&lt;h2 id=&#34;8-container包中的那些容器&#34;&gt;8. container包中的那些容器&lt;/h2&gt;

&lt;p&gt;Go 语言的链表实现在标准库的&lt;code&gt;container/list&lt;/code&gt;代码包中。这个代码包中有两个公开的程序实体——&lt;code&gt;List&lt;/code&gt;和&lt;code&gt;Element&lt;/code&gt;，List 实现了一个双向链表（以下简称链表），而 Element 则代表了链表中元素的结构。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问：可以把自己生成的&lt;code&gt;Element&lt;/code&gt;类型值传给链表吗&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们在这里用到了&lt;code&gt;List&lt;/code&gt;的四种方法。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MoveBefore&lt;/code&gt;方法和&lt;code&gt;MoveAfter&lt;/code&gt;方法，它们分别用于把给定的元素移动到另一个元素的前面和后面。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MoveToFront&lt;/code&gt;方法和&lt;code&gt;MoveToBack&lt;/code&gt;方法，分别用于把给定的元素移动到链表的最前端和最后端。&lt;/p&gt;

&lt;p&gt;在这些方法中，“给定的元素”都是&lt;code&gt;*Element&lt;/code&gt;类型的，&lt;code&gt;*Element&lt;/code&gt;类型是&lt;code&gt;Element&lt;/code&gt;类型的指针类型，&lt;code&gt;*Element&lt;/code&gt;的值就是元素的指针。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (l *List) MoveBefore(e, mark *Element)
func (l *List) MoveAfter(e, mark *Element)
 
func (l *List) MoveToFront(e *Element)
func (l *List) MoveToBack(e *Element)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体问题是，如果我们自己生成这样的值，然后把它作为“给定的元素”传给链表的方法，那么会发生什么？链表会接受它吗？&lt;/p&gt;

&lt;p&gt;这里，给出一个&lt;strong&gt;典型回答&lt;/strong&gt;：不会接受，这些方法将不会对链表做出任何改动。因为我们自己生成的&lt;code&gt;Element&lt;/code&gt;值并不在链表中，所以也就谈不上“在链表中移动元素”。更何况链表不允许我们把自己生成的&lt;code&gt;Element&lt;/code&gt;值插入其中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题解析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;List&lt;/code&gt;包含的方法中，用于插入新元素的那些方法都只接受&lt;code&gt;interface{}&lt;/code&gt;类型的值。这些方法在内部会使用&lt;code&gt;Element&lt;/code&gt;值，包装接收到的新元素。&lt;/p&gt;

&lt;p&gt;这样做正是为了避免直接使用我们自己生成的元素，主要原因是避免链表的内部关联，遭到外界破坏，这对于链表本身以及我们这些使用者来说都是有益的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;List&lt;/code&gt;的方法还有下面这几种：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Front&lt;/code&gt;和&lt;code&gt;Back&lt;/code&gt;方法分别用于获取链表中最前端和最后端的元素，
&lt;code&gt;InsertBefore&lt;/code&gt;和&lt;code&gt;InsertAfter&lt;/code&gt;方法分别用于在指定的元素之前和之后插入新元素，&lt;code&gt;PushFront&lt;/code&gt;和&lt;code&gt;PushBack&lt;/code&gt;方法则分别用于在链表的最前端和最后端插入新元素。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (l *List) Front() *Element
func (l *List) Back() *Element
 
func (l *List) InsertBefore(v interface{}, mark *Element) *Element
func (l *List) InsertAfter(v interface{}, mark *Element) *Element
 
func (l *List) PushFront(v interface{}) *Element
func (l *List) PushBack(v interface{}) *Element
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些方法都会把一个&lt;code&gt;Element&lt;/code&gt;值的指针作为结果返回，它们就是链表留给我们的安全“接口”。拿到这些内部元素的指针，我们就可以去调用前面提到的用于移动元素的方法了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;知识扩展&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问：为什么链表可以做到开箱即用？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;List&lt;/code&gt;和&lt;code&gt;Element&lt;/code&gt;都是结构体类型。结构体类型有一个特点，那就是它们的零值都会是拥有特定结构，但是没有任何定制化内容的值，相当于一个空壳。值中的字段也都会被分别赋予各自类型的零值。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;广义来讲，所谓的零值就是只做了声明，但还未做初始化的变量被给予的缺省值。每个类型的零值都会依据该类型的特性而被设定。&lt;/p&gt;

&lt;p&gt;比如，经过语句&lt;code&gt;var a [2]int&lt;/code&gt;声明的变量&lt;code&gt;a&lt;/code&gt;的值，将会是一个包含了两个&lt;code&gt;0&lt;/code&gt;的整数数组。又比如，经过语句&lt;code&gt;var s []int&lt;/code&gt;声明的变量&lt;code&gt;s&lt;/code&gt;的值将会是一个&lt;code&gt;[]int&lt;/code&gt;类型的、值为&lt;code&gt;nil&lt;/code&gt;的切片。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么经过语句&lt;code&gt;var l list.List&lt;/code&gt;声明的变量&lt;code&gt;l&lt;/code&gt;的值将会是什么呢？[1] 这个零值将会是一个长度为&lt;code&gt;0&lt;/code&gt;的链表。这个链表持有的根元素也将会是一个空壳，其中只会包含缺省的内容。那这样的链表我们可以直接拿来使用吗？&lt;/p&gt;

&lt;p&gt;答案是，可以的。这被称为“开箱即用”。Go 语言标准库中很多结构体类型的程序实体都做到了开箱即用。这也是在编写可供别人使用的代码包（或者说程序库）时，我们推荐遵循的最佳实践之一。那么，语句&lt;code&gt;var l list.List&lt;/code&gt;声明的链表&lt;code&gt;l&lt;/code&gt;可以直接使用，这是怎么做到的呢？&lt;/p&gt;

&lt;p&gt;关键在于它的“延迟初始化”机制。&lt;/p&gt;

&lt;p&gt;所谓的&lt;strong&gt;延迟初始化&lt;/strong&gt;，你可以理解为把初始化操作延后，仅在实际需要的时候才进行。延迟初始化的优点在于“延后”，它可以分散初始化操作带来的计算量和存储空间消耗。&lt;/p&gt;

&lt;p&gt;例如，如果我们需要集中声明非常多的大容量切片的话，那么那时的 CPU 和内存空间的使用量肯定都会一个激增，并且只有设法让其中的切片及其底层数组被回收，内存使用量才会有所降低。&lt;/p&gt;

&lt;p&gt;如果数组是可以被延迟初始化的，那么计算量和存储空间的压力就可以被分散到实际使用它们的时候。这些数组被实际使用的时间越分散，延迟初始化带来的优势就会越明显。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;实际上，Go 语言的切片就起到了延迟初始化其底层数组的作用，你可以想一想为什么会这么说的理由。&lt;/p&gt;

&lt;p&gt;延迟初始化的缺点恰恰也在于“延后”。你可以想象一下，如果我在调用链表的每个方法的时候，它们都需要先去判断链表是否已经被初始化，那这也会是一个计算量上的浪费。在这些方法被非常频繁地调用的情况下，这种浪费的影响就开始显现了，程序的性能将会降低。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在这里的链表实现中，一些方法是无需对是否初始化做判断的。比如&lt;code&gt;Front&lt;/code&gt;方法和&lt;code&gt;Back&lt;/code&gt;方法，一旦发现链表的长度为&lt;code&gt;0&lt;/code&gt;, 直接返回&lt;code&gt;nil&lt;/code&gt;就好了。&lt;/p&gt;

&lt;p&gt;又比如，在用于删除元素、移动元素，以及一些用于插入元素的方法中，只要判断一下传入的元素中指向所属链表的指针，是否与当前链表的指针相等就可以了。&lt;/p&gt;

&lt;p&gt;如果不相等，就一定说明传入的元素不是这个链表中的，后续的操作就不用做了。反之，就一定说明这个链表已经被初始化了。&lt;/p&gt;

&lt;p&gt;原因在于，链表的&lt;code&gt;PushFront&lt;/code&gt;方法、&lt;code&gt;PushBack&lt;/code&gt;方法、&lt;code&gt;PushBackList&lt;/code&gt;方法以及&lt;code&gt;PushFrontList&lt;/code&gt;方法总会先判断链表的状态，并在必要时进行初始化，这就是延迟初始化。&lt;/p&gt;

&lt;p&gt;而且，我们在向一个空的链表中添加新元素的时候，肯定会调用这四个方法中的一个，这时新元素中指向所属链表的指针，一定会被设定为当前链表的指针。所以，指针相等是链表已经初始化的充分必要条件。&lt;/p&gt;

&lt;p&gt;明白了吗？&lt;code&gt;List&lt;/code&gt;利用了自身以及&lt;code&gt;Element&lt;/code&gt;在结构上的特点，巧妙地平衡了延迟初始化的优缺点，使得链表可以开箱即用，并且在性能上可以达到最优。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问：&lt;code&gt;Ring&lt;/code&gt;与&lt;code&gt;List&lt;/code&gt;的区别在哪儿？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;container/ring&lt;/code&gt;包中的&lt;code&gt;Ring&lt;/code&gt;类型实现的是一个循环链表，也就是我们俗称的环。其实&lt;code&gt;List&lt;/code&gt;在内部就是一个循环链表。它的根元素永远不会持有任何实际的元素值，而该元素的存在就是为了连接这个循环链表的首尾两端。&lt;/p&gt;

&lt;p&gt;所以也可以说，&lt;code&gt;List&lt;/code&gt;的零值是一个只包含了根元素，但不包含任何实际元素值的空链表。那么，既然&lt;code&gt;Ring&lt;/code&gt;和&lt;code&gt;List&lt;/code&gt;在本质上都是循环链表，那它们到底有什么不同呢？&lt;/p&gt;

&lt;p&gt;最主要的不同有下面几种。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Ring&lt;/code&gt;类型的数据结构仅由它自身即可代表，而&lt;code&gt;List&lt;/code&gt;类型则需要由它以及&lt;code&gt;Element&lt;/code&gt;类型联合表示。这是表示方式上的不同，也是结构复杂度上的不同。&lt;/li&gt;
&lt;li&gt;一个&lt;code&gt;Ring&lt;/code&gt;类型的值严格来讲，只代表了其所属的循环链表中的一个元素，而一个&lt;code&gt;List&lt;/code&gt;类型的值则代表了一个完整的链表。这是表示维度上的不同。&lt;/li&gt;
&lt;li&gt;在创建并初始化一个&lt;code&gt;Ring&lt;/code&gt;值的时候，我们可以指定它包含的元素的数量，但是对于一个&lt;code&gt;List&lt;/code&gt;值来说却不能这样做（也没有必要这样做）。循环链表一旦被创建，其长度是不可变的。这是两个代码包中的&lt;code&gt;New&lt;/code&gt;函数在功能上的不同，也是两个类型在初始化值方面的第一个不同。&lt;/li&gt;
&lt;li&gt;仅通过&lt;code&gt;var r ring.Ring&lt;/code&gt;语句声明的&lt;code&gt;r&lt;/code&gt;将会是一个长度为&lt;code&gt;1&lt;/code&gt;的循环链表，而&lt;code&gt;List&lt;/code&gt;类型的零值则是一个长度为&lt;code&gt;0&lt;/code&gt;的链表。别忘了&lt;code&gt;List&lt;/code&gt;中的根元素不会持有实际元素值，因此计算长度时不会包含它。这是两个类型在初始化值方面的第二个不同。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ring&lt;/code&gt;值的&lt;code&gt;Len&lt;/code&gt;方法的算法复杂度是 O(N) 的，而&lt;code&gt;List&lt;/code&gt;值的&lt;code&gt;Len&lt;/code&gt;方法的算法复杂度则是 O(1) 的。这是两者在性能方面最显而易见的差别。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其他的不同基本上都是方法方面的了。比如，循环链表也有用于插入、移动或删除元素的方法，不过用起来都显得更抽象一些，等等。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;9-字典的操作和约束&#34;&gt;9. 字典的操作和约束&lt;/h2&gt;

&lt;p&gt;为什么字典的键类型会受到约束？&lt;/p&gt;

&lt;p&gt;Go 语言的字典类型其实是一个哈希表（hash table）的特定实现，在这个实现中，键和元素的最大不同在于，键的类型是受限的，而元素却可以是任意类型的。&lt;/p&gt;

&lt;p&gt;如果要探究限制的原因，我们就先要了解哈希表中最重要的一个过程：映射。&lt;/p&gt;

&lt;p&gt;你可以把键理解为元素的一个索引，我们可以在哈希表中通过键查找与它成对的那个元素。&lt;/p&gt;

&lt;p&gt;映射过程的第一步就是：把键值转换为哈希值。**&lt;/p&gt;

&lt;p&gt;在 Go 语言的字典中，每一个键值都是由它的哈希值代表的。也就是说，字典不会独立存储任何键的值，但会独立存储它们的哈希值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问：字典的键类型不能是哪些类型？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Go 语言字典的键类型不可以是函数类型、字典类型和切片类型。&lt;/p&gt;

&lt;p&gt;Go 语言规范规定，在键类型的值之间必须可以施加操作符&lt;code&gt;==&lt;/code&gt;和&lt;code&gt;!=&lt;/code&gt;。换句话说，键类型的值必须要支持判等操作。由于函数类型、字典类型和切片类型的值并不支持判等操作，所以字典的键类型不能是这些类型。&lt;/p&gt;

&lt;p&gt;另外，如果键的类型是接口类型的，那么键值的实际类型也不能是上述三种类型，否则在程序运行过程中会引发 panic（即运行时恐慌）。&lt;/p&gt;

&lt;p&gt;我们举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var badMap2 = map[interface{}]int{
	&amp;quot;1&amp;quot;:   1,
	[]int{2}: 2, // 这里会引发 panic。
	3:    3,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的变量&lt;code&gt;badMap2&lt;/code&gt;的类型是键类型为&lt;code&gt;interface{}&lt;/code&gt;、值类型为&lt;code&gt;int&lt;/code&gt;的字典类型。这样声明并不会引起什么错误。或者说，我通过这样的声明躲过了 Go 语言编译器的检查。&lt;/p&gt;

&lt;p&gt;注意，我用字面量在声明该字典的同时对它进行了初始化，使它包含了三个键 - 元素对。其中第二个键 - 元素对的键值是&lt;code&gt;[]int{2}&lt;/code&gt;，元素值是&lt;code&gt;2&lt;/code&gt;。这样的键值也不会让 Go 语言编译器报错，因为从语法上说，这样做是可以的。&lt;/p&gt;

&lt;p&gt;但是，当我们运行这段代码的时候，Go 语言的运行时（runtime）系统就会发现这里的问题，它会抛出一个 panic，并把根源指向字面量中定义第二个键 - 元素对的那一行。我们越晚发现问题，修正问题的成本就会越高，所以最好不要把字典的键类型设定为任何接口类型。&lt;/p&gt;

&lt;p&gt;还要注意，如果键的类型是数组类型，那么还要确保该类型的元素类型不是函数类型、字典类型或切片类型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问：应该优先考虑哪些类型作为字典的键类型？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你现在已经清楚了，在 Go 语言中，有些类型的值是支持判等的，有些是不支持的。那么在这些值支持判等的类型当中，哪些更适合作为字典的键类型呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;答案是，优先选用数值类型和指针类型，通常情况下类型的宽度越小越好。如果非要选择字符串类型的话，最好对键值的长度进行额外的约束。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题 2：在值为&lt;code&gt;nil&lt;/code&gt;的字典上执行读操作会成功吗，那写操作呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于字典是引用类型，所以当我们仅声明而不初始化一个字典类型的变量的时候，它的值会是&lt;code&gt;nil&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;除了添加键 - 元素对，我们在一个值为&lt;code&gt;nil&lt;/code&gt;的字典上做任何操作都不会引起错误。当我们试图在一个值为&lt;code&gt;nil&lt;/code&gt;的字典中添加键 - 元素对的时候，Go 语言的运行时系统就会立即抛出一个 panic。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;10-通道的基本操作&#34;&gt;10. 通道的基本操作&lt;/h2&gt;

&lt;p&gt;通道类型的值本身就是并发安全的，这也是 Go 语言自带的、唯一一个可以满足并发安全性的类型。&lt;/p&gt;

&lt;p&gt;当容量为&lt;code&gt;0&lt;/code&gt;时，我们可以称通道为非缓冲通道，也就是不带缓冲的通道。而当容量大于&lt;code&gt;0&lt;/code&gt;时，我们可以称为缓冲通道，也就是带有缓冲的通道&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个通道相当于一个先进先出（FIFO）的队列。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。元素值的发送和接收都需要用到操作符&lt;code&gt;&amp;lt;-&lt;/code&gt;。我们也可以叫它接送操作符。一个左尖括号紧接着一个减号形象地代表了元素值的传输方向。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问：对通道的发送和接收操作都有哪些基本的特性？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;它们的基本特性如下。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的。&lt;/li&gt;
&lt;li&gt;发送操作和接收操作中对元素值的处理都是不可分割的。&lt;/li&gt;
&lt;li&gt;发送操作在完全完成之前会被阻塞。接收操作也是如此。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;问题解析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我们先来看第一个基本特性。&lt;/strong&gt; 在同一时刻，Go 语言的运行时系统（以下简称运行时系统）只会执行对同一个通道的任意个发送操作中的某一个。&lt;/p&gt;

&lt;p&gt;直到这个元素值被完全复制进该通道之后，其他针对该通道的发送操作才可能被执行。&lt;/p&gt;

&lt;p&gt;类似的，在同一时刻，运行时系统也只会执行，对同一个通道的任意个接收操作中的某一个。&lt;/p&gt;

&lt;p&gt;直到这个元素值完全被移出该通道之后，其他针对该通道的接收操作才可能被执行。即使这些操作是并发执行的也是如此。&lt;/p&gt;

&lt;p&gt;这里所谓的并发执行，你可以这样认为，多个代码块分别在不同的 goroutine 之中，并有机会在同一个时间段内被执行。&lt;/p&gt;

&lt;p&gt;另外，对于通道中的同一个元素值来说，发送操作和接收操作之间也是互斥的。例如，虽然会出现，正在被复制进通道但还未复制完成的元素值，但是这时它绝不会被想接收它的一方看到和取走。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这里要注意的一个细节是，元素值从外界进入通道时会被复制。更具体地说，进入通道的并不是在接收操作符右边的那个元素值，而是它的副本。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另一方面，元素值从通道进入外界时会被移动。这个移动操作实际上包含了两步，第一步是生成正在通道中的这个元素值的副本，并准备给到接收方，第二步是删除在通道中的这个元素值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;顺着这个细节再来看第二个基本特性。&lt;/strong&gt; 这里的“不可分割”的意思是，它们处理元素值时都是一气呵成的，绝不会被打断。&lt;/p&gt;

&lt;p&gt;例如，发送操作要么还没复制元素值，要么已经复制完毕，绝不会出现只复制了一部分的情况。&lt;/p&gt;

&lt;p&gt;又例如，接收操作在准备好元素值的副本之后，一定会删除掉通道中的原值，绝不会出现通道中仍有残留的情况。&lt;/p&gt;

&lt;p&gt;这既是为了保证通道中元素值的完整性，也是为了保证通道操作的唯一性。对于通道中的同一个元素值来说，它只可能是某一个发送操作放入的，同时也只可能被某一个接收操作取出。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;再来说第三个基本特性。&lt;/strong&gt; 一般情况下，发送操作包括了“复制元素值”和“放置副本到通道内部”这两个步骤。&lt;/p&gt;

&lt;p&gt;在这两个步骤完全完成之前，发起这个发送操作的那句代码会一直阻塞在那里。也就是说，在它之后的代码不会有执行的机会，直到这句代码的阻塞解除。&lt;/p&gt;

&lt;p&gt;更细致地说，在通道完成发送操作之后，运行时系统会通知这句代码所在的 goroutine，以使它去争取继续运行代码的机会。&lt;/p&gt;

&lt;p&gt;另外，接收操作通常包含了“复制通道内的元素值”“放置副本到接收方”“删掉原值”三个步骤。&lt;/p&gt;

&lt;p&gt;在所有这些步骤完全完成之前，发起该操作的代码也会一直阻塞，直到该代码所在的 goroutine 收到了运行时系统的通知并重新获得运行机会为止。&lt;/p&gt;

&lt;p&gt;说到这里，你可能已经感觉到，&lt;strong&gt;如此阻塞代码其实就是为了实现操作的互斥和元素值的完整。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;知识扩展&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题 1：发送操作和接收操作在什么时候可能被长时间的阻塞？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;先说针对&lt;strong&gt;缓冲通道&lt;/strong&gt;的情况。如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接收走。&lt;/p&gt;

&lt;p&gt;这时，通道会优先通知最早因此而等待的、那个发送操作所在的 goroutine，后者会再次执行发送操作。&lt;/p&gt;

&lt;p&gt;由于发送操作在这种情况下被阻塞后，它们所在的 goroutine 会顺序地进入通道内部的发送等待队列，所以通知的顺序总是公平的。&lt;/p&gt;

&lt;p&gt;相对的，如果通道已空，那么对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。这时，通道会通知最早等待的那个接收操作所在的 goroutine，并使它再次执行接收操作。&lt;/p&gt;

&lt;p&gt;因此而等待的、所有接收操作所在的 goroutine，都会按照先后顺序被放入通道内部的接收等待队列。&lt;/p&gt;

&lt;p&gt;对于&lt;strong&gt;非缓冲通道&lt;/strong&gt;，情况要简单一些。无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。由此可见，非缓冲通道是在用同步的方式传递数据。也就是说，只有收发双方对接上了，数据才会被传递。&lt;/p&gt;

&lt;p&gt;并且，数据是直接从发送方复制到接收方的，中间并不会用非缓冲通道做中转。相比之下，缓冲通道则在用异步的方式传递数据。&lt;/p&gt;

&lt;p&gt;在大多数情况下，缓冲通道会作为收发双方的中间件。正如前文所述，元素值会先从发送方复制到缓冲通道，之后再由缓冲通道复制给接收方。&lt;/p&gt;

&lt;p&gt;但是，当发送操作在执行的时候发现空的通道中，正好有等待的接收操作，那么它会直接把元素值复制给接收方。&lt;/p&gt;

&lt;p&gt;以上说的都是在正确使用通道的前提下会发生的事情。下面我特别说明一下，由于错误使用通道而造成的阻塞。&lt;/p&gt;

&lt;p&gt;对于值为&lt;code&gt;nil&lt;/code&gt;的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态。它们所属的 goroutine 中的任何代码，都不再会被执行。&lt;/p&gt;

&lt;p&gt;注意，由于通道类型是引用类型，所以它的零值就是&lt;code&gt;nil&lt;/code&gt;。换句话说，当我们只声明该类型的变量但没有用&lt;code&gt;make&lt;/code&gt;函数对它进行初始化时，该变量的值就会是&lt;code&gt;nil&lt;/code&gt;。我们一定不要忘记初始化通道！&lt;/p&gt;

&lt;p&gt;你可以去看一下 demo21.go，我在里面用代码罗列了一下会造成阻塞的几种情况。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题 2：发送操作和接收操作在什么时候会引发 panic？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于一个已初始化，但并未关闭的通道来说，收发操作一定不会引发 panic。但是通道一旦关闭，再对它进行发送操作，就会引发 panic。&lt;/p&gt;

&lt;p&gt;另外，如果我们试图关闭一个已经关闭了的通道，也会引发 panic。注意，接收操作是可以感知到通道的关闭的，并能够安全退出。&lt;/p&gt;

&lt;p&gt;更具体地说，当我们把接收表达式的结果同时赋给两个变量时，第二个变量的类型就是一定&lt;code&gt;bool&lt;/code&gt;类型。它的值如果为&lt;code&gt;false&lt;/code&gt;就说明通道已经关闭，并且再没有元素值可取了。&lt;/p&gt;

&lt;p&gt;注意，如果通道关闭时，里面还有元素值未被取出，那么接收表达式的第一个结果，仍会是通道中的某一个元素值，而第二个结果值一定会是&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;因此，通过接收表达式的第二个结果值，来判断通道是否关闭是可能有延时的。&lt;/p&gt;

&lt;p&gt;由于通道的收发操作有上述特性，所以除非有特殊的保障措施，我们千万不要让接收方关闭通道，而应当让发送方做这件事。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go语言核心36讲思考题</title>
      <link>/go/interview/gocore36-think/</link>
      <pubDate>Tue, 28 Jul 2020 19:25:43 +0800</pubDate>
      <guid>/go/interview/gocore36-think/</guid>
      <description>

&lt;h2 id=&#34;基础概念篇&#34;&gt;基础概念篇&lt;/h2&gt;

&lt;h3 id=&#34;1-go-语言在多个工作区中查找依赖包的时候是以怎样的顺序进行的&#34;&gt;1. Go 语言在多个工作区中查找依赖包的时候是以怎样的顺序进行的？&lt;/h3&gt;

&lt;p&gt;答：你设置的环境变量&lt;code&gt;GOPATH&lt;/code&gt;的值决定了这个顺序。如果你在&lt;code&gt;GOPATH&lt;/code&gt;中设置了多个工作区，那么这种查找会以从左到右的顺序在这些工作区中进行。&lt;/p&gt;

&lt;p&gt;你可以通过试验来确定这个问题的答案。例如：先在一个源码文件中导入一个在你的机器上并不存在的代码包，然后编译这个代码文件。最后，将输出的编译错误信息与&lt;code&gt;GOPATH&lt;/code&gt;的值进行对比。&lt;/p&gt;

&lt;h3 id=&#34;2-如果在多个工作区中都存在导入路径相同的代码包会产生冲突吗&#34;&gt;2. 如果在多个工作区中都存在导入路径相同的代码包会产生冲突吗？&lt;/h3&gt;

&lt;p&gt;答：不会产生冲突。因为代码包的查找是按照已给定的顺序逐一地在多个工作区中进行的。&lt;/p&gt;

&lt;h3 id=&#34;3-默认情况下-我们可以让命令源码文件接受哪些类型的参数值&#34;&gt;3. 默认情况下，我们可以让命令源码文件接受哪些类型的参数值？&lt;/h3&gt;

&lt;p&gt;答：这个问题通过查看&lt;code&gt;flag&lt;/code&gt;代码包的文档就可以回答了。概括来讲，有布尔类型、整数类型、浮点数类型、字符串类型，以及&lt;code&gt;time.Duration&lt;/code&gt;类型。&lt;/p&gt;

&lt;h3 id=&#34;4-我们可以把自定义的数据类型作为参数值的类型吗-如果可以-怎样做&#34;&gt;4. 我们可以把自定义的数据类型作为参数值的类型吗？如果可以，怎样做？&lt;/h3&gt;

&lt;p&gt;答：狭义上讲是不可以的，但是广义上讲是可以的。这需要一些定制化的工作，并且被给定的参数值只能是序列化的。具体可参见&lt;code&gt;flag&lt;/code&gt;代码包文档中的例子。&lt;/p&gt;

&lt;h3 id=&#34;5-如果你需要导入两个代码包-而这两个代码包的导入路径的最后一级是相同的-比如-dep-lib-flag-和-flag-那么会产生冲突吗&#34;&gt;5. 如果你需要导入两个代码包，而这两个代码包的导入路径的最后一级是相同的，比如：&lt;code&gt;dep/lib/flag&lt;/code&gt;和&lt;code&gt;flag&lt;/code&gt;，那么会产生冲突吗？&lt;/h3&gt;

&lt;p&gt;答：这会产生冲突。因为代表两个代码包的标识符重复了，都是&lt;code&gt;flag&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;6-如果会产生冲突-那么怎样解决这种冲突-有几种方式&#34;&gt;6. 如果会产生冲突，那么怎样解决这种冲突？有几种方式？&lt;/h3&gt;

&lt;p&gt;答：接上一个问题。很简单，导入代码包的时候给它起一个别名就可以了，比如： &lt;code&gt;import libflag &amp;quot;dep/lib/flag&amp;quot;&lt;/code&gt;。或者，以本地化的方式导入代码包，如：&lt;code&gt;import . &amp;quot;dep/lib/flag&amp;quot;&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;7-如果与当前的变量重名的是外层代码块中的变量-那么意味着什么&#34;&gt;7. 如果与当前的变量重名的是外层代码块中的变量，那么意味着什么？&lt;/h3&gt;

&lt;p&gt;答：这意味着这两个变量成为了“可重名变量”。在内层的变量所处的那个代码块以及更深层次的代码块中，这个变量会“屏蔽”掉外层代码块中的那个变量。&lt;/p&gt;

&lt;h3 id=&#34;8-如果通过-import-xxx-这种方式导入的代码包中的变量与当前代码包中的变量重名了-那么-go-语言是会把它们当做-可重名变量-看待还是会报错呢&#34;&gt;8. 如果通过&lt;code&gt;import . XXX&lt;/code&gt;这种方式导入的代码包中的变量与当前代码包中的变量重名了，那么 Go 语言是会把它们当做“可重名变量”看待还是会报错呢？&lt;/h3&gt;

&lt;p&gt;答：这两个变量会成为“可重名变量”。虽然这两个变量在这种情况下的作用域都是当前代码包的当前文件，但是它们所处的代码块是不同的。&lt;/p&gt;

&lt;p&gt;当前文件中的变量处在该文件所代表的代码块中，而被导入的代码包中的变量却处在声明它的那个文件所代表的代码块中。当然，我们也可以说被导入的代码包所代表的代码块包含了这个变量。&lt;/p&gt;

&lt;p&gt;在当前文件中，本地的变量会“屏蔽”掉被导入的变量。&lt;/p&gt;

&lt;h3 id=&#34;9-除了-程序实体的那些事儿-3-一文中提及的那些-你还认为类型转换规则中有哪些值得注意的地方&#34;&gt;9. 除了《程序实体的那些事儿 3》一文中提及的那些，你还认为类型转换规则中有哪些值得注意的地方？&lt;/h3&gt;

&lt;p&gt;答：简单来说，我们在进行类型转换的时候需要注意各种符号的优先级。具体可参见 Go 语言规范中的转换部分。&lt;/p&gt;

&lt;h3 id=&#34;10-你能具体说说别名类型在代码重构过程中可以起到的哪些作用吗&#34;&gt;10. 你能具体说说别名类型在代码重构过程中可以起到的哪些作用吗？&lt;/h3&gt;

&lt;p&gt;答：简单来说，我们可以通过别名类型实现外界无感知的代码重构。具体可参见 Go 语言官方的文档 Proposal: Type Aliases。&lt;/p&gt;

&lt;h2 id=&#34;数据类型和语句篇&#34;&gt;数据类型和语句篇&lt;/h2&gt;

&lt;h3 id=&#34;11-如果有多个切片指向了同一个底层数组-那么你认为应该注意些什么&#34;&gt;11. 如果有多个切片指向了同一个底层数组，那么你认为应该注意些什么？&lt;/h3&gt;

&lt;p&gt;答：我们需要特别注意的是，当操作其中一个切片的时候是否会影响到其他指向同一个底层数组的切片。&lt;/p&gt;

&lt;p&gt;如果是，那么问一下自己，这是你想要的结果吗？无论如何，通过这种方式来组织或共享数据是不正确的。你需要做的是，要么彻底切断这些切片的底层联系，要么立即为所有的相关操作加锁。&lt;/p&gt;

&lt;h3 id=&#34;12-怎样沿用-扩容-的思想对切片进行-缩容&#34;&gt;12. 怎样沿用“扩容”的思想对切片进行“缩容”？&lt;/h3&gt;

&lt;p&gt;答：关于切片的“缩容”，可参看官方的相关 wiki。不过，如果你需要频繁的“缩容”，那么就可能需要考虑其他的数据结构了，比如：&lt;code&gt;container/list&lt;/code&gt;代码包中的&lt;code&gt;List&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;13-container-ring-包中的循环链表的适用场景都有哪些&#34;&gt;13. &lt;code&gt;container/ring&lt;/code&gt;包中的循环链表的适用场景都有哪些？&lt;/h3&gt;

&lt;p&gt;答：比如：可重用的资源（缓存等）的存储，或者需要灵活组织的资源池，等等。&lt;/p&gt;

&lt;h3 id=&#34;14-container-heap-包中的堆的适用场景又有哪些呢&#34;&gt;14. &lt;code&gt;container/heap&lt;/code&gt;包中的堆的适用场景又有哪些呢？&lt;/h3&gt;

&lt;p&gt;答：它最重要的用途就是构建优先级队列，并且这里的“优先级”可以很灵活。所以，想象空间很大。&lt;/p&gt;

&lt;h3 id=&#34;15-字典类型的值是并发安全的吗-如果不是-那么在我们只在字典上添加或删除键-元素对的情况下-依然不安全吗&#34;&gt;15. 字典类型的值是并发安全的吗？如果不是，那么在我们只在字典上添加或删除键 - 元素对的情况下，依然不安全吗？&lt;/h3&gt;

&lt;p&gt;答：字典类型的值不是并发安全的，即使我们只是增减其中的键值对也是如此。其根本原因是，字典值内部有时候会根据需要进行存储方面的调整。&lt;/p&gt;

&lt;h3 id=&#34;16-通道的长度代表着什么-它在什么时候会通道的容量相同&#34;&gt;16. 通道的长度代表着什么？它在什么时候会通道的容量相同？&lt;/h3&gt;

&lt;p&gt;通道的长度代表它当前包含的元素值的个数。当通道已满时，其长度会与容量相同。&lt;/p&gt;

&lt;h3 id=&#34;17-元素值在经过通道传递时会被复制-那么这个复制是浅表复制还是深层复制呢&#34;&gt;17. 元素值在经过通道传递时会被复制，那么这个复制是浅表复制还是深层复制呢？&lt;/h3&gt;

&lt;p&gt;答：浅表复制。实际上，在 Go 语言中并不存在深层次的复制，除非我们自己来做。&lt;/p&gt;

&lt;h3 id=&#34;18-如果在-select-语句中发现某个通道已关闭-那么应该怎样屏蔽掉它所在的分支&#34;&gt;18. 如果在&lt;code&gt;select&lt;/code&gt;语句中发现某个通道已关闭，那么应该怎样屏蔽掉它所在的分支？&lt;/h3&gt;

&lt;p&gt;答：很简单，把&lt;code&gt;nil&lt;/code&gt;赋给代表了这个通道的变量就可以了。如此一来，对于这个通道（那个变量）的发送操作和接收操作就会永远被阻塞。&lt;/p&gt;

&lt;h3 id=&#34;19-在-select-语句与-for-语句联用时-怎样直接退出外层的-for-语句&#34;&gt;19. 在&lt;code&gt;select&lt;/code&gt;语句与&lt;code&gt;for&lt;/code&gt;语句联用时，怎样直接退出外层的&lt;code&gt;for&lt;/code&gt;语句？&lt;/h3&gt;

&lt;p&gt;答：这一般会用到&lt;code&gt;goto&lt;/code&gt;语句和标签（label），具体请参看 Go 语言规范的这部分。&lt;/p&gt;

&lt;h3 id=&#34;20-complexarray1-被传入函数的话-这个函数中对该参数值的修改会影响到它的原值吗&#34;&gt;20. &lt;code&gt;complexArray1&lt;/code&gt;被传入函数的话，这个函数中对该参数值的修改会影响到它的原值吗？&lt;/h3&gt;

&lt;p&gt;答：文中&lt;code&gt;complexArray1&lt;/code&gt;变量的声明如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;complexArray1 := [3][]string{
	[]string{&amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;f&amp;quot;},
	[]string{&amp;quot;g&amp;quot;, &amp;quot;h&amp;quot;, &amp;quot;i&amp;quot;},
	[]string{&amp;quot;j&amp;quot;, &amp;quot;k&amp;quot;, &amp;quot;l&amp;quot;},
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这要看怎样修改了。虽然&lt;code&gt;complexArray1&lt;/code&gt;本身是一个数组，但是其中的元素却都是切片。如果对&lt;code&gt;complexArray1&lt;/code&gt;中的元素进行增减，那么原值就不会受到影响。但若要修改它已有的元素值，那么原值也会跟着改变。&lt;/p&gt;

&lt;h3 id=&#34;21-函数真正拿到的参数值其实只是它们的副本-那么函数返回给调用方的结果值也会被复制吗&#34;&gt;21. 函数真正拿到的参数值其实只是它们的副本，那么函数返回给调用方的结果值也会被复制吗？&lt;/h3&gt;

&lt;p&gt;答：函数返回给调用方的结果值也会被复制。不过，在一般情况下，我们不用太在意。但如果函数在返回结果值之后依然保持执行并会对结果值进行修改，那么我们就需要注意了。&lt;/p&gt;

&lt;h3 id=&#34;22-我们可以在结构体类型中嵌入某个类型的指针类型吗-如果可以-有哪些注意事项&#34;&gt;22. 我们可以在结构体类型中嵌入某个类型的指针类型吗？如果可以，有哪些注意事项？&lt;/h3&gt;

&lt;p&gt;答：当然可以。在这时，我们依然需要注意各种“屏蔽”现象。由于某个类型的指针类型会包含与前者有关联的所有方法，所以我们更要注意。&lt;/p&gt;

&lt;p&gt;另外，我们在嵌入和引用这样的字段的时候还需要注意一些冲突方面的问题，具体请参看 Go 语言规范的这一部分。&lt;/p&gt;

&lt;h3 id=&#34;23-字面量-struct-代表了什么-又有什么用处&#34;&gt;23. 字面量&lt;code&gt;struct{}&lt;/code&gt;代表了什么？又有什么用处？&lt;/h3&gt;

&lt;p&gt;答：字面量&lt;code&gt;struct{}&lt;/code&gt;代表了空的结构体类型。这样的类型既不包含任何字段也没有任何方法。该类型的值所需的存储空间几乎可以忽略不计。&lt;/p&gt;

&lt;p&gt;因此，我们可以把这样的值作为占位值来使用。比如：在同一个应用场景下，&lt;code&gt;map[int] [int]bool&lt;/code&gt;类型的值占用更少的存储空间。&lt;/p&gt;

&lt;h3 id=&#34;24-如果我们把一个值为-nil-的某个实现类型的变量赋给了接口变量-那么在这个接口变量上仍然可以调用该接口的方法吗-如果可以-有哪些注意事项-如果不可以-原因是什么&#34;&gt;24. 如果我们把一个值为&lt;code&gt;nil&lt;/code&gt;的某个实现类型的变量赋给了接口变量，那么在这个接口变量上仍然可以调用该接口的方法吗？如果可以，有哪些注意事项？如果不可以，原因是什么？&lt;/h3&gt;

&lt;p&gt;答：可以调用。但是请注意，这个被调用的方法在此时所持有的接收者的值是&lt;code&gt;nil&lt;/code&gt;。因此，如果该方法引用了其接收者的某个字段，那么就会引发 panic！&lt;/p&gt;

&lt;h3 id=&#34;25-引用类型的值的指针值是有意义的吗-如果没有意义-为什么-如果有意义-意义在哪里&#34;&gt;25. 引用类型的值的指针值是有意义的吗？如果没有意义，为什么？如果有意义，意义在哪里？&lt;/h3&gt;

&lt;p&gt;答：从存储和传递的角度看，没有意义。因为引用类型的值已经相当于指向某个底层数据结构的指针了。当然，引用类型的值不只是指针那么简单。&lt;/p&gt;

&lt;h3 id=&#34;26-用什么手段可以对-goroutine-的启用数量加以限制&#34;&gt;26. 用什么手段可以对 goroutine 的启用数量加以限制？&lt;/h3&gt;

&lt;p&gt;答：一个很简单且很常用的方法是，使用一个通道保存一些令牌。只有先拿到一个令牌，才能启用一个 goroutine。另外在&lt;code&gt;go&lt;/code&gt;函数即将执行结束的时候还需要把令牌及时归还给那个通道。&lt;/p&gt;

&lt;p&gt;更高级的手段就需要比较完整的设计了。比如，任务分发器 + 任务管道（单层的通道）+ 固定个数的 goroutine。又比如，动态任务池（多层的通道）+ 动态 goroutine 池（可由前述的那个令牌方案演化而来）。等等。&lt;/p&gt;

&lt;h3 id=&#34;27-runtime-包中提供了哪些与模型三要素-g-p-和-m-相关的函数&#34;&gt;27. &lt;code&gt;runtime&lt;/code&gt;包中提供了哪些与模型三要素 G、P 和 M 相关的函数？&lt;/h3&gt;

&lt;p&gt;答：关于这个问题，我相信你一查文档便知。在线文档在这里。不过光知道还不够，还要会用。&lt;/p&gt;

&lt;h3 id=&#34;28-在类型-switch-语句中-我们怎样对被判断类型的那个值做相应的类型转换&#34;&gt;28. 在类型&lt;code&gt;switch&lt;/code&gt;语句中，我们怎样对被判断类型的那个值做相应的类型转换？&lt;/h3&gt;

&lt;p&gt;答：其实这个事情可以让 Go 语言自己来做，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;switch t := x.(type) {
// cases
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当流程进入到某个&lt;code&gt;case&lt;/code&gt;子句的时候，变量&lt;code&gt;t&lt;/code&gt;的值就已经被自动地转换为相应类型的值了。&lt;/p&gt;

&lt;h3 id=&#34;29-在-if-语句中-初始化子句声明的变量的作用域是什么&#34;&gt;29. 在&lt;code&gt;if&lt;/code&gt;语句中，初始化子句声明的变量的作用域是什么？&lt;/h3&gt;

&lt;p&gt;答：如果这个变量是新的变量，那么它的作用域就是当前&lt;code&gt;if&lt;/code&gt;语句所代表的代码块。注意，后续的&lt;code&gt;else if&lt;/code&gt;子句和&lt;code&gt;else&lt;/code&gt;子句也包含在当前的&lt;code&gt;if&lt;/code&gt;语句代表的代码块之内。&lt;/p&gt;

&lt;h3 id=&#34;30-请列举出你经常用到或者看到的-3-个错误类型-它们所在的错误类型体系都是怎样的-你能画出一棵树来描述它们吗&#34;&gt;30. 请列举出你经常用到或者看到的 3 个错误类型，它们所在的错误类型体系都是怎样的？你能画出一棵树来描述它们吗？&lt;/h3&gt;

&lt;p&gt;答：略。这需要你自己去做，我代替不了你。&lt;/p&gt;

&lt;h3 id=&#34;31-请列举出你经常用到或者看到的-3-个错误值-它们分别在哪个错误值列表里-这些错误值列表分别包含的是哪个种类的错误&#34;&gt;31. 请列举出你经常用到或者看到的 3 个错误值，它们分别在哪个错误值列表里？这些错误值列表分别包含的是哪个种类的错误？&lt;/h3&gt;

&lt;p&gt;答：略。这需要你自己去做，我代替不了你。&lt;/p&gt;

&lt;h3 id=&#34;32-一个函数怎样才能把-panic-转化为-error-类型值-并将其作为函数的结果值返回给调用方&#34;&gt;32. 一个函数怎样才能把 panic 转化为&lt;code&gt;error&lt;/code&gt;类型值，并将其作为函数的结果值返回给调用方？&lt;/h3&gt;

&lt;p&gt;答：可以这样编写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func doSomething() (err error) {
	defer func() {
		p := recover()
		err = fmt.Errorf(&amp;quot;FATAL ERROR: %s&amp;quot;, p)
	}()
	panic(&amp;quot;Oops!!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意结果声明的写法。这是一个带有名称的结果声明。&lt;/p&gt;

&lt;h3 id=&#34;33-我们可以在-defer-函数中恢复-panic-那么可以在其中引发-panic-吗&#34;&gt;33. 我们可以在&lt;code&gt;defer&lt;/code&gt;函数中恢复 panic，那么可以在其中引发 panic 吗？&lt;/h3&gt;

&lt;p&gt;答：当然可以。这样做可以把原先的 panic 包装一下再抛出去。&lt;/p&gt;

&lt;h2 id=&#34;go-程序的测试&#34;&gt;Go 程序的测试&lt;/h2&gt;

&lt;h3 id=&#34;34-除了本文中提到的-你还知道或用过-testing-t-类型和-testing-b-类型的哪些方法-它们都是做什么用的&#34;&gt;34. 除了本文中提到的，你还知道或用过&lt;code&gt;testing.T&lt;/code&gt;类型和&lt;code&gt;testing.B&lt;/code&gt;类型的哪些方法？它们都是做什么用的？&lt;/h3&gt;

&lt;p&gt;答：略。这需要你自己去做，我代替不了你。&lt;/p&gt;

&lt;h3 id=&#34;35-在编写示例测试函数的时候-我们怎样指定预期的打印内容&#34;&gt;35. 在编写示例测试函数的时候，我们怎样指定预期的打印内容？&lt;/h3&gt;

&lt;p&gt;答：这个问题的答案就在&lt;code&gt;testing&lt;/code&gt;代码包的文档中。&lt;/p&gt;

&lt;h3 id=&#34;36-benchmem-标记和-benchtime-标记的作用分别是什么&#34;&gt;36. &lt;code&gt;-benchmem&lt;/code&gt;标记和&lt;code&gt;-benchtime&lt;/code&gt;标记的作用分别是什么？&lt;/h3&gt;

&lt;p&gt;答：&lt;code&gt;-benchmem&lt;/code&gt;标记的作用是在性能测试完成后打印内存分配统计信息。&lt;code&gt;-benchtime&lt;/code&gt;标记的作用是设定测试函数的执行时间上限。&lt;/p&gt;

&lt;p&gt;具体请看这里的文档。&lt;/p&gt;

&lt;h3 id=&#34;37-怎样在测试的时候开启测试覆盖度分析-如果开启-会有什么副作用吗&#34;&gt;37. 怎样在测试的时候开启测试覆盖度分析？如果开启，会有什么副作用吗？&lt;/h3&gt;

&lt;p&gt;答：&lt;code&gt;go test&lt;/code&gt;命令可以接受&lt;code&gt;-cover&lt;/code&gt;标记。该标记的作用就是开启测试覆盖度分析。不过，由于覆盖度分析开启之后&lt;code&gt;go test&lt;/code&gt;命令可能会在程序被编译之前注释掉一部分源代码，所以，若程序编译或测试失败，那么错误报告可能会记录下与原始的源代码不对应的行号。&lt;/p&gt;

&lt;h2 id=&#34;标准库的用法&#34;&gt;标准库的用法&lt;/h2&gt;

&lt;h3 id=&#34;38-你知道互斥锁和读写锁的指针类型都实现了哪一个接口吗&#34;&gt;38. 你知道互斥锁和读写锁的指针类型都实现了哪一个接口吗？&lt;/h3&gt;

&lt;p&gt;答：它们都实现了&lt;code&gt;sync.Locker&lt;/code&gt;接口。&lt;/p&gt;

&lt;h3 id=&#34;39-怎样获取读写锁中的读锁&#34;&gt;39. 怎样获取读写锁中的读锁？&lt;/h3&gt;

&lt;p&gt;答：&lt;code&gt;sync.RWMutex&lt;/code&gt;类型有一个名为&lt;code&gt;RLocker&lt;/code&gt;的指针方法可以获取其读锁。&lt;/p&gt;

&lt;h3 id=&#34;40-sync-cond-类型的值可以被传递吗-那-sync-cond-类型的值呢&#34;&gt;40. &lt;code&gt;*sync.Cond&lt;/code&gt;类型的值可以被传递吗？那&lt;code&gt;sync.Cond&lt;/code&gt;类型的值呢？&lt;/h3&gt;

&lt;p&gt;答：&lt;code&gt;sync.Cond&lt;/code&gt;类型的值一旦被使用就不应该再被传递了，传递往往意味着拷贝。拷贝一个已经被使用的&lt;code&gt;sync.Cond&lt;/code&gt;值会引发 panic。但是它的指针值是可以被拷贝的。&lt;/p&gt;

&lt;h3 id=&#34;41-sync-cond-类型中的公开字段-l-是做什么用的-我们可以在使用条件变量的过程中改变这个字段的值吗&#34;&gt;41. &lt;code&gt;sync.Cond&lt;/code&gt;类型中的公开字段&lt;code&gt;L&lt;/code&gt;是做什么用的？我们可以在使用条件变量的过程中改变这个字段的值吗？&lt;/h3&gt;

&lt;p&gt;答：这个字段代表的是当前的&lt;code&gt;sync.Cond&lt;/code&gt;值所持有的那个锁。我们可以在使用条件变量的过程中改变该字段的值，但是在改变之前一定要搞清楚这样做的影响。&lt;/p&gt;

&lt;h3 id=&#34;42-如果要对原子值和互斥锁进行二选一-你认为最重要的三个决策条件应该是什么&#34;&gt;42. 如果要对原子值和互斥锁进行二选一，你认为最重要的三个决策条件应该是什么？&lt;/h3&gt;

&lt;p&gt;答：我觉得首先需要考虑下面几个问题。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;被保护的数据是什么类型的？是值类型的还是引用类型的？&lt;/li&gt;
&lt;li&gt;操作被保护数据的方式是怎样的？是简单的读和写还是更复杂的操作？&lt;/li&gt;
&lt;li&gt;操作被保护数据的代码是集中的还是分散的？如果是分散的，是否可以变为集中的？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在搞清楚上述问题（以及你关注的其他问题）之后，优先使用原子值。&lt;/p&gt;

&lt;h3 id=&#34;43-在使用-waitgroup-值实现一对多的-goroutine-协作流程时-怎样才能让分发子任务的-goroutine-获得各个子任务的具体执行结果&#34;&gt;43. 在使用&lt;code&gt;WaitGroup&lt;/code&gt;值实现一对多的 goroutine 协作流程时，怎样才能让分发子任务的 goroutine 获得各个子任务的具体执行结果？&lt;/h3&gt;

&lt;p&gt;答：可以考虑使用锁 + 容器（数组、切片或字典等），也可以考虑使用通道。另外，你或许也可以用上&lt;code&gt;golang.org/x/sync/errgroup&lt;/code&gt;代码包中的程序实体，相应的文档在这里。&lt;/p&gt;

&lt;h3 id=&#34;44-context-值在传达撤销信号的时候是广度优先的还是深度优先的-其优势和劣势都是什么&#34;&gt;44. &lt;code&gt;Context&lt;/code&gt;值在传达撤销信号的时候是广度优先的还是深度优先的？其优势和劣势都是什么？&lt;/h3&gt;

&lt;p&gt;答：它是深度优先的。其优势和劣势都是：直接分支的产生时间越早，其中的所有子节点就会越先接收到信号。至于什么时候是优势、什么时候是劣势还要看具体的应用场景。&lt;/p&gt;

&lt;p&gt;例如，如果子节点的存续时间与资源的消耗是正相关的，那么这可能就是一个优势。但是，如果每个分支中的子节点都很多，而且各个分支中的子节点的产生顺序并不依从于分支的产生顺序，那么这种优势就很可能会变成劣势。最终的定论还是要看测试的结果。&lt;/p&gt;

&lt;h3 id=&#34;45-怎样保证一个临时对象池中总有比较充足的临时对象&#34;&gt;45. 怎样保证一个临时对象池中总有比较充足的临时对象？&lt;/h3&gt;

&lt;p&gt;答：首先，我们应该事先向临时对象池中放入足够多的临时对象。其次，在用完临时对象之后，我们需要及时地把它归还给临时对象池。&lt;/p&gt;

&lt;p&gt;最后，我们应该保证它的&lt;code&gt;New&lt;/code&gt;字段所代表的值是可用的。虽然&lt;code&gt;New&lt;/code&gt;函数返回的临时对象并不会被放入池中，但是起码能够保证池的&lt;code&gt;Get&lt;/code&gt;方法总能返回一个临时对象。&lt;/p&gt;

&lt;h3 id=&#34;46-关于保证并发安全字典中的键和值的类型正确性-你还能想到其他的方案吗&#34;&gt;46. 关于保证并发安全字典中的键和值的类型正确性，你还能想到其他的方案吗？&lt;/h3&gt;

&lt;p&gt;答：这是一道开放的问题，需要你自己去思考。其实怎样做完全取决于你的应用场景。不过，我们应该尽量避免使用反射，因为它对程序性能还是有一定的影响的。&lt;/p&gt;

&lt;h3 id=&#34;47-判断一个-unicode-字符是否为单字节字符通常有几种方式&#34;&gt;47. 判断一个 Unicode 字符是否为单字节字符通常有几种方式？&lt;/h3&gt;

&lt;p&gt;答：&lt;code&gt;unicode/utf8&lt;/code&gt;代码包中有几个可以做此判断的函数，比如：&lt;code&gt;RuneLen&lt;/code&gt;函数、&lt;code&gt;EncodeRune&lt;/code&gt;函数等。我们需要根据输入的不同来选择和使用它们。具体可以查看该代码包的文档。&lt;/p&gt;

&lt;h3 id=&#34;48-strings-builder-和-strings-reader-都分别实现了哪些接口-这样做有什么好处吗&#34;&gt;48. &lt;code&gt;strings.Builder&lt;/code&gt;和&lt;code&gt;strings.Reader&lt;/code&gt;都分别实现了哪些接口？这样做有什么好处吗？&lt;/h3&gt;

&lt;p&gt;答：&lt;code&gt;strings.Builder&lt;/code&gt;类型实现了 3 个接口，分别是：&lt;code&gt;fmt.Stringer&lt;/code&gt;、&lt;code&gt;io.Writer&lt;/code&gt;和&lt;code&gt;io.ByteWriter&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;而&lt;code&gt;strings.Reader&lt;/code&gt;类型则实现了 8 个接口，即：&lt;code&gt;io.Reader&lt;/code&gt;、&lt;code&gt;io.ReaderAt&lt;/code&gt;、&lt;code&gt;io.ByteReader&lt;/code&gt;、&lt;code&gt;io.RuneReader&lt;/code&gt;、&lt;code&gt;io.Seeker&lt;/code&gt;、&lt;code&gt;io.ByteScanner&lt;/code&gt;、&lt;code&gt;io.RuneScanner&lt;/code&gt;和&lt;code&gt;io.WriterTo&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;好处是显而易见的。实现的接口越多，它们的用途就越广。它们会适用于那些要求参数的类型为这些接口类型的地方。&lt;/p&gt;

&lt;h3 id=&#34;49-对比-strings-builder-和-bytes-buffer-的-string-方法-并判断哪一个更高效-原因是什么&#34;&gt;49. 对比&lt;code&gt;strings.Builder&lt;/code&gt;和&lt;code&gt;bytes.Buffer&lt;/code&gt;的&lt;code&gt;String&lt;/code&gt;方法，并判断哪一个更高效？原因是什么？&lt;/h3&gt;

&lt;p&gt;答：&lt;code&gt;strings.Builder&lt;/code&gt;的&lt;code&gt;String&lt;/code&gt;方法更高效。因为该方法只对其所属值的内容容器（那个字节切片）做了简单的类型转换，并且直接使用了底层的值（或者说内存空间）。它的源码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// String returns the accumulated string.
func (b *Builder) String() string {
		return *(*string)(unsafe.Pointer(&amp;amp;b.buf))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数组值和字符串值在底层的存储方式其实是一样的。所以从切片值到字符串值的指针值的转换可以是直截了当的。又由于字符串值是不可变的，所以这样做也是安全的。&lt;/p&gt;

&lt;p&gt;不过，由于一些历史、结构和功能方面的原因，&lt;code&gt;bytes.Buffer&lt;/code&gt;的&lt;code&gt;String&lt;/code&gt;方法却不能这样做。&lt;/p&gt;

&lt;h3 id=&#34;50-io-包中的同步内存管道的运作机制是什么&#34;&gt;50. &lt;code&gt;io&lt;/code&gt;包中的同步内存管道的运作机制是什么？&lt;/h3&gt;

&lt;p&gt;答：我们实际上已经在正文中做了基本的说明。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;io.Pipe&lt;/code&gt;函数会返回一个&lt;code&gt;io.PipeReader&lt;/code&gt;类型的值和一个&lt;code&gt;io.PipeWriter&lt;/code&gt;类型的值，并将它们分别作为管道的两端。而这两个值在底层其实只是代理了同一个&lt;code&gt;*io.pipe&lt;/code&gt;类型值的功能而已。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;io.pipe&lt;/code&gt;类型通过无缓冲的通道实现了读操作与写操作之间的同步，并且通过互斥锁实现了写操作之间的串行化。另外，它还使用原子值来处理错误。这些共同保证了这个同步内存管道的并发安全性。&lt;/p&gt;

&lt;h3 id=&#34;51-bufio-scanner-类型的主要功用是什么-它有哪些特点&#34;&gt;51. &lt;code&gt;bufio.Scanner&lt;/code&gt;类型的主要功用是什么？它有哪些特点？&lt;/h3&gt;

&lt;p&gt;答：&lt;code&gt;bufio.Scanner&lt;/code&gt;类型俗称带缓存的扫描器。它的功能还是比较强大的。&lt;/p&gt;

&lt;p&gt;比如，我们可以自定义每次扫描的边界，或者说内容的分段方法。我们在调用它的&lt;code&gt;Scan&lt;/code&gt;方法对目标进行扫描之前，可以先调用其&lt;code&gt;Split&lt;/code&gt;方法并传入一个函数来自定义分段方法。&lt;/p&gt;

&lt;p&gt;在默认情况下，扫描器会以行为单位对目标内容进行扫描。&lt;code&gt;bufio&lt;/code&gt;代码包提供了一些现成的分段方法。实际上，扫描器在默认情况下会使用&lt;code&gt;bufio.ScanLines&lt;/code&gt;函数作为分段方法。&lt;/p&gt;

&lt;p&gt;又比如，我们还可以在扫描之前自定义缓存的载体和缓存的最大容量，这需要调用它的&lt;code&gt;Buffer&lt;/code&gt;方法。在默认情况下，扫描器内部设定的最大缓存容量是&lt;code&gt;64K&lt;/code&gt;个字节。&lt;/p&gt;

&lt;p&gt;换句话说，目标内容中的每一段都不能超过&lt;code&gt;64K&lt;/code&gt;个字节。否则，扫描器就会使它的&lt;code&gt;Scan&lt;/code&gt;方法返回&lt;code&gt;false&lt;/code&gt;，并通过其&lt;code&gt;Err&lt;/code&gt;方法给予我们一个表示“token too long”的错误值。这里的“token”代表的就是一段内容。&lt;/p&gt;

&lt;p&gt;关于&lt;code&gt;bufio.Scanner&lt;/code&gt;类型的更多特点和使用注意事项，你可以通过它的文档获得。&lt;/p&gt;

&lt;h3 id=&#34;52-怎样通过-os-包中的-api-创建和操纵一个系统进程&#34;&gt;52. 怎样通过&lt;code&gt;os&lt;/code&gt;包中的 API 创建和操纵一个系统进程？&lt;/h3&gt;

&lt;p&gt;答：你可以从&lt;code&gt;os&lt;/code&gt;包的&lt;code&gt;FindProcess&lt;/code&gt;函数和&lt;code&gt;StartProcess&lt;/code&gt;函数开始。前者用于通过进程 ID（pid）查找进程，后者用来基于某个程序启动一个进程。&lt;/p&gt;

&lt;p&gt;这两者都会返回一个&lt;code&gt;*os.Process&lt;/code&gt;类型的值。该类型提供了一些方法，比如，用于杀掉当前进程的&lt;code&gt;Kill&lt;/code&gt;方法，又比如，可以给当前进程发送系统信号的&lt;code&gt;Signal&lt;/code&gt;方法，以及会等待当前进程结束的&lt;code&gt;Wait&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;与此相关的还有&lt;code&gt;os.ProcAttr&lt;/code&gt;类型、&lt;code&gt;os.ProcessState&lt;/code&gt;类型、&lt;code&gt;os.Signal&lt;/code&gt;类型，等等。你可以通过积极的实践去探索更多的玩法。&lt;/p&gt;

&lt;h3 id=&#34;53-怎样在-net-conn-类型的值上正确地设定针对读操作和写操作的超时时间&#34;&gt;53. 怎样在&lt;code&gt;net.Conn&lt;/code&gt;类型的值上正确地设定针对读操作和写操作的超时时间？&lt;/h3&gt;

&lt;p&gt;答：&lt;code&gt;net.Conn&lt;/code&gt;类型有 3 个可用于设置超时时间的方法，分别是：&lt;code&gt;SetDeadline&lt;/code&gt;、&lt;code&gt;SetReadDeadline&lt;/code&gt;和&lt;code&gt;SetWriteDeadline&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这三个方法的签名是一模一样的，只是名称不同罢了。它们都接受一个&lt;code&gt;time.Time&lt;/code&gt;类型的参数，并都会返回一个&lt;code&gt;error&lt;/code&gt;类型的结果。其中的&lt;code&gt;SetDeadline&lt;/code&gt;方法是用来同时设置读操作超时和写操作超时的。&lt;/p&gt;

&lt;p&gt;有一点需要特别注意，这三个方法都会针对任何正在进行以及未来将要进行的相应操作进行超时设定。&lt;/p&gt;

&lt;p&gt;因此，如果你要在一个循环中进行读操作或写操作的话，最好在每次迭代中都进行一次超时设定。&lt;/p&gt;

&lt;p&gt;否则，靠后的操作就有可能因触达超时时间而直接失败。另外，如果有必要，你应该再次调用它们并传入&lt;code&gt;time.Time&lt;/code&gt;类型的零值来表达不再限定超时时间。&lt;/p&gt;

&lt;h3 id=&#34;54-怎样优雅地停止基于-http-协议的网络服务程序&#34;&gt;54. 怎样优雅地停止基于 HTTP 协议的网络服务程序？&lt;/h3&gt;

&lt;p&gt;答：&lt;code&gt;net/http.Server&lt;/code&gt;类型有一个名为&lt;code&gt;Shutdown&lt;/code&gt;的指针方法可以实现“优雅的停止”。也就是说，它可以在不中断任何正处在活动状态的连接的情况下平滑地关闭当前的服务器。&lt;/p&gt;

&lt;p&gt;它会先关闭所有的空闲连接，并一直等待。只有活动的连接变为空闲之后，它才会关闭它们。当所有的连接都被平滑地关闭之后，它会关闭当前的服务器并返回。当有错误发生时，它还会把相应的错误值返回。&lt;/p&gt;

&lt;p&gt;另外，你还可以通过调用&lt;code&gt;Server&lt;/code&gt;值的&lt;code&gt;RegisterOnShutdown&lt;/code&gt;方法来注册可以在服务器即将关闭时被自动调用的函数。&lt;/p&gt;

&lt;p&gt;更确切地说，当前服务器的&lt;code&gt;Shutdown&lt;/code&gt;方法会以异步的方式调用如此注册的所有函数。我们可以利用这样的函数来通知长连接的客户端“连接即将关闭”。&lt;/p&gt;

&lt;h3 id=&#34;55-runtime-trace-代码包的功用是什么&#34;&gt;55. &lt;code&gt;runtime/trace&lt;/code&gt;代码包的功用是什么？&lt;/h3&gt;

&lt;p&gt;答：简单来说，这个代码包是用来帮助 Go 程序实现内部跟踪操作的。其中的程序实体可以帮助我们记录程序中各个 goroutine 的状态、各种系统调用的状态，与 GC 有关的各种事件，以及内存相关和 CPU 相关的变化，等等。&lt;/p&gt;

&lt;p&gt;通过它们生成的跟踪记录可以通过&lt;code&gt;go tool trace&lt;/code&gt;命令来查看。更具体的说明可以参看&lt;code&gt;runtime/trace&lt;/code&gt;代码包的文档。&lt;/p&gt;

&lt;p&gt;有了&lt;code&gt;runtime/trace&lt;/code&gt;代码包，我们就可以为 Go 程序加装上可以满足个性化需求的跟踪器了。Go 语言标准库中有的代码包正是通过使用该包实现了自身的功能，例如&lt;code&gt;net/http/pprof&lt;/code&gt;包。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go语言中文网面试题 91-120</title>
      <link>/go/interview/91-120/</link>
      <pubDate>Tue, 28 Jul 2020 00:30:03 +0800</pubDate>
      <guid>/go/interview/91-120/</guid>
      <description>

&lt;h2 id=&#34;day-91-init-类型&#34;&gt;Day 91.  init, 类型&lt;/h2&gt;

&lt;p&gt;1.下面两段代码能否编译通过？请简要说明。&lt;/p&gt;

&lt;p&gt;第一段：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func f() {}
func f() {}

func main() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二段：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func init(){}
func init(){}

func main() {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：第二段代码能通过编译。除 init() 函数之外，一个包内不允许有其他同名函数。&lt;/p&gt;

&lt;p&gt;2.下面代码有什么问题？请指出。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (m map[string]string) Set(key string, value string) {
    m[key] = value
}

func main() {
    m := make(map[string]string)
    m.Set(&amp;quot;A&amp;quot;, &amp;quot;One&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：Unnamed Type 不能作为方法的接收者。昨天我们讲过 Named Type 与 Unamed Type 的区别，就用 Named Type 来修复下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type User map[string]string
 
func (m User) Set(key string, value string) {
     m[key] = value
}
 
func main() {
    m := make(User)
    m.Set(&amp;quot;A&amp;quot;, &amp;quot;One&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-92-init-copy&#34;&gt;Day 92. init ,copy&lt;/h2&gt;

&lt;p&gt;1.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var x int

func init() {
    x++
}

func main() {
    init()
    fmt.Println(x)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：编译失败。init() 函数不能被其他函数调用，包括 main() 函数。&lt;/p&gt;

&lt;p&gt;2.min() 函数是求两个数之间的较小值，能否在 该函数中添加一行代码将其功能补全。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func min(a int, b uint) {
    var min = 0
    fmt.Printf(&amp;quot;The min of %d and %d is %d\n&amp;quot;, a, b, min)
}

func main() {
    min(1225, 256)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案即解析：利用 copy() 函数的功能：切片复制，并且返回两者长度的较小值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func min(a int, b uint) {
    var min = 0
    min = copy(make([]struct{},a),make([]struct{},b))
    fmt.Printf(&amp;quot;The min of %d and %d is %d\n&amp;quot;, a, b, min)
}

func main() {
    min(1225, 256)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-93-main-类型&#34;&gt;Day 93. main, 类型&lt;/h2&gt;

&lt;p&gt;1.关于 main() 函数，下面说法正确的是？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不能带参数；&lt;/li&gt;
&lt;li&gt;不能定义返回值；&lt;/li&gt;
&lt;li&gt;所在的包必须为 main 包；&lt;/li&gt;
&lt;li&gt;可以使用 flag 包来获取和解析命令行参数；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：ABCD。&lt;/p&gt;

&lt;p&gt;2.下面代码能编译通过吗？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type User struct {
    Name string
}

func (u *User) SetName(name string) {
    u.Name = name
    fmt.Println(u.Name)
}

type Employee User

func main() {
    employee := new(Employee)
    employee.SetName(&amp;quot;Jack&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：编译不通过。当使用 type 声明一个新类型，它不会继承原有类型的方法集。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-94-default&#34;&gt;Day 94. ^, default&lt;/h2&gt;

&lt;p&gt;1.下面这段代码输出什么？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    a := 2 ^ 15
    b := 4 ^ 15
    if a &amp;gt; b {
        println(&amp;quot;a&amp;quot;)
    } else {
        println(&amp;quot;b&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：a。Go 语言里面 ^ 表示按位异或，而不是求幂。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;0010 ^ 1111 == 1101   (2^15 == 13)
0100 ^ 1111 == 1011   (4^15 == 11)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.下面哪些函数不能通过编译？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func A(string string) string {
    return string + string
}

func B(len int) int {
    return len + len
}
 
func C(val, default string) string {
   if val == &amp;quot;&amp;quot; {
        return default
    }
    return val
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：C() 函数不能通过编译。C() 函数的 default 属于关键字。string 和 len 是预定义标识符，可以在局部使用。nil 也可以当做变量使用，不过不建议写这样的代码，可读性不好，小心被接手你代码的人胖揍。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var nil = new(int)
 
func main() {
     var p *int
    if p == nil {
        fmt.Println(&amp;quot;p is nil&amp;quot;)
    } else {
        fmt.Println(&amp;quot;p is not nil&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-95-select&#34;&gt;Day 95. select&lt;/h2&gt;

&lt;p&gt;1.下面代码输出什么？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type foo struct{ Val int }

type bar struct{ Val int }

func main() {
    a := &amp;amp;foo{Val: 5}
    b := &amp;amp;foo{Val: 5}
    c := foo{Val: 5}
    d := bar{Val: 5}
    e := bar{Val: 5}
    f := bar{Val: 5}
    fmt.Print(a == b, c == foo(d), e == f)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：false true true。这道题唯一有疑问的地方就在第一个比较，Go 语言里没有引用变量，每个变量都占用一个惟一的内存位置，所以第一个比较输出 false。这个知识点在《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648467113&amp;amp;idx=2&amp;amp;sn=dae5e4d1a0c3c5b48eb01aa4c5587809&amp;amp;chksm=f24740c6c530c9d0a65bc0a0e2c39f82df88109e6c37c6afd0b8101d3f86330c69e106e4228f&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;Go 语言没有引用传递&lt;/a&gt;》有介绍。&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func A() int {
    time.Sleep(100 * time.Millisecond)
    return 1
}

func B() int {
    time.Sleep(1000 * time.Millisecond)
    return 2
}

func main() {
   ch := make(chan int, 1)
    go func() {
        select {
        case ch &amp;lt;- A():
        case ch &amp;lt;- B():
        default:
             ch &amp;lt;- 3
        }
    }()
    fmt.Println(&amp;lt;-ch)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：1、2随机输出。关于 select 的使用可以查看《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466739&amp;amp;idx=1&amp;amp;sn=bfff10a9eed52a13fb2adb63569b0bca&amp;amp;chksm=f247435cc530ca4ac2eaad9c3879331ec5507f6452e901eb046f7ec46e703a678541e1fa1840&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;Go 并发 &amp;ndash; Select&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-96-for-range-切片&#34;&gt;Day 96. for range,切片&lt;/h2&gt;

&lt;p&gt;1.下面的代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Point struct{ x, y int }

func main() {
    s := []Point{
        {1, 2},
        {3, 4},
    }
    for _, p := range s {
        p.x, p.y = p.y, p.x
    }
    fmt.Println(s)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：输出 [{1 2} {3 4}]。知识点：for range 循环。range 循环的时候，获取到的元素值是副本，就比如这里的 p。修复代码示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Point struct{ x, y int }

func main() {
    s := []*Point{
        &amp;amp;Point{1, 2},
        &amp;amp;Point{3, 4},
     }
    for _, p := range s {
        p.x, p.y = p.y, p.x
    }
    fmt.Println(*s[0])
    fmt.Println(*s[1])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.下面的代码有什么隐患？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func get() []byte {
    raw := make([]byte, 10000)
    fmt.Println(len(raw), cap(raw), &amp;amp;raw[0])
    return raw[:3]
}

func main() {
    data := get()
    fmt.Println(len(data), cap(data), &amp;amp;data[0])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：get() 函数返回的切片与原切片公用底层数组，如果在调用函数里面（这里是 main() 函数）修改返回的切片，将会影响到原切片。为了避免掉入陷阱，可以如下修改：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func get() []byte {
    raw := make([]byte, 10000)
    fmt.Println(len(raw), cap(raw), &amp;amp;raw[0])
    res := make([]byte, 3)
    copy(res, raw[:3])
    return res
}

func main() {
    data := get()
    fmt.Println(len(data), cap(data), &amp;amp;data[0])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-97-map-参数传递&#34;&gt;Day 97. map,参数传递&lt;/h2&gt;

&lt;p&gt;1.关于map，下面说法正确的是？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. map 反序列化时 json.unmarshal() 的入参必须为map的地址；&lt;/li&gt;
&lt;li&gt;B. 在函数调用中传递 map，则子函数中对 map 元素的增加不会导致父函数中 map 的修改；&lt;/li&gt;
&lt;li&gt;C. 在函数调用中传递 map，则子函数中对 map 元素的修改不会导致父函数中 map 的修改；&lt;/li&gt;
&lt;li&gt;D. 不能使用内置函数 delete() 删除 map 的元素；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：A。知识点：map 的使用。可以查看《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466739&amp;amp;idx=2&amp;amp;sn=44a35b80cd64b30305a08050629696b2&amp;amp;chksm=f247435cc530ca4a847567150a029a08346614356bb70c27d27f8bd54136b1c8466403af82bb&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;Go Map&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Foo struct {
    val int
}

func (f Foo) Inc(inc int) {
    f.val += inc
}

 func main() {
    var f Foo
    f.Inc(100)
    fmt.Println(f.val)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：输出 0。使用值类型接收者定义的方法，调用的时候，使用的是值的副本，对副本操作不会影响的原来的值。如果想要在调用函数中修改原值，可以使用指针接收者定义的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt; type Foo struct {
    val int
}

func (f *Foo) Inc(inc int) {
    f.val += inc
}

func main() {
    f := &amp;amp;Foo{}
    f.Inc(100)
     fmt.Println(f.val)  // 100
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-98-变量的作用域&#34;&gt;Day 98. 变量的作用域&lt;/h2&gt;

&lt;p&gt;1.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    a := 1
    for i := 0;i&amp;lt;5;i++ {
        a := a + 1
        a = a * 2
    }
    fmt.Println(a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：1。知识点：变量的作用域。注意 for 语句的变量 a 是重新声明，它的作用范围只在 for 语句范围内。&lt;/p&gt;

&lt;p&gt;2.下面的代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test(i int) (ret int) {
    ret = i * 2
    if ret &amp;gt; 10 {
        ret := 10
        return
    }
    return
}

func main() {
    result := test(10)
    fmt.Println(result)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案即解析：编译错误。知识点：变量的作用域。编译错误信息：ret is shadowed during return。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-99-变量作用域-defer&#34;&gt;Day 99. 变量作用域,defer&lt;/h2&gt;

&lt;p&gt;1.下面代码能编译通过吗？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    true := false
    fmt.Println(true)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案即解析：编译通过。true 是预定义标识符可以用作变量名，但是不建议这么做。&lt;/p&gt;

&lt;p&gt;2.下面的代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func watShadowDefer(i int) (ret int) {
    ret = i * 2
    if ret &amp;gt; 10 {
        ret := 10
        defer func() {
            ret = ret + 1
        }()
   }
    return
}

func main() {
    result := watShadowDefer(50)
    fmt.Println(result)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案即解析：100。知识点：变量作用域和defer 返回值。可以查看文章《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466918&amp;amp;idx=2&amp;amp;sn=151a8135f22563b7b97bf01ff480497b&amp;amp;chksm=f2474389c530ca9f3dc2ae1124e4e5ed3db4c45096924265bccfcb8908a829b9207b0dd26047&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;5 年 Gopher 都不知道的 defer 细节，你别再掉进坑里！&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-100-读写锁-map&#34;&gt;Day 100. 读写锁,map&lt;/h2&gt;

&lt;p&gt;1.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
     m := map[string]int{
        &amp;quot;G&amp;quot;: 7, &amp;quot;A&amp;quot;: 1,
        &amp;quot;C&amp;quot;: 3, &amp;quot;E&amp;quot;: 5,
        &amp;quot;D&amp;quot;: 4, &amp;quot;B&amp;quot;: 2,
        &amp;quot;F&amp;quot;: 6, &amp;quot;I&amp;quot;: 9,
        &amp;quot;H&amp;quot;: 8,
    }
    var order []string
    for k, _ := range m {
        order = append(order, k)
    }
    fmt.Println(order)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案即解析：按字母无序输出。知识点：遍历 map 是无序的。&lt;/p&gt;

&lt;p&gt;2.下面的代码有什么问题？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type UserAges struct {
    ages map[string]int
    sync.Mutex
}

func (ua *UserAges) Add(name string, age int) {
   ua.Lock()
    defer ua.Unlock()
    ua.ages[name] = age
}

func (ua *UserAges) Get(name string) int {
    if age, ok := ua.ages[name]; ok {
        return age
    }
    return -1
}

func main() {
    count := 1000
    gw := sync.WaitGroup{}
    gw.Add(count * 3)
    u := UserAges{ages: map[string]int{}}
    add := func(i int) {
        u.Add(fmt.Sprintf(&amp;quot;user_%d&amp;quot;, i), i)
        gw.Done()
    }
    for i := 0; i &amp;lt; count; i++ {
        go add(i)
        go add(i)
    }
    for i := 0; i &amp;lt; count; i++ {
        go func(i int) {
            defer gw.Done()
            u.Get(fmt.Sprintf(&amp;quot;user_%d&amp;quot;, i))
        }(i)
    }
    gw.Wait()
    fmt.Println(&amp;quot;Done&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案即解析：在执行 Get() 方法时可能报错。知识点：读写锁。虽然可以使用 sync.Mutex 做写锁，但是 map 是并发读写不安全的。map 属于引用类型，并发读写时多个协程是通过指针访问同一个地址，即访问共享变量，此时同时读写资源存在竞争关系，会报错 “fatal error: concurrent map read and map write”。&lt;/p&gt;

&lt;p&gt;有兴趣的同学可以尝试用 sync.RWMutex（读写锁）改进下程序。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-101-循环-select&#34;&gt;Day 101. 循环,select&lt;/h2&gt;

&lt;p&gt;1.关于循环语句，下面说法正确的有？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. 循环语句既支持 for 关键字，也支持 while 和 do-while；&lt;/li&gt;
&lt;li&gt;B. 关键字for的基本使用方法与C/C++中没有任何差异；&lt;/li&gt;
&lt;li&gt;C. for 循环支持 continue 和 break 来控制循环，但是它提供了一个更高级的 break，可以选择中断哪一个循环；&lt;/li&gt;
&lt;li&gt;D. for 循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：CD。&lt;/p&gt;

&lt;p&gt;2.下面代码的功能是从小到大找出 17 和 38 的 3 个公倍数，请问下面的代码有什么问题？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var ch chan int = make(chan int)

func generate() {
    for i := 17; i &amp;lt; 5000; i += 17 {
        ch &amp;lt;- i
        time.Sleep(1 * time.Millisecond)
    }
    close(ch)
}

func main() {
    timeout := time.After(800 * time.Millisecond)
    go generate()
    found := 0
    for {
        select {
        case i, ok := &amp;lt;-ch:
            if ok {
                if i%38 == 0 {
                    fmt.Println(i, &amp;quot;is a multiple of 17 and 38&amp;quot;)
                    found++
                    if found == 3 {
                        break
                    }
                }
            } else {
                break
            }
        case &amp;lt;-timeout:
            fmt.Println(&amp;quot;timed out&amp;quot;)
            break
        }
    }
    fmt.Println(&amp;quot;The end&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案即解析：break 会跳出 select 块，但不会跳出 for 循环。这算是一个比较容易掉的坑。可以使用 break label 特性或者 goto 功能解决这个问题，这里使用 break label 作个示例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var ch chan int = make(chan int)

func generate() {
    for i := 17; i &amp;lt; 5000; i += 17 {
        ch &amp;lt;- i
        time.Sleep(1 * time.Millisecond)
    }
    close(ch)
}

func main() {
    timeout := time.After(800 * time.Millisecond)
    go generate()
    found := 0
    MAIN_LOOP:
    for {
        select {
        case i, ok := &amp;lt;-ch:
            if ok {
                if i%38 == 0 {
                    fmt.Println(i, &amp;quot;is a multiple of 17 and 38&amp;quot;)
                    found++
                   if found == 3 {
                        break MAIN_LOOP
                    }
                }
            } else {
                break MAIN_LOOP
            }
        case &amp;lt;-timeout:
            fmt.Println(&amp;quot;timed out&amp;quot;)
            break MAIN_LOOP
       }
    }
    fmt.Println(&amp;quot;The end&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-102-channel-锁&#34;&gt;Day 102. channel, 锁&lt;/h2&gt;

&lt;p&gt;1.ch := make(chan interface{}) 和 ch := make(chan interface{},1) 有什么区别？&lt;/p&gt;

&lt;p&gt;参考答案及解析：第一个是声明无缓存通道，第二个是声明缓存为 1 的通道。无缓存通道需要一直有接收者接收数据，写操作才会继续，不然会一直阻塞；而缓冲为 1 则即使没有接收者也不会阻塞，因为缓冲大小是 1 ，只有当放第二个值的时候，第一个还没被人拿走，这时候才会阻塞。注意这两者还是有区别的。&lt;/p&gt;

&lt;p&gt;2.下面的代码输出什么？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var mu sync.Mutex
var chain string

func main() {
    chain = &amp;quot;main&amp;quot;
    A()
    fmt.Println(chain)
}
func A() {
    mu.Lock()
    defer mu.Unlock()
    chain = chain + &amp;quot; --&amp;gt; A&amp;quot;
    B()
}

func B() {
    chain = chain + &amp;quot; --&amp;gt; B&amp;quot;
    C()
}

func C() {
    mu.Lock()
    defer mu.Unlock()
    chain = chain + &amp;quot; --&amp;gt; C&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 不能编译；&lt;/li&gt;
&lt;li&gt;B. 输出 main &amp;ndash;&amp;gt; A &amp;ndash;&amp;gt; B &amp;ndash;&amp;gt; C；&lt;/li&gt;
&lt;li&gt;C. 输出 main；&lt;/li&gt;
&lt;li&gt;D. fatal error；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案即解析：D。使用 Lock() 加锁后，不能再继续对其加锁，直到利用 Unlock() 解锁后才能再加锁。&lt;/p&gt;

&lt;p&gt;引自博客《鸟窝》 &lt;a href=&#34;https://colobu.com/&#34; target=&#34;_blank&#34;&gt;https://colobu.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-103-锁-defer&#34;&gt;Day 103. 锁,defer&lt;/h2&gt;

&lt;p&gt;1.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    fmt.Println(doubleScore(0))    
    fmt.Println(doubleScore(20.0)) 
    fmt.Println(doubleScore(50.0)) 
}
func doubleScore(source float32) (score float32) {
    defer func() {
        if score &amp;lt; 1 || score &amp;gt;= 100 {
            score = source
       }
    }()
    return source * 2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：输出 0 40 50。知识点：defer 语句与返回值。函数的 return value 不是原子操作，而是在编译器中分解为两部分：返回值赋值 和 return。可以细看《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466918&amp;amp;idx=2&amp;amp;sn=151a8135f22563b7b97bf01ff480497b&amp;amp;chksm=f2474389c530ca9f3dc2ae1124e4e5ed3db4c45096924265bccfcb8908a829b9207b0dd26047&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;5 年 Gopher 都不知道的 defer 细节，你别再掉进坑里！&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var mu sync.RWMutex
var count int

func main() {
    go A()
    time.Sleep(2 * time.Second)
    mu.Lock()
    defer mu.Unlock()
    count++
    fmt.Println(count)
}
func A() {
    mu.RLock()
    defer mu.RUnlock()
    B()
}
func B() {
    time.Sleep(5 * time.Second)
    C()
}
func C() {
    mu.RLock()
    defer mu.RUnlock()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 不能编译；&lt;/li&gt;
&lt;li&gt;B. 输出 1；&lt;/li&gt;
&lt;li&gt;C. 程序 hang 住；&lt;/li&gt;
&lt;li&gt;D. fatal error；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：D。当写锁阻塞时，新的读锁是无法申请的（有效防止写锁饥饿），导致死锁。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-104-waitgroup&#34;&gt;Day 104. WaitGroup&lt;/h2&gt;

&lt;p&gt;1.关于同步锁，下面说法正确的是？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. 当一个 goroutine 获得了 Mutex 后，其他 goroutine 就只能乖乖的等待，除非该 goroutine 释放这个 Mutex；&lt;/li&gt;
&lt;li&gt;B. RWMutex 在读锁占用的情况下，会阻止写，但不阻止读；&lt;/li&gt;
&lt;li&gt;C. RWMutex 在写锁占用情况下，会阻止任何其他 goroutine（无论读和写）进来，整个锁相当于由该 goroutine 独占；&lt;/li&gt;
&lt;li&gt;D. Lock() 操作需要保证有 Unlock() 或 RUnlock() 调用与之对应；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：ABC。&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt; func main() {
     var wg sync.WaitGroup
     wg.Add(1)
     go func() {
         time.Sleep(time.Millisecond)
         wg.Done()
         wg.Add(1)
     }()
     wg.Wait()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 不能编译；&lt;/li&gt;
&lt;li&gt;B. 无输出，正常退出；&lt;/li&gt;
&lt;li&gt;C. 程序 hang 住；&lt;/li&gt;
&lt;li&gt;D. panic；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：D。WaitGroup 在调用 Wait() 之后不能再调用 Add() 方法的。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-105-channel-锁&#34;&gt;Day 105. channel,锁&lt;/h2&gt;

&lt;p&gt;1.下面代码输出什么？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var c = make(chan int)
var a int

func f() {
    a = 1
    &amp;lt;-c
}
func main() {
    go f()
    c &amp;lt;- 0
    print(a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 不能编译；&lt;/li&gt;
&lt;li&gt;B. 输出 1；&lt;/li&gt;
&lt;li&gt;C. 输出 0；&lt;/li&gt;
&lt;li&gt;D. panic；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：B。能正确输出，不过主协程会阻塞 f() 函数的执行。&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type MyMutex struct {
    count int
    sync.Mutex
}

func main() {
    var mu MyMutex
    mu.Lock()
    var mu1 = mu
    mu.count++
    mu.Unlock()
    mu1.Lock()
   mu1.count++
    mu1.Unlock()
    fmt.Println(mu.count, mu1.count)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 不能编译；&lt;/li&gt;
&lt;li&gt;B. 输出 1, 1；&lt;/li&gt;
&lt;li&gt;C. 输出 1, 2；&lt;/li&gt;
&lt;li&gt;D. fatal error；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：D。加锁后复制变量，会将锁的状态也复制，所以 mu1 其实是已经加锁状态，再加锁会死锁。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-106-goroutines&#34;&gt;Day 106.  goroutines&lt;/h2&gt;

&lt;p&gt;1.下面代码输出什么？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var ch chan int
    var count int
    go func() {
        ch &amp;lt;- 1
    }()
    go func() {
        count++
        close(ch)
    }()
    &amp;lt;-ch
    fmt.Println(count)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 不能编译；&lt;/li&gt;
&lt;li&gt;B. 输出 1；&lt;/li&gt;
&lt;li&gt;C. 输出 0；&lt;/li&gt;
&lt;li&gt;D. panic；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：D。ch 未被初始化，关闭时会报错。&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var ch chan int
    go func() {
        ch = make(chan int, 1)
        ch &amp;lt;- 1
    }()
    go func(ch chan int) {
        time.Sleep(time.Second)
        &amp;lt;-ch
    }(ch)

    c := time.Tick(1 * time.Second)
    for range c {
        fmt.Printf(&amp;quot;#goroutines: %d\n&amp;quot;, runtime.NumGoroutine())
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 不能编译；&lt;/li&gt;
&lt;li&gt;B. 一段时间后总是输出 #goroutines: 1；&lt;/li&gt;
&lt;li&gt;C. 一段时间后总是输出 #goroutines: 2；&lt;/li&gt;
&lt;li&gt;D. panic；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案即解析：C。程序执行到第二个 groutine 时，ch 还未初始化，导致第二个 goroutine 阻塞。需要注意的是第一个 goroutine 不会阻塞。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-107-append-sync-map&#34;&gt;Day 107. append,sync.Map&lt;/h2&gt;

&lt;p&gt;1.下面代码输出什么？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var m sync.Map
    m.LoadOrStore(&amp;quot;a&amp;quot;, 1)
    m.Delete(&amp;quot;a&amp;quot;)
    fmt.Println(m.Len())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 不能编译；&lt;/li&gt;
&lt;li&gt;B. 输出 1；&lt;/li&gt;
&lt;li&gt;C. 输出 0；&lt;/li&gt;
&lt;li&gt;D. panic；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：D。sync.Map 没有 Len() 方法。&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var wg sync.WaitGroup
    wg.Add(2)
    var ints = make([]int, 0, 1000)
    go func() {
        for i := 0; i &amp;lt; 1000; i++ {
            ints = append(ints, i)
        }
        wg.Done()
    }()
    go func() {
        for i := 0; i &amp;lt; 1000; i++ {
            ints = append(ints, i)
        }
        wg.Done()
    }()
    wg.Wait()
    fmt.Println(len(ints))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 不能编译；&lt;/li&gt;
&lt;li&gt;B. 输出 2000；&lt;/li&gt;
&lt;li&gt;C. 输出可能不是 2000；&lt;/li&gt;
&lt;li&gt;D. panic；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：C。append() 并不是并发安全的，有兴趣的同学可以尝试用锁去解决这个问题。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-108-私有-flag&#34;&gt;Day 108. 私有,flag&lt;/h2&gt;

&lt;p&gt;1.下面的代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type People struct {
    name string `json:&amp;quot;name&amp;quot;`
}
 
 func main() {
     js := `{
         &amp;quot;name&amp;quot;:&amp;quot;11&amp;quot;
     }`
    var p People
    err := json.Unmarshal([]byte(js), &amp;amp;p)
    if err != nil {
        fmt.Println(&amp;quot;err: &amp;quot;, err)
        return
    }
    fmt.Println(&amp;quot;people: &amp;quot;, p)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：people:{}。按照 go 的语法，小写开头的方法、属性或 struct 是私有的，同样，在 json 解码或转码的时候也无法实现私有属性的转换。&lt;/p&gt;

&lt;p&gt;这段代码是无法正常得到 People 的 name 值的。而且，私有属性 name 也不应该加 json 的标签。&lt;/p&gt;

&lt;p&gt;2.补充 A、B 两处代码，实现程序能解析 ip 和 prot 参数，默认值是  0.0.0.0 和 8000。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var ip string
var port int

func init() {
    // A
    // B
}

func main() {
    flag.Parse()
    fmt.Printf(&amp;quot;%s:%d&amp;quot;, ip, port)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：flag 包的使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var ip string
var port int

func init() {
    flag.StringVar(&amp;amp;ip, &amp;quot;ip&amp;quot;, &amp;quot;0.0.0.0&amp;quot;, &amp;quot;ip address&amp;quot;)
    flag.IntVar(&amp;amp;port, &amp;quot;port&amp;quot;, 8000, &amp;quot;port number&amp;quot;)
}

func main() {
    flag.Parse()
    fmt.Printf(&amp;quot;%s:%d&amp;quot;, ip, port)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-109-sort-go&#34;&gt;Day 109. sort, go&lt;/h2&gt;

&lt;p&gt;1.下面代码有什么问题？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    ch := make(chan int, 1000)
    go func() {
        for i := 0; i &amp;lt; 10; i++ {
            ch &amp;lt;- i
        }
   }()
     go func() {
         for {
            a, ok := &amp;lt;-ch
            if !ok {
               fmt.Println(&amp;quot;close&amp;quot;)
                return
            }
            fmt.Println(&amp;quot;a: &amp;quot;, a)
        }
    }()
    close(ch)
    fmt.Println(&amp;quot;ok&amp;quot;)
    time.Sleep(time.Second * 20)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：panic。协程开启还未来得及执行，chan 就已经 close() ，往已经关闭的 chan 写数据会 panic。&lt;/p&gt;

&lt;p&gt;2.在 A 处添加一行代码实现 S 按升序排列。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type S struct {
    v int
}

func main() {
    s := []S{{1}, {3}, {5}, {2}}
    // A
    fmt.Printf(&amp;quot;%#v&amp;quot;, s)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：可以考虑使用 sort.Slice()。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type S struct {
    v int
}

func main() {
    s := []S{{1}, {3}, {5}, {2}}
    sort.Slice(s, func(i, j int) bool { return s[i].v &amp;lt; s[j].v })
    fmt.Printf(&amp;quot;%#v&amp;quot;, s)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-110-for-range-waitgroup&#34;&gt;Day 110.  for range,WaitGroup&lt;/h2&gt;

&lt;p&gt;1.下面代码输出什么？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type T struct {
    V int
}

func (t *T) Incr(wg *sync.WaitGroup) {
    t.V++
    wg.Done()
}
func (t *T) Print() {
    time.Sleep(1)
    fmt.Print(t.V)
}
func main() {
    var wg sync.WaitGroup
    wg.Add(10)
    var ts = make([]T, 10)
    for i := 0; i &amp;lt; 10; i++ {
        ts[i] = T{i}
    }
    for _, t := range ts {
        go t.Incr(&amp;amp;wg)
    }
    wg.Wait()
    for _, t := range ts {
        go t.Print()
    }
    time.Sleep(5 * time.Second)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 输出 12345678910；&lt;/li&gt;
&lt;li&gt;B. 输出 0123456789；&lt;/li&gt;
&lt;li&gt;C. 输出 9999999999；&lt;/li&gt;
&lt;li&gt;D. panic；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：C。这道题需要注意的一点是 for range 循环里的变量 t 是临时变量。&lt;/p&gt;

&lt;p&gt;2.下面的代码可以随机输出大小写字母，尝试在 A 处添加一行代码使得字母先按大写再按小写的顺序输出。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const N = 26

func main() {
    const GOMAXPROCS = 1
    runtime.GOMAXPROCS(GOMAXPROCS)

    var wg sync.WaitGroup
    wg.Add(2 * N)
    for i := 0; i &amp;lt; N; i++ {
        go func(i int) {
            defer wg.Done()
            // A
            runtime.Gosched()
            fmt.Printf(&amp;quot;%c&amp;quot;, &#39;a&#39;+i)
        }(i)
        go func(i int) {
            defer wg.Done()
            fmt.Printf(&amp;quot;%c&amp;quot;, &#39;A&#39;+i)
        }(i)
    }
    wg.Wait()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const N = 26

func main() {
    const GOMAXPROCS = 1
    runtime.GOMAXPROCS(GOMAXPROCS)

    var wg sync.WaitGroup
    wg.Add(2 * N)
    for i := 0; i &amp;lt; N; i++ {
        go func(i int) {
            defer wg.Done()
            runtime.Gosched()
            fmt.Printf(&amp;quot;%c&amp;quot;, &#39;a&#39;+i)
        }(i)
        go func(i int) {
            defer wg.Done()
            fmt.Printf(&amp;quot;%c&amp;quot;, &#39;A&#39;+i)
        }(i)
    }
    wg.Wait()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-111-栈增长-逃逸分析&#34;&gt;Day 111. 栈增长、逃逸分析&lt;/h2&gt;

&lt;p&gt;1.下面两处打印的值是否相同？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var val int
    println(&amp;amp;val)
    f(10000)
    println(&amp;amp;val)
}

func f(i int) {
    if i--; i == 0 {
        return
    }
    f(i)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：不同。知识点：栈增长、逃逸分析。每个 groutine 都会分配相应的栈内存，比如 Go 1.11 版本是 2Kb，随着程序运行，栈内存会发生增长或缩小，协程会重新申请栈内存块。就像这个题目，循环调用 f()，发生深度递归，栈内存不断增大，当超过范围时，会重新申请栈内存，所以 val 的地址会变化。&lt;/p&gt;

&lt;p&gt;这道题还有个特别注意的地方，如果将 println() 函数换成 fmt.Println() 会发现，打印结果相同。为什么？因为函数 fmt.Println() 使变量 val 发生了逃逸，逃逸到堆内存，即使协程栈内存重新申请，val 变量在堆内存的地址也不会改变。&lt;/p&gt;

&lt;p&gt;2.下面代码 A 处输出什么？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var val int

    a := &amp;amp;val
    println(a)

    f(10000)

    b := &amp;amp;val
    println(b)

    println(a == b)  // A
}

func f(i int) {
    if i--; i == 0 {
        return
    }
    f(i)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. ture&lt;/li&gt;
&lt;li&gt;B. false&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：A。这道题和上一道有一定联系，a 是指向变量 val 的指针，我们知道 val 变量的地址发生了改变，a 指向 val 新的地址是由内存管理自动实现的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var val int

    a := &amp;amp;val
    println(a)

    f(10000)
 
    b := &amp;amp;val
    println(a)   // a b 的值相同
    println(b)

    println(a == b) // A
}

func f(i int) {
    if i--; i == 0 {
        return
    }
    f(i)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-112-切片&#34;&gt;Day 112. 切片&lt;/h2&gt;

&lt;p&gt;1.下面代码输出什么？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    x := []int{100, 200, 300, 400, 500, 600, 700}
    twohundred := &amp;amp;x[1]
    x = append(x, 800)
    for i := range x {
        x[i]++
    }
    fmt.Println(*twohundred)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：200。因为原切片的容量已经满了，执行 append 操作之后会创建一个新的底层数组，并将原切片底层数组的值拷贝到新的数组，原数组保持不变。参考《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466739&amp;amp;idx=3&amp;amp;sn=9a1c9599172a532297ef41238450f9af&amp;amp;chksm=f247435cc530ca4ac6d92bd22011b52ae34d25d6e0eddf5b2ba85a15d3846b6674aa8bcf1d07&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;非懂不可的Slice（一）&lt;/a&gt;》。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {

    x := make([]int, 0, 7)
    x = append(x, 100, 200, 300, 400, 500, 600, 700)
    twohundred := &amp;amp;x[1]
    x = append(x, 800)
    for i := range x {
        x[i]++
    }
   fmt.Println(*twohundred)    // 输出 200

    x = make([]int, 0, 8)   // 指向另一个切片
    x = append(x, 100, 200, 300, 400, 500, 600, 700)
    twohundred = &amp;amp;x[1]
    x = append(x, 800)  // 执行 append 操作，容量足够，不会重新申请内存
    for i := range x {
        x[i]++
    }
    fmt.Println(*twohundred)  // 输出 201
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.下面的代码输出什么？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    a := []int{0, 1}
    fmt.Printf(&amp;quot;%v&amp;quot;, a[len(a):])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：输出 []。对一个切片执行 [i,j] 的时候，i 和 j 都不能超过切片的长度值。参考《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466739&amp;amp;idx=3&amp;amp;sn=9a1c9599172a532297ef41238450f9af&amp;amp;chksm=f247435cc530ca4ac6d92bd22011b52ae34d25d6e0eddf5b2ba85a15d3846b6674aa8bcf1d07&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;非懂不可的Slice（一）&lt;/a&gt;》。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-113-const-切片&#34;&gt;Day 113. const, 切片&lt;/h2&gt;

&lt;p&gt;1.关于 const 常量定义，下面正确的使用方式是？&lt;/p&gt;

&lt;p&gt;A.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const Pi float64 = 3.14159265358979323846
const zero= 0.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;B.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
    size int64= 1024
    eof = -1
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
    ERR_ELEM_EXISTerror = errors.New(&amp;quot;element already exists&amp;quot;)
    ERR_ELEM_NT_EXISTerror = errors.New(&amp;quot;element not exists&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;D.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const u, vfloat32 = 0, 3
const a,b, c = 3, 4, &amp;quot;foo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：ABD。&lt;/p&gt;

&lt;p&gt;2.修改下面的代码，使得第二个输出 [seek 1 2 3 4] 。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func link(p ...interface{}) {
    fmt.Println(p)
}

func main() {
    link(&amp;quot;seek&amp;quot;, 1, 2, 3, 4) // 输出 [seek 1 2 3 4] 
    a := []int{1, 2, 3, 4}
    link(&amp;quot;seek&amp;quot;, a) // 输出 [seek [1 2 3 4]] 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func link(p ...interface{}) {
    fmt.Println(p)
}

func main() {
    link(&amp;quot;seek&amp;quot;, 1, 2, 3, 4) // 输出 [seek 1 2 3 4]
    a := []int{1, 2, 3, 4}
    link(&amp;quot;seek&amp;quot;, a) // 输出 [seek [1 2 3 4]]
 
    tmplink := make([]interface{}, 0, len(a)+1)
    tmplink = append(tmplink, &amp;quot;seek&amp;quot;)
    for _, ii := range a {
        tmplink = append(tmplink, ii)
    }
    link(tmplink...) // 输出 [seek 1 2 3 4]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-114-进制-select&#34;&gt;Day 114. 进制, select&lt;/h2&gt;

&lt;p&gt;1.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    ns := []int{010: 200, 005: 100}
    print(len(ns))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：9。Go 语言中，0x 开头表示 十六进制；0 开头表示八进制。&lt;/p&gt;

&lt;p&gt;2.下面的代码输出什么？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    i := 0
    f := func() int {
         i++
         return i
    }
    c := make(chan int, 1)
    c &amp;lt;- f()
    select {
    case c &amp;lt;- f():
    default:
        fmt.Println(i)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案即解析：2。知识点：select 的使用。《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466739&amp;amp;idx=1&amp;amp;sn=bfff10a9eed52a13fb2adb63569b0bca&amp;amp;chksm=f247435cc530ca4ac2eaad9c3879331ec5507f6452e901eb046f7ec46e703a678541e1fa1840&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;Go 并发 &amp;ndash; Select&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;下面这段代码会更有助于大家理解：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    i := 0
    f := func() int {
        fmt.Println(&amp;quot;incr&amp;quot;)
        i++
        return i
    }
    c := make(chan int)
    for j := 0; j &amp;lt; 2; j++ {
        select {
        case c &amp;lt;- f():
            // noop
        default:
            // noop
        }
    }
    fmt.Println(i)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-115-可变函数-switch&#34;&gt;Day 115. 可变函数,switch&lt;/h2&gt;

&lt;p&gt;1.下面正确的是？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var y int

func f(x int) int {
    return 7
}

A.
switch y = f(2) {
case y == 7:
  return
}

B.
switch y = f(2); {
case y == 7:
  return
}

C.
switch y = f(2) {
case 7:
  return
}

D.
switch y = f(2); {
case 7:
  return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：B。知识点：switch case 的使用。&lt;/p&gt;

&lt;p&gt;2.下面的代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    a := []int{1, 2, 3, 4}
    b := variadic(a...)
    b[0], b[1] = b[1], b[0]
    fmt.Println(a)
}

func variadic(ints ...int) []int {
    return ints
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：2 1 3 4。知识点：可变函数。切片作为参数传入可变函数时不会创建新的切片。参见《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466706&amp;amp;idx=3&amp;amp;sn=003c213739e51088ad4947e473429775&amp;amp;chksm=f247437dc530ca6bafebe0a5a4090343cbf1eb992e36b6199cf213be6156273179465ed41348&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;可变函数&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-116-iota&#34;&gt;Day 116. iota&lt;/h2&gt;

&lt;p&gt;1.下面的代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
    one = 1 &amp;lt;&amp;lt; iota
    two
)

func main() {
    fmt.Println(one, two)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.下面的代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
    greeting = &amp;quot;Hello, Go&amp;quot;
    one = 1 &amp;lt;&amp;lt; iota
    two
)

func main() {
    fmt.Println(one, two)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：这两道题考的是同一个知识点：iota 的使用。
第一题：1 2；第二题：2 4。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-117-waitgroup-mutex-json&#34;&gt;Day 117. WaitGroup,mutex,json&lt;/h2&gt;

&lt;p&gt;1.Go 语言中中大多数数据类型都可以转化为有效的 JSON 文本，下面几种类型除外。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. 指针&lt;/li&gt;
&lt;li&gt;B. channel&lt;/li&gt;
&lt;li&gt;C. complex&lt;/li&gt;
&lt;li&gt;D. 函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：BCD。&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？如果想要代码输出 10，应该如何修改？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const N = 10

func main() {
    m := make(map[int]int)

    wg := &amp;amp;sync.WaitGroup{}
    mu := &amp;amp;sync.Mutex{}
    wg.Add(N)
    for i := 0; i &amp;lt; N; i++ {
        go func() {
            defer wg.Done()
           mu.Lock()
            m[i] = i
            mu.Unlock()
        }()
    }
    wg.Wait()
    println(len(m))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：输出 1。知识点：并发、引用。修复代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const N = 10

func main() {
    m := make(map[int]int)

    wg := &amp;amp;sync.WaitGroup{}
    mu := &amp;amp;sync.Mutex{}
    wg.Add(N)
    for i := 0; i &amp;lt; N; i++ {
        go func(i int) {
            defer wg.Done()
            mu.Lock()
            m[i] = i
           mu.Unlock()
        }(i)
    }
    wg.Wait()
    println(len(m))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-118-iota&#34;&gt;Day 118. iota&lt;/h2&gt;

&lt;p&gt;1、下面说法正确的是。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. Go 语言中，声明的常量未使用会报错；&lt;/li&gt;
&lt;li&gt;B. cap() 函数适用于 array、slice、map 和 channel;&lt;/li&gt;
&lt;li&gt;C. 空指针解析会触发异常；&lt;/li&gt;
&lt;li&gt;D. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：CD。A.声明的常量未使用不会报错；B.cap() 函数不适用 map。&lt;/p&gt;

&lt;p&gt;2.下面的代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
    _ = iota
    c1 int = (10*iota)
    c2
    d = iota
)
func main() {
  fmt.Printf(&amp;quot;%d - %d - %d&amp;quot;,c1,c2, d)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. compile error&lt;/li&gt;
&lt;li&gt;B. 1 - 2 - 3&lt;/li&gt;
&lt;li&gt;C. 10 - 20 - 30&lt;/li&gt;
&lt;li&gt;D. 10 - 20 - 3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：D。iota 的使用。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-119-slice-map-变量的作用域&#34;&gt;Day 119. slice, map,变量的作用域&lt;/h2&gt;

&lt;p&gt;1.关于slice或map操作，下面正确的是。&lt;/p&gt;

&lt;p&gt;A.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var s []int
s = append(s,1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;B.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var m map[string]int
m[&amp;quot;one&amp;quot;] = 1 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var s []int
s = make([]int, 0)
s = append(s,1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;D.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var m map[string]int
m = make(map[string]int)
m[&amp;quot;one&amp;quot;] = 1 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：ACD。&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var ErrDidNotWork = errors.New(&amp;quot;did not work&amp;quot;)

func DoTheThing(reallyDoIt bool) (err error) {
    if reallyDoIt {
        result, err := tryTheThing()
        if err != nil || result != &amp;quot;it worked&amp;quot; {
            err = ErrDidNotWork
        }
    }
    return err
}

func tryTheThing() (string, error) {
    return &amp;quot;&amp;quot;, ErrDidNotWork
}

func main() {
    fmt.Println(DoTheThing(true))
    fmt.Println(DoTheThing(false))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案即解析：都输出 nil。知识点：变量的作用域。因为 if 语句块内的 err 变量会遮罩函数作用域内的 err 变量。&lt;/p&gt;

&lt;p&gt;修复代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func DoTheThing(reallyDoIt bool) (err error) {
    var result string
    if reallyDoIt {
        result, err = tryTheThing()
        if err != nil || result != &amp;quot;it worked&amp;quot; {
            err = ErrDidNotWork
        }
    }
    return err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-120&#34;&gt;Day 120.&lt;/h2&gt;

&lt;p&gt;1.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    fmt.Println(len(&amp;quot;你好bj!&amp;quot;))
    fmt.Println(len(&amp;quot;你好&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9,6&lt;/p&gt;

&lt;p&gt;2.是否可以编译通过？如果通过，输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func GetValue(m map[int]string, id int) (string, bool) {
    if _, exist := m[id]; exist {
        return &amp;quot;存在数据&amp;quot;, true
    }
   return nil, false
}

func main() {

    intmap := map[int]string{
      1: &amp;quot;a&amp;quot;,
        2: &amp;quot;bb&amp;quot;,
        3: &amp;quot;ccc&amp;quot;,
    }

    v, err := GetValue(intmap, 3)
    fmt.Println(v, err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;cannot use nil as type string in return argument
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func GetValue(m map[int]string, id int) (string, bool) {
	if _, exist := m[id]; exist {
		return &amp;quot;存在数据&amp;quot;, true
	}
	return &amp;quot;&amp;quot;, false
}

func main() {

	intmap := map[int]string{
		1: &amp;quot;a&amp;quot;,
		2: &amp;quot;bb&amp;quot;,
		3: &amp;quot;ccc&amp;quot;,
	}

	v, err := GetValue(intmap, 3)
	fmt.Println(v, err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;存在数据 true
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Go语言中文网面试题 61-90</title>
      <link>/go/interview/61-90/</link>
      <pubDate>Tue, 28 Jul 2020 00:29:48 +0800</pubDate>
      <guid>/go/interview/61-90/</guid>
      <description>

&lt;h2 id=&#34;day-61-多重赋值&#34;&gt;Day 61. 多重赋值&lt;/h2&gt;

&lt;p&gt;1.下面这段代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var k = 1
    var s = []int{1, 2}
    k, s[k] = 0, 3
    fmt.Println(s[0] + s[1])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：4。知识点：多重赋值。&lt;/p&gt;

&lt;p&gt;多重赋值分为两个步骤，有先后顺序：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;计算等号左边的索引表达式和取址表达式，接着计算等号右边的表达式；&lt;/li&gt;
&lt;li&gt;赋值；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以本例，会先计算 s[k]，等号右边是两个表达式是常量，所以赋值运算等同于 &lt;code&gt;k, s[1] = 0, 3&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var k = 9
   for k = range []int{} {}
    fmt.Println(k)

    for k = 0; k &amp;lt; 3; k++ {
    }
    fmt.Println(k)


    for k = range (*[3]int)(nil) {
    }
    fmt.Println(k)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：932。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-62-nil&#34;&gt;Day 62. nil&lt;/h2&gt;

&lt;p&gt;1.下面哪一行代码会编译出错，请说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    nil := 123
    fmt.Println(nil)
    var _ map[string]int = nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：第 4 行，当前作用域中，预定义的 nil 被覆盖，此时 nil 是 int 类型值，不能赋值给 map 类型。&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var x int8 = -128
    var y = x/-1
    fmt.Println(y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：-128。因为溢出。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-63-匿名函数-defer&#34;&gt;Day 63. 匿名函数、defer&lt;/h2&gt;

&lt;p&gt;1.下面选项正确的是？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. 类型可以声明的函数体内；&lt;/li&gt;
&lt;li&gt;B. Go 语言支持 ++i 或者 &amp;ndash;i 操作；&lt;/li&gt;
&lt;li&gt;C. nil 是关键字；&lt;/li&gt;
&lt;li&gt;D. 匿名函数可以直接赋值给一个变量或者直接执行；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：AD。&lt;/p&gt;

&lt;p&gt;2.下面的代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func F(n int) func() int {
    return func() int {
        n++
        return n
    }
}

func main() {
    f := F(5)
    defer func() {
        fmt.Println(f())
    }()
    defer fmt.Println(f())
    i := f()
    fmt.Println(i)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：768。知识点：匿名函数、defer()。defer() 后面的函数如果带参数，会优先计算参数，并将结果存储在栈中，到真正执行 defer() 的时候取出。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-64-recover&#34;&gt;Day 64. recover&lt;/h2&gt;

&lt;p&gt;1.下面列举的是 recover() 的几种调用方式，哪些是正确的？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
recover()
panic(1)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;B.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
defer recover()
panic(1)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
defer func() {
    recover()
}()
panic(1)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;D.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
defer func() {
    defer func() {
        recover()
    }()
}()
panic(1)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：C。recover() 必须在 defer() 函数中直接调用才有效。上面其他几种情况调用都是无效的：直接调用 recover()、在 defer() 中直接调用 recover() 和 defer() 调用时多层嵌套。&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么，请说明？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    defer func() {
        fmt.Print(recover())
    }()
    defer func() {
        defer fmt.Print(recover())
        panic(1)
    }()
    defer recover() 
    panic(2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：21。recover() 必须在 defer() 函数中调用才有效，所以第 9 行代码捕获是无效的。在调用 defer() 时，便会计算函数的参数并压入栈中，所以执行第 6 行代码时，此时便会捕获 panic(2)；此后的 panic(1)，会被上一层的 recover() 捕获。所以输出 21。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-65-bool-defer-recover&#34;&gt;Day 65. bool ,defer, recover&lt;/h2&gt;

&lt;p&gt;1.flag 是 bool 型变量，下面 if 表达式符合编码规范的是？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. if flag == 1&lt;/li&gt;
&lt;li&gt;B. if flag&lt;/li&gt;
&lt;li&gt;C. if flag == false&lt;/li&gt;
&lt;li&gt;D. if !flag&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：BCD。&lt;/p&gt;

&lt;p&gt;2.下面的代码输出什么，请说明？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    defer func() {
        fmt.Print(recover())
    }()
    defer func() {
        defer func() {
            fmt.Print(recover())
        }()
        panic(1)
    }()
    defer recover()
    panic(2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：12。相关知识点请看 &lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648467245&amp;amp;idx=1&amp;amp;sn=f3b252693935264a9be97e186349f53d&amp;amp;chksm=f2474142c530c8545df816968f46b57487a157bc68fbecc559c40d134ca9f70d8ddce9a145b4&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;第64天&lt;/a&gt; 题目解析。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-66-for-range-数组指针-switch&#34;&gt;Day 66. for-range, 数组指针,switch&lt;/h2&gt;

&lt;p&gt;1.下面的代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type T struct {
    n int
}

func main() {
    ts := [2]T{}
    for i, t := range ts {
        switch i {
        case 0:
            t.n = 3
            ts[1].n = 9
        case 1:
            fmt.Print(t.n, &amp;quot; &amp;quot;)
        }
    }
    fmt.Print(ts)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：0 [{0} {9}]。知识点：for-range 循环数组。此时使用的是数组 ts 的副本，所以 t.n = 3 的赋值操作不会影响原数组。&lt;/p&gt;

&lt;p&gt;2.下面的代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type T struct {
    n int
}

func main() {
    ts := [2]T{}
    for i, t := range &amp;amp;ts {
      switch i {
        case 0:
            t.n = 3
            ts[1].n = 9
        case 1:
           fmt.Print(t.n, &amp;quot; &amp;quot;)
        }
    }
    fmt.Print(ts)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：9 [{0} {9}]。知识点：for-range 数组指针。for-range 循环中的循环变量 t 是原数组元素的副本。如果数组元素是结构体值，则副本的字段和原数组字段是两个不同的值。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-67-for-range-切片&#34;&gt;Day 67. for-range 切片&lt;/h2&gt;

&lt;p&gt;1.下面的代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type T struct {
    n int
}

func main() {
    ts := [2]T{}
    for i := range ts[:] {
        switch i {
        case 0:
            ts[1].n = 9
        case 1:
            fmt.Print(ts[i].n, &amp;quot; &amp;quot;)
        }
    }
    fmt.Print(ts)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：9 [{0} {9}]。知识点：for-range 切片。for-range 切片时使用的是切片的副本，但不会复制底层数组，换句话说，此副本切片与原数组共享底层数组。&lt;/p&gt;

&lt;p&gt;2.下面的代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type T struct {
    n int
}

func main() {
    ts := [2]T{}
    for i := range ts[:] {
        switch t := &amp;amp;ts[i]; i {
        case 0:
            t.n = 3;
            ts[1].n = 9
        case 1:
            fmt.Print(t.n, &amp;quot; &amp;quot;)
        }
    }
    fmt.Print(ts)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：9 [{3} {9}]。知识点：for-range 切片。参考前几道题的解析，这道题的答案应该很明显。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-68-defer-for-range&#34;&gt;Day 68. defer、for-range&lt;/h2&gt;

&lt;p&gt;1.下面代码有什么问题吗？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main()  {

    for i:=0;i&amp;lt;10 ;i++  {
    loop:
        println(i)
    }
    goto loop
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：goto 不能跳转到其他函数或者内层代码。编译报错：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;goto loop jumps into block starting at
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.下面代码输出什么，请说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    x := []int{0, 1, 2}
    y := [3]*int{}
    for i, v := range x {
        defer func() {
           print(v)
        }()
        y[i] = &amp;amp;v
    }
    print(*y[0], *y[1], *y[2])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：22222。知识点：defer()、for-range。for-range 虽然使用的是 :=，但是 v 不会重新声明，可以打印 v 的地址验证下。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-69-闭包-slice-map&#34;&gt;Day 69. 闭包, slice , map&lt;/h2&gt;

&lt;p&gt;1.关于 slice 或 map 操作，下面正确的是？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var s []int
s = append(s,1)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;B&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var m map[string]int
m[&amp;quot;one&amp;quot;] = 1 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var s []int
s = make([]int, 0)
s = append(s,1)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;D&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var m map[string]int
m = make(map[string]int)
m[&amp;quot;one&amp;quot;] = 1 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：ACD。&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test(x int) (func(), func()) {
    return func() {
        println(x)
        x += 10
    }, func() {
        println(x)
    }
}

func main() {
    a, b := test(100)
    a()
    b()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：100 110。知识点：闭包引用相同变量。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-70-字符串-defer&#34;&gt;Day 70. 字符串， defer&lt;/h2&gt;

&lt;p&gt;1.关于字符串连接，下面语法正确的是？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. str := &amp;lsquo;abc&amp;rsquo; + &amp;lsquo;123&amp;rsquo;&lt;/li&gt;
&lt;li&gt;B. str := &amp;ldquo;abc&amp;rdquo; + &amp;ldquo;123&amp;rdquo;&lt;/li&gt;
&lt;li&gt;C. str ：= &amp;lsquo;123&amp;rsquo; + &amp;ldquo;abc&amp;rdquo;&lt;/li&gt;
&lt;li&gt;D. fmt.Sprintf(&amp;ldquo;abc%d&amp;rdquo;, 123)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：BD。知识点：单引号、双引号和字符串连接。在 Go 语言中，双引号用来表示字符串 string，其实质是一个 byte 类型的数组，单引号表示 rune 类型。&lt;/p&gt;

&lt;p&gt;2.下面代码能编译通过吗？可以的话，输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {

    println(DeferTest1(1))
   println(DeferTest2(1))
}

func DeferTest1(i int) (r int) {
    r = i
    defer func() {
        r += 3
    }()
    return r
}

func DeferTest2(i int) (r int) {
    defer func() {
        r += i
    }()
    return 2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：43。具体解析请看《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466918&amp;amp;idx=2&amp;amp;sn=151a8135f22563b7b97bf01ff480497b&amp;amp;chksm=f2474389c530ca9f3dc2ae1124e4e5ed3db4c45096924265bccfcb8908a829b9207b0dd26047&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;5 年 Gopher 都不知道的 defer 细节，你别再掉进坑里！&lt;/a&gt;》。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-71-取反&#34;&gt;Day 71. 取反&lt;/h2&gt;

&lt;p&gt;1.判断题：对变量x的取反操作是 ~x？&lt;/p&gt;

&lt;p&gt;从参考答案及解析：错。&lt;/p&gt;

&lt;p&gt;Go 语言的取反操作是 ^，它返回一个每个 bit 位都取反的数。作用类似在 C、C#、Java 语言中中符号 ~，对于有符号的整数来说，是按照补码进行取反操作的（快速计算方法：对数 a 取反，结果为 -(a+1) ），对于无符号整数来说就是按位取反。&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么，请说明原因。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Slice []int

func NewSlice() Slice {
    return make(Slice, 0)
}
func (s *Slice) Add(elem int) *Slice {
    *s = append(*s, elem)
    fmt.Print(elem)
    return s
}
func main() {
    s := NewSlice()
    defer s.Add(1).Add(2)
    s.Add(3)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：132。这一题有两点需要注意：1.Add() 方法的返回值依然是指针类型 *Slice，所以可以循环调用方法 Add()；2.defer 函数的参数（包括接收者）是在 defer 语句出现的位置做计算的，而不是在函数执行的时候计算的，所以 s.Add(1) 会先于 s.Add(3) 执行。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-72-指针方法-切片&#34;&gt;Day 72. 指针方法, 切片&lt;/h2&gt;

&lt;p&gt;1.下面的代码输出什么，请说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Slice []int

func NewSlice() Slice {
    return make(Slice, 0)
}
func (s *Slice) Add(elem int) *Slice {
    *s = append(*s, elem)
    fmt.Print(elem)
    return s
}
func main() {
    s := NewSlice()
     defer func() {
          s.Add(1).Add(2)
   }()
    s.Add(3)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：312。对比昨天的第二题，本题的 s.Add(1).Add(2) 作为一个整体包在一个匿名函数中，会延迟执行。&lt;/p&gt;

&lt;p&gt;2.下面的代码输出什么，请说明？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Orange struct {
    Quantity int
}

func (o *Orange) Increase(n int) {
    o.Quantity += n
}

func (o *Orange) Decrease(n int) {
    o.Quantity -= n
}

func (o *Orange) String() string {
    return fmt.Sprintf(&amp;quot;%#v&amp;quot;, o.Quantity)
}

func main() {
    var orange Orange
    orange.Increase(10)
    orange.Decrease(5)
    fmt.Println(orange)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：{5}。这道题容易忽视的点是，String() 是指针方法，而不是值方法，所以使用 Println() 输出时不会调用到 String() 方法。&lt;/p&gt;

&lt;p&gt;可以这样修复：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    orange := &amp;amp;Orange{}
    orange.Increase(10)
    orange.Decrease(5)
    fmt.Println(orange
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-73-for-函数调用&#34;&gt;Day 73. for, 函数调用&lt;/h2&gt;

&lt;p&gt;1.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func test() []func() {
    var funs []func()
    for i := 0; i &amp;lt; 2; i++ {
        funs = append(funs, func() {
            println(&amp;amp;i, i)
        })
    }
   return funs
}

func main() {
    funs := test()
    for _, f := range funs {
        f()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;0xc000018058 2
0xc000018058 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;知识点：闭包延迟求值。for 循环局部变量 i，匿名函数每一次使用的都是同一个变量。（说明：i 的地址，输出可能与上面的不一样）。&lt;/p&gt;

&lt;p&gt;如果想要匿名函数每一次输出不同，应该怎么修改代码？&lt;/p&gt;

&lt;p&gt;2.下面的代码能编译通过吗？可以的话输出什么，请说明？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var f = func(i int) {
    print(&amp;quot;x&amp;quot;)
}

func main() {
    f := func(i int) {
        print(i)
        if i &amp;gt; 0 {
            f(i - 1)
        }
    }
    f(10)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：10x。这道题一眼看上去会输出 109876543210，其实这是错误的答案，这里不是递归。假设 main() 函数里为 f2()，外面的为 f1()，当声明 f2() 时，调用的是已经完成声明的 f1()。&lt;/p&gt;

&lt;p&gt;看下面这段代码你应该会更容易理解一点：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var x = 23

func main() {
    x := 2*x - 4
    println(x)    // 输出:42
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-74-gomaxprocs&#34;&gt;Day 74. GOMAXPROCS, :=&lt;/h2&gt;

&lt;p&gt;1.下面代码有什么问题，请说明？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    runtime.GOMAXPROCS(1)

    go func() {
        for i:=0;i&amp;lt;10 ;i++  {
            fmt.Println(i)
        }
    }()

   for {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：for {} 独占 CPU 资源导致其他 Goroutine 饿死。&lt;/p&gt;

&lt;p&gt;可以通过阻塞的方式避免 CPU 占用，修复代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    runtime.GOMAXPROCS(1)

    go func() {
        for i:=0;i&amp;lt;10 ;i++  {
            fmt.Println(i)
       }
        os.Exit(0)
   }()

   select {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引自《Go语言高级编程》&lt;/p&gt;

&lt;p&gt;2.假设 x 已声明，y 未声明，下面 4 行代码哪些是正确的。错误的请说明原因？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;x, _ := f()  // 1
x, _ = f()  // 2
x, y := f()  // 3
x, y = f()  // 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：2、3正确。知识点：简短变量声明。使用简短变量声明有几个需要注意的地方：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只能用于函数内部；&lt;/li&gt;
&lt;li&gt;短变量声明语句中至少要声明一个新的变量；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-75-panic-recover&#34;&gt;Day 75. panic、recover&lt;/h2&gt;

&lt;p&gt;1.下面的代码有什么问题，请说明？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    f, err := os.Open(&amp;quot;file&amp;quot;)
    defer f.Close()
    if err != nil {
        return
    }

    b, err := ioutil.ReadAll(f)
    println(string(b))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：defer 语句应该放在 if() 语句后面，先判断 err，再 defer 关闭文件句柄。&lt;/p&gt;

&lt;p&gt;修复代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    f, err := os.Open(&amp;quot;file&amp;quot;)
    if err != nil {
        return
    }
    defer f.Close()

    b, err := ioutil.ReadAll(f)
    println(string(b))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.下面代码输出什么，为什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func f() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Printf(&amp;quot;recover:%#v&amp;quot;, r)
        }
    }()
    panic(1)
    panic(2)
}

func main() {
    f()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：recover:1。知识点：panic、recover()。当程序 panic 时就不会往下执行，可以使用 recover() 捕获 panic 的内容。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-76-类型断言-结构体嵌套-协程&#34;&gt;Day 76. 类型断言，结构体嵌套, 协程&lt;/h2&gt;

&lt;p&gt;1.下面这段代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type S1 struct{}

func (s1 S1) f() {
    fmt.Println(&amp;quot;S1.f()&amp;quot;)
}
func (s1 S1) g() {
    fmt.Println(&amp;quot;S1.g()&amp;quot;)
}

type S2 struct {
    S1
}

func (s2 S2) f() {
    fmt.Println(&amp;quot;S2.f()&amp;quot;)
}

type I interface {
    f()
}

func printType(i I) {

    fmt.Printf(&amp;quot;%T\n&amp;quot;, i)
    if s1, ok := i.(S1); ok {
        s1.f()
        s1.g()
    }
    if s2, ok := i.(S2); ok {
        s2.f()
        s2.g()
    }
}

func main() {
    printType(S1{})
    printType(S2{})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;main.S1
S1.f()
S1.g()
main.S2
S2.f()
S1.g()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;知识点：类型断言，结构体嵌套。结构体 S2 嵌套了结构体 S1，S2 自己没有实现 g() ，调用的是 S1 的 g()。详细的解析请看《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466700&amp;amp;idx=1&amp;amp;sn=25c48d78dcfad6c70330cd36dd749e53&amp;amp;chksm=f2474363c530ca75132454e4e10e40659310a073e2f9d30ad9697d4abf7c2b9e5aa9adee58bf&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;Go 语言接口详解（二）&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;2.下面的代码有什么问题？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var wg sync.WaitGroup
    wg.Add(1)
    go func() {
        fmt.Println(&amp;quot;1&amp;quot;)
        wg.Done()
        wg.Add(1)
    }()
    wg.Wait()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：协程里面，使用 wg.Add(1) 但是没有 wg.Done()，导致 panic()。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-77-cap-可变函数&#34;&gt;Day 77. cap, 可变函数&lt;/h2&gt;

&lt;p&gt;1.关于 cap 函数适用下面哪些类型？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. 数组；&lt;/li&gt;
&lt;li&gt;B. channel;&lt;/li&gt;
&lt;li&gt;C. map；&lt;/li&gt;
&lt;li&gt;D. slice；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案即解析：ABD。cap() 函数的作用：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;arry 返回数组的元素个数；&lt;/li&gt;
&lt;li&gt;slice 返回 slice 的最大容量；&lt;/li&gt;
&lt;li&gt;channel 返回 channel 的容量；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func hello(num ...int) {
    num[0] = 18
}
 
func Test13(t *testing.T) {
    i := []int{5, 6, 7}
    hello(i...)
    fmt.Println(i[0])
}

func main() {
    t := &amp;amp;testing.T{}
    Test13(t)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 18&lt;/li&gt;
&lt;li&gt;B. 5&lt;/li&gt;
&lt;li&gt;C. Compilation error&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：A。可变函数是指针传递。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-78-switch&#34;&gt;Day 78. switch&lt;/h2&gt;

&lt;p&gt;1.关于 switch 语句，下面说法正确的是？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. 单个 case 中，可以出现多个结果选项；&lt;/li&gt;
&lt;li&gt;B. 需要使用 break 来明确退出一个 case;&lt;/li&gt;
&lt;li&gt;C. 只有在 case 中明确添加 fallthrought 关键字，才会继续执行紧跟的下一个 case;&lt;/li&gt;
&lt;li&gt;D. 条件表达式必须为常量或者整数；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：AC。&lt;/p&gt;

&lt;p&gt;2.下面代码能编译通过吗？可以的话，输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func alwaysFalse() bool {
    return false
}
 
func main() {
    switch alwaysFalse()
    {
    case true:
        println(true)
    case false:
        println(false)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：可以编译通过，输出：true。知识点：Go 代码断行规则。&lt;/p&gt;

&lt;p&gt;详情请查看：&lt;a href=&#34;https://gfw.go101.org/article/line-break-rules.html&#34; target=&#34;_blank&#34;&gt;https://gfw.go101.org/article/line-break-rules.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-79-interface-struct&#34;&gt;Day 79. interface, struct&lt;/h2&gt;

&lt;p&gt;1.interface{} 是可以指向任意对象的 Any 类型，是否正确？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. false&lt;/li&gt;
&lt;li&gt;B. true&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：B。&lt;/p&gt;

&lt;p&gt;2.下面的代码有什么问题？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type ConfigOne struct {
    Daemon string
}

func (c *ConfigOne) String() string {
    return fmt.Sprintf(&amp;quot;print: %v&amp;quot;, c)
}

func main() {
   c := &amp;amp;ConfigOne{}
    c.String()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：无限递归循环，栈溢出。知识点：类型的 String() 方法。如果类型定义了 String() 方法，使用 Printf()、Print() 、 Println() 、 Sprintf() 等格式化输出时会自动使用 String() 方法。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-80-全局变量-waitgroup&#34;&gt;Day 80. 全局变量,WaitGroup&lt;/h2&gt;

&lt;p&gt;1.定义一个包内全局字符串变量，下面语法正确的是？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. var str string&lt;/li&gt;
&lt;li&gt;B. str := &amp;ldquo;&amp;rdquo;&lt;/li&gt;
&lt;li&gt;C. str = &amp;ldquo;&amp;rdquo;&lt;/li&gt;
&lt;li&gt;D. var str = &amp;ldquo;&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：AD。全局变量要定义在函数之外，而在函数之外定义的变量只能用 var 定义。短变量声明 := 只能用于函数之内。&lt;/p&gt;

&lt;p&gt;2.下面的代码有什么问题？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {

    wg := sync.WaitGroup{}

    for i := 0; i &amp;lt; 5; i++ {
        go func(wg sync.WaitGroup, i int) {
            wg.Add(1)
            fmt.Printf(&amp;quot;i:%d\n&amp;quot;, i)
            wg.Done()
        }(wg, i)
    }

    wg.Wait()

    fmt.Println(&amp;quot;exit&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：知识点：WaitGroup 的使用。存在两个问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在协程中使用 wg.Add()；&lt;/li&gt;
&lt;li&gt;使用了 sync.WaitGroup 副本；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;修复代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {

    wg := sync.WaitGroup{}

    for i := 0; i &amp;lt; 5; i++ {
        wg.Add(1)
        go func(i int) {
            fmt.Printf(&amp;quot;i:%d\n&amp;quot;, i)
            wg.Done()
        }(i)
    }

    wg.Wait()

    fmt.Println(&amp;quot;exit&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {

    wg := &amp;amp;sync.WaitGroup{}

    for i := 0; i &amp;lt; 5; i++ {
        wg.Add(1)
        go func(wg *sync.WaitGroup,i int) {
            fmt.Printf(&amp;quot;i:%d\n&amp;quot;, i)
            wg.Done()
        }(wg,i)
    }

    wg.Wait()

    fmt.Println(&amp;quot;exit&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-81-多重赋值-野指针&#34;&gt;Day 81. 多重赋值, 野指针&lt;/h2&gt;

&lt;p&gt;1.下面的代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var a []int = nil
    a, a[0] = []int{1, 2}, 9
    fmt.Println(a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案即解析：运行时错误。知识点：多重赋值。&lt;/p&gt;

&lt;p&gt;多重赋值分为两个步骤，有先后顺序：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;计算等号左边的索引表达式和取址表达式，接着计算等号右边的表达式；&lt;/li&gt;
&lt;li&gt;赋值；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2.下面代码中的指针 p 为野指针，因为返回的栈内存在函数结束时会被释放？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type TimesMatcher struct {
    base int
}

func NewTimesMatcher(base int) *TimesMatcher  {
    return &amp;amp;TimesMatcher{base:base}
}

func main() {
    p := NewTimesMatcher(3)
    fmt.Println(p)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. false&lt;/li&gt;
&lt;li&gt;B. true&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：A。Go语言的内存回收机制规定，只要有一个指针指向引用一个变量，那么这个变量就不会被释放（内存逃逸），因此在 Go 语言中返回函数参数或临时变量是安全的。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-82-iota-数值溢出&#34;&gt;Day 82. iota, 数值溢出&lt;/h2&gt;

&lt;p&gt;1.下面这段代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    count := 0
    for i := range [256]struct{}{} {
        m, n := byte(i), int8(i)
        if n == -n {
            count++
        }
        if m == -m {
            count++
        }
    }
    fmt.Println(count)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：4。知识点：数值溢出。当 i 的值为 0、128 是会发生相等情况，注意 byte 是 uint8 的别名。&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
    azero = iota
    aone  = iota
)

const (
    info  = &amp;quot;msg&amp;quot;
     bzero = iota
    bone  = iota
)

func main() {
    fmt.Println(azero, aone)
    fmt.Println(bzero, bone)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：0 1 1 2。知识点：iota 的使用。这道题易错点在 bzero、bone 的值，在一个常量声明代码块中，如果 iota 没出现在第一行，则常量的初始值就是非 0 值。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-83-接口-包&#34;&gt;Day 83. 接口,包&lt;/h2&gt;

&lt;p&gt;1.同级文件的包名不允许有多个，是否正确？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. true&lt;/li&gt;
&lt;li&gt;B. false&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：A。一个文件夹下只能有一个包，可以多个.go文件，但这些文件必须属于同一个包。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;看昨天答题评论，有个例外，Go test 支持在不同名的 package 属于同一个目录，只要包名是以 package_test 形式命名即可。大家可以看下 strings 包，就是这样子的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;2.下面的代码有什么问题，请说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type data struct {
    name string
}

func (p *data) print() {
    fmt.Println(&amp;quot;name:&amp;quot;, p.name)
}

type printer interface {
    print()
}

func main() {
    d1 := data{&amp;quot;one&amp;quot;}
    d1.print()

    var in printer = data{&amp;quot;two&amp;quot;}
    in.print()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：编译报错。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;cannot use data literal (type data) as type printer in assignment:
data does not implement printer (print method has pointer receiver)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结构体类型 data 没有实现接口 printer。知识点：接口。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-84-panic-切片&#34;&gt;Day 84. panic, 切片&lt;/h2&gt;

&lt;p&gt;1.函数执行时，如果由于 panic 导致了异常，则延迟函数不会执行。这一说法是否正确？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. true&lt;/li&gt;
&lt;li&gt;B. false&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：B。
由 panic 引发异常以后，程序停止执行，然后调用延迟函数（defer），就像程序正常退出一样。&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    a := [3]int{0, 1, 2}
    s := a[1:2]

    s[0] = 11
    s = append(s, 12)
    s = append(s, 13)
    s[0] = 21

    fmt.Println(a)
    fmt.Println(s)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：&lt;/p&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;[0 11 12]
[21 12 13]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详情请参考《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466739&amp;amp;idx=4&amp;amp;sn=9de0eba9bdb36aa3b67d8a3903c53584&amp;amp;chksm=f247435cc530ca4a98abd9c1b2d58a63c7716e64236076c1296ed2964cd4fb68f7c8a6d44f85&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;非懂不可的Slice（二）&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-85-拷贝切片-append-字符串&#34;&gt;Day 85. 拷贝切片,append,字符串&lt;/h2&gt;

&lt;p&gt;1.下面这段代码输出什么？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    fmt.Println(strings.TrimRight(&amp;quot;ABBA&amp;quot;, &amp;quot;BA&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：输出空字符。这是一个大多数人遇到的坑，TrimRight() 会将第二个参数字符串里面所有的字符拿出来处理，只要与其中任何一个字符相等，便会将其删除。想正确地截取字符串，可以参考 TrimSuffix() 函数。&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var src, dst []int
    src = []int{1, 2, 3}
    copy(dst, src) 
    fmt.Println(dst)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：输出 []。知识点：拷贝切片。copy(dst, src) 函数返回 len(dst)、len(src) 之间的最小值。如果想要将 src 完全拷贝至 dst，必须给 dst 分配足够的内存空间。&lt;/p&gt;

&lt;p&gt;修复代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var src, dst []int
    src = []int{1, 2, 3}
    dst = make([]int, len(src))
    n := copy(dst, src)
    fmt.Println(n,dst)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者直接使用 append()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var src, dst []int
    src = []int{1, 2, 3}
    dst = append(dst, src...)
    fmt.Println(&amp;quot;dst:&amp;quot;, dst)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;详情请参考《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466739&amp;amp;idx=4&amp;amp;sn=9de0eba9bdb36aa3b67d8a3903c53584&amp;amp;chksm=f247435cc530ca4a98abd9c1b2d58a63c7716e64236076c1296ed2964cd4fb68f7c8a6d44f85&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;非懂不可的Slice（二）&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-86-进制数-运算符优先级&#34;&gt;Day 86. 进制数,运算符优先级&lt;/h2&gt;

&lt;p&gt;1.n 是秒数，下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    n := 43210
    fmt.Println(n/60*60, &amp;quot; hours and &amp;quot;, n%60*60, &amp;quot; seconds&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：43200 hours and 600 seconds。知识点：运算符优先级。算术运算符 *、/ 和 % 的优先级相同，从左向右结合。&lt;/p&gt;

&lt;p&gt;修复代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    n := 43210
    fmt.Println(n/(60*60), &amp;quot;hours and&amp;quot;, n%(60*60), &amp;quot;seconds&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.下面代码输出什么，为什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
    Century = 100
    Decade  = 010
    Year    = 001
)

func main() {
    fmt.Println(Century + 2*Decade + 2*Year)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：118。知识点：进制数。Go 语言里面，八进制数以 0 开头，十六进制数以 0x 开头，所以 Decade 表示十进制的 8。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-87-协程-运算符优先级&#34;&gt;Day 87. 协程, 运算符优先级&lt;/h2&gt;

&lt;p&gt;1.关于协程，下面说法正确是()&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A.协程和线程都可以实现程序的并发执行；&lt;/li&gt;
&lt;li&gt;B.线程比协程更轻量级；&lt;/li&gt;
&lt;li&gt;C.协程不存在死锁问题；&lt;/li&gt;
&lt;li&gt;D.通过 channel 来进行协程间的通信；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：AD。&lt;/p&gt;

&lt;p&gt;2.在数学里面，有著名的勾股定理：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://mmbiz.qpic.cn/mmbiz_png/zVM9HMBJAjMZQtI7vy313Sn2193ta5ZnHNaCxSoAIDcC2VyickjaJ8CbUMm1XvQ8skpoZst6H9TNX2PWO8NxiciaQ/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;例如，有我们熟悉的组合（3，4，5）、（6、8、10）等。在 Go 语言中，下面代码输出 true：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Println(3^2+4^2 == 5^2) // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;问题来了，下面代码输出什么，请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    fmt.Println(6^2+8^2 == 10^2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：false。在 Go 语言里面，^ 作为二元运算符时表示&lt;strong&gt;按位异或&lt;/strong&gt;：对应位，相同为 0，相异为 1。所以第一段代码输出 true 是因为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;0011 ^ 0010 == 0001   (3^2 == 1)
0100 ^ 0010 == 0110   (4^2 == 6)
0101 ^ 0010 == 0111   (5^2 == 7)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1+6=7，这当然是相等的。你来试试分解下第二段代码的数学表达式。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-88-map-nil&#34;&gt;Day 88. map,nil&lt;/h2&gt;

&lt;p&gt;1.下面这段代码能通过编译吗？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    m := make(map[string]int)
    m[&amp;quot;foo&amp;quot;]++
    fmt.Println(m[&amp;quot;foo&amp;quot;])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：能通过编译。&lt;/p&gt;

&lt;p&gt;上面的代码可以理解成：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    m := make(map[string]int)
    v := m[&amp;quot;foo&amp;quot;]
    v++
    m[&amp;quot;foo&amp;quot;] = v
    fmt.Println(m[&amp;quot;foo&amp;quot;])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.下面的代码输出什么，请简要说明？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Foo() error {
    var err *os.PathError = nil
    // …
    return err
}

func main() {
    err := Foo()
    fmt.Println(err)
    fmt.Println(err == nil)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：nil false。知识点：接口值与 nil 值。只有在值和动态类型都为 nil 的情况下，接口值才为 nil。Foo() 函数返回的 err 变量，值为 nil、动态类型为 *os.PathError，与 nil（值为 nil，动态类型为 nil）显然是不相等。我们可以打印下变量 err 的详情：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Printf(&amp;quot;%#v\n&amp;quot;,err)   // (*os.PathError)(nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个更合适的解决办法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Foo() (err error) {
    // …
    return
}

func main() {
    err := Foo()
    fmt.Println(err)
    fmt.Println(err == nil)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-89-指针&#34;&gt;Day 89. 指针&lt;/h2&gt;

&lt;p&gt;1.下面代码能编译通过吗？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    v := []int{1, 2, 3}
    for i, n := 0, len(v); i &amp;lt; n; i++ {
        v = append(v, i)
    }
    fmt.Println(v)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：能编译通过，输出 [1 2 3 0 1 2]。for 循环开始的时候，终止条件只会计算一次。&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type P *int
type Q *int

func main() {
   var p P = new(int)
    *p += 8
    var x *int = p
    var q Q = x
    *q++
    fmt.Println(*p, *q)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A.8 8&lt;/li&gt;
&lt;li&gt;B.8 9&lt;/li&gt;
&lt;li&gt;C.9 9&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：C。指针变量指向相同的地址。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-90-类型&#34;&gt;Day 90. 类型&lt;/h2&gt;

&lt;p&gt;1.下面代码能通过编译吗？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type T int

func F(t T) {}

func main() {
    var q int
    F(q)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.下面代码能通过编译吗？请简要说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type T []int

func F(t T) {}

func main() {
    var q []int
    F(q)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们将这两道题目放到一块做一个解析，第一题不能通过编译，第二题可以通过编译。我们知道不同类型的值是不能相互赋值的，即使底层类型一样，所以第一题编译不通过；对于底层类型相同的变量可以相互赋值还有一个重要的条件，即至少有一个不是有名类型（named type）。&lt;/p&gt;

&lt;p&gt;这是 Go 语言规范手册的原文：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;x&amp;rsquo;s type V and T have identical underlying types and at least one of V or T is not a named type. &amp;ldquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Named Type 有两类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;内置类型，比如 int, int64, float, string, bool 等；&lt;/li&gt;
&lt;li&gt;使用关键字 type 声明的类型；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unnamed Type 是基于已有的 Named Type 组合一起的类型，例如：struct{}、[]string、interface{}、map[string]bool 等。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go语言中文网面试题 31-60</title>
      <link>/go/interview/31-60/</link>
      <pubDate>Mon, 27 Jul 2020 22:07:56 +0800</pubDate>
      <guid>/go/interview/31-60/</guid>
      <description>

&lt;h2 id=&#34;day-31-可变函数-append&#34;&gt;Day 31. 可变函数、append()&lt;/h2&gt;

&lt;p&gt;1.下面这段代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func change(s ...int) {
    s = append(s,3)
}

func main() {
    slice := make([]int,5,5)
    slice[0] = 1
    slice[1] = 2
    change(slice...)
    fmt.Println(slice)
    change(slice[0:2]...)
    fmt.Println(slice)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;[1 2 0 0 0]
[1 2 3 0 0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;知识点：可变函数、append()操作。&lt;/p&gt;

&lt;p&gt;Go 提供的语法糖&lt;code&gt;...&lt;/code&gt;，可以将 slice 传进可变函数，不会创建新的切片。&lt;/p&gt;

&lt;p&gt;第一次调用 change() 时，append() 操作使切片底层数组发生了扩容，原 slice 的底层数组不会改变；&lt;/p&gt;

&lt;p&gt;第二次调用change() 函数时，使用了操作符&lt;code&gt;[i,j]&lt;/code&gt;获得一个新的切片，假定为 slice1，它的底层数组和原切片底层数组是重合的，不过 slice1 的长度、容量分别是 2、5，所以在 change() 函数中对 slice1 底层数组的修改会影响到原切片。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./31-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466706&amp;amp;idx=3&amp;amp;sn=003c213739e51088ad4947e473429775&amp;amp;chksm=f247437dc530ca6bafebe0a5a4090343cbf1eb992e36b6199cf213be6156273179465ed41348&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;可变函数&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466739&amp;amp;idx=3&amp;amp;sn=9a1c9599172a532297ef41238450f9af&amp;amp;chksm=f247435cc530ca4ac6d92bd22011b52ae34d25d6e0eddf5b2ba85a15d3846b6674aa8bcf1d07&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;非懂不可的Slice（一）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466739&amp;amp;idx=4&amp;amp;sn=9de0eba9bdb36aa3b67d8a3903c53584&amp;amp;chksm=f247435cc530ca4a98abd9c1b2d58a63c7716e64236076c1296ed2964cd4fb68f7c8a6d44f85&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;非懂不可的Slice（二）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;2.下面这段代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var a = []int{1, 2, 3, 4, 5}
    var r [5]int

    for i, v := range a {
        if i == 0 {
            a[1] = 12
            a[2] = 13
        }
        r[i] = v
    }
    fmt.Println(&amp;quot;r = &amp;quot;, r)
    fmt.Println(&amp;quot;a = &amp;quot;, a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r =  [1 12 13 4 5]
a =  [1 12 13 4 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这道题是 &lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648467013&amp;amp;idx=1&amp;amp;sn=e9856544b4ef7e02deb62e5839550786&amp;amp;chksm=f247402ac530c93c879f433e88cdd4ab55fcc6b336d342f3a8c1ece6cecb6b131f5acc486264&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;第30天&lt;/a&gt; 的第二题的一个解决办法，这的 a 是一个切片，那切片是怎么实现的呢？切片在 go 的内部结构有一个指向底层数组的指针，当 range 表达式发生复制时，副本的指针依旧指向原底层数组，所以对切片的修改都会反应到底层数组上，所以通过 v 可以获得修改后的数组元素。&lt;/p&gt;

&lt;p&gt;引自：&lt;a href=&#34;https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/&#34; target=&#34;_blank&#34;&gt;https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-32-for-range-map&#34;&gt;Day 32. for range ,map&lt;/h2&gt;

&lt;p&gt;1.下面这段代码输出结果正确吗？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Foo struct {
    bar string
}
func main() {
    s1 := []Foo{
        {&amp;quot;A&amp;quot;},
        {&amp;quot;B&amp;quot;},
        {&amp;quot;C&amp;quot;},
    }
    s2 := make([]*Foo, len(s1))
    for i, value := range s1 {
        s2[i] = &amp;amp;value
    }
    fmt.Println(s1[0], s1[1], s1[2])
    fmt.Println(s2[0], s2[1], s2[2])
}
输出：
{A} {B} {C}
&amp;amp;{A} &amp;amp;{B} &amp;amp;{C}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：s2 的输出结果错误。s2 的输出是 &lt;code&gt;&amp;amp;{C} &amp;amp;{C} &amp;amp;{C}&lt;/code&gt;，在 &lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648467013&amp;amp;idx=1&amp;amp;sn=e9856544b4ef7e02deb62e5839550786&amp;amp;chksm=f247402ac530c93c879f433e88cdd4ab55fcc6b336d342f3a8c1ece6cecb6b131f5acc486264&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;第 30 天&lt;/a&gt; 的答案解析第二题，我们提到过，for range 使用短变量声明(:=)的形式迭代变量时，变量 i、value 在每次循环体中都会被重用，而不是重新声明。所以 s2 每次填充的都是临时变量 value 的地址，而在最后一次循环中，value 被赋值为{c}。因此，s2 输出的时候显示出了三个 &amp;amp;{c}。&lt;/p&gt;

&lt;p&gt;可行的解决办法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for i := range s1 {
    s2[i] = &amp;amp;s1[i]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.下面代码里的 counter 的输出值？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {

    var m = map[string]int{
        &amp;quot;A&amp;quot;: 21,
        &amp;quot;B&amp;quot;: 22,
        &amp;quot;C&amp;quot;: 23,
    }
    counter := 0
    for k, v := range m {
        if counter == 0 {
            delete(m, &amp;quot;A&amp;quot;)
        }
        counter++
        fmt.Println(k, v)
    }
    fmt.Println(&amp;quot;counter is &amp;quot;, counter)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 2&lt;/li&gt;
&lt;li&gt;B. 3&lt;/li&gt;
&lt;li&gt;C. 2 或 3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：C。for range map 是无序的，如果第一次循环到 A，则输出 3；否则输出 2。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-33-协程-循环语句-多重赋值&#34;&gt;Day 33. 协程，循环语句，多重赋值&lt;/h2&gt;

&lt;p&gt;1.关于协程，下面说法正确是（）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. 协程和线程都可以实现程序的并发执行；&lt;/li&gt;
&lt;li&gt;B. 线程比协程更轻量级；&lt;/li&gt;
&lt;li&gt;C. 协程不存在死锁问题；&lt;/li&gt;
&lt;li&gt;D. 通过 channel 来进行协程间的通信；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：AD。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;2.关于循环语句，下面说法正确的有（）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. 循环语句既支持 for 关键字，也支持 while 和 do-while；&lt;/li&gt;
&lt;li&gt;B. 关键字 for 的基本使用方法与 C/C++ 中没有任何差异；&lt;/li&gt;
&lt;li&gt;C. for 循环支持 continue 和 break 来控制循环，但是它提供了一个更高级的 break，可以选择中断哪一个循环；&lt;/li&gt;
&lt;li&gt;D. for 循环不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：CD。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;3.下面代码输出正确的是？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    i := 1
    s := []string{&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;}
    i, s[i-1] = 2, &amp;quot;Z&amp;quot;
    fmt.Printf(&amp;quot;s: %v \n&amp;quot;, s)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. s: [Z,B,C]&lt;/li&gt;
&lt;li&gt;B. s: [A,Z,C]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：A。知识点：多重赋值。&lt;/p&gt;

&lt;p&gt;多重赋值分为两个步骤，有先后顺序：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;计算等号左边的索引表达式和取址表达式，接着计算等号右边的表达式；&lt;/li&gt;
&lt;li&gt;赋值；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以本例，会先计算 s[i-1]，等号右边是两个表达式是常量，所以赋值运算等同于 &lt;code&gt;i, s[0] = 2, &amp;quot;Z&amp;quot;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-34-强制类型转化-类型断言-方法集&#34;&gt;Day 34. 强制类型转化,类型断言、方法集&lt;/h2&gt;

&lt;p&gt;1.关于类型转化，下面选项正确的是？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;A.
type MyInt int
var i int = 1
var j MyInt = i

B.
type MyInt int
var i int = 1
var j MyInt = (MyInt)i

C.
type MyInt int
var i int = 1
var j MyInt = MyInt(i)

D.
type MyInt int
var i int = 1
var j MyInt = i.(MyInt)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：C。知识点：强制类型转化。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;2.关于switch语句，下面说法正确的有?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. 条件表达式必须为常量或者整数；&lt;/li&gt;
&lt;li&gt;B. 单个case中，可以出现多个结果选项；&lt;/li&gt;
&lt;li&gt;C. 需要用break来明确退出一个case；&lt;/li&gt;
&lt;li&gt;D. 只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：BD。参考文章 &lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648467036&amp;amp;idx=2&amp;amp;sn=79bb23c3d1d2eef7e989ecc2643b5f5a&amp;amp;chksm=f2474033c530c925d5accf3633888d783dd3e3137b71a3b963a397d198e2619cd8e32f0ddd4f&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;条件语句和循环语句&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;3.如果 Add() 函数的调用代码为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var a Integer = 1
    var b Integer = 2
    var i interface{} = &amp;amp;a
    sum := i.(*Integer).Add(b)
    fmt.Println(sum)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;则Add函数定义正确的是()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;A.
type Integer int
func (a Integer) Add(b Integer) Integer {
        return a + b
}

B.
type Integer int
func (a Integer) Add(b *Integer) Integer {
        return a + *b
}

C.
type Integer int
func (a *Integer) Add(b Integer) Integer {
        return *a + b
}

D.
type Integer int
func (a *Integer) Add(b *Integer) Integer {
        return *a + *b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：AC。知识点：类型断言、方法集。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-35-bool-自增和自减-接口&#34;&gt;Day 35. bool, 自增和自减, 接口&lt;/h2&gt;

&lt;p&gt;1.关于 bool 变量 b 的赋值，下面错误的用法是？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. b = true&lt;/li&gt;
&lt;li&gt;B. b = 1&lt;/li&gt;
&lt;li&gt;C. b = bool(1)&lt;/li&gt;
&lt;li&gt;D. b = (1 == 2)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：BC。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;2.关于变量的自增和自减操作，下面语句正确的是？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;A.
i := 1
i++

B.
i := 1
j = i++

C.
i := 1
++i

D.
i := 1
i--
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：AD。知识点：自增自减操作。i++ 和 i&amp;ndash; 在 Go 语言中是语句，不是表达式，因此不能赋值给另外的变量。此外没有 ++i 和 &amp;ndash;i。&lt;/p&gt;

&lt;p&gt;3.关于GetPodAction定义，下面赋值正确的是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Fragment interface {
        Exec(transInfo *TransInfo) error
}
type GetPodAction struct {
}
func (g GetPodAction) Exec(transInfo *TransInfo) error {
        ...
        return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. var fragment Fragment = new(GetPodAction)&lt;/li&gt;
&lt;li&gt;B. var fragment Fragment = GetPodAction&lt;/li&gt;
&lt;li&gt;C. var fragment Fragment = &amp;amp;GetPodAction{}&lt;/li&gt;
&lt;li&gt;D. var fragment Fragment = GetPodAction{}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：ACD。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-36-select-函数声明-切片初始化&#34;&gt;Day 36. select, 函数声明，切片初始化&lt;/h2&gt;

&lt;p&gt;1.关于函数声明，下面语法正确的是？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. func f(a, b int) (value int, err error)&lt;/li&gt;
&lt;li&gt;B. func f(a int, b int) (value int, err error)&lt;/li&gt;
&lt;li&gt;C. func f(a, b int) (value int, error)&lt;/li&gt;
&lt;li&gt;D. func f(a int, b int) (int, int, error)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：ABD。参考文章《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466706&amp;amp;idx=4&amp;amp;sn=b296779ff31a98ecc978d2e513328443&amp;amp;chksm=f247437dc530ca6bf646850a498e19e5c7f331e0ef3e38909297da8724223422075d04cd21bf&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;函数&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;2.关于整型切片的初始化，下面正确的是？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. s := make([]int)&lt;/li&gt;
&lt;li&gt;B. s := make([]int, 0)&lt;/li&gt;
&lt;li&gt;C. s := make([]int, 5, 10)&lt;/li&gt;
&lt;li&gt;D. s := []int{1, 2, 3, 4, 5}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：BCD。参考文章《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466739&amp;amp;idx=3&amp;amp;sn=9a1c9599172a532297ef41238450f9af&amp;amp;chksm=f247435cc530ca4ac6d92bd22011b52ae34d25d6e0eddf5b2ba85a15d3846b6674aa8bcf1d07&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;非懂不可的Slice（一）&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;3.下面代码会触发异常吗？请说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    runtime.GOMAXPROCS(1)
    int_chan := make(chan int, 1)
    string_chan := make(chan string, 1)
    int_chan &amp;lt;- 1
    string_chan &amp;lt;- &amp;quot;hello&amp;quot;
    select {
    case value := &amp;lt;-int_chan:
        fmt.Println(value)
    case value := &amp;lt;-string_chan:
        panic(value)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：&lt;code&gt;select&lt;/code&gt; 会随机选择一个可用通道做收发操作，所以可能触发异常，也可能不会。具体详看《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466739&amp;amp;idx=1&amp;amp;sn=bfff10a9eed52a13fb2adb63569b0bca&amp;amp;chksm=f247435cc530ca4ac2eaad9c3879331ec5507f6452e901eb046f7ec46e703a678541e1fa1840&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;Go 并发 &amp;ndash; Select&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-37-函数返回值类型-channel-常量&#34;&gt;Day 37. 函数返回值类型, channel, 常量&lt;/h2&gt;

&lt;p&gt;1.关于channel的特性，下面说法正确的是？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. 给一个 nil channel 发送数据，造成永远阻塞&lt;/li&gt;
&lt;li&gt;B. 从一个 nil channel 接收数据，造成永远阻塞&lt;/li&gt;
&lt;li&gt;C. 给一个已经关闭的 channel 发送数据，引起 panic&lt;/li&gt;
&lt;li&gt;D. 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：ABCD。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;2.下面代码有什么问题？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const i = 100
var j = 123

func main() {
    fmt.Println(&amp;amp;j, j)
    fmt.Println(&amp;amp;i, i)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：编译报错&lt;code&gt;cannot take the address of i&lt;/code&gt;。知识点：常量。常量不同于变量的在运行期分配内存，常量通常会被编译器在预处理阶段直接展开，作为指令数据使用，所以常量无法寻址。&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;3.下面代码能否编译通过？如果通过，输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func GetValue(m map[int]string, id int) (string, bool) {

    if _, exist := m[id]; exist {
        return &amp;quot;exist&amp;quot;, true
    }
    return nil, false
}
func main() {
    intmap := map[int]string{
        1: &amp;quot;a&amp;quot;,
        2: &amp;quot;b&amp;quot;,
        3: &amp;quot;c&amp;quot;,
    }

    v, err := GetValue(intmap, 3)
    fmt.Println(v, err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：不能通过编译。知识点：函数返回值类型。nil 可以用作 interface、function、pointer、map、slice 和 channel 的“空值”。但是如果不特别指定的话，Go 语言不能识别类型，所以会报错:&lt;code&gt;cannot use nil as type string in return argument&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-38-异常&#34;&gt;Day 38. 异常&lt;/h2&gt;

&lt;p&gt;1.关于异常的触发，下面说法正确的是？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. 空指针解析；&lt;/li&gt;
&lt;li&gt;B. 下标越界；&lt;/li&gt;
&lt;li&gt;C. 除数为0；&lt;/li&gt;
&lt;li&gt;D. 调用panic函数；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：ABCD。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    x := []string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;}
    for v := range x {
        fmt.Print(v)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：012。注意区别下面代码段：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    x := []string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;}
    for _, v := range x {
        fmt.Print(v)     //输出 abc
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;3.下面这段代码能否编译通过？如果通过，输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt; type User struct{}
 type User1 User
 type User2 = User
 
 func (i User1) m1() {
     fmt.Println(&amp;quot;m1&amp;quot;)
 }
 func (i User) m2() {
     fmt.Println(&amp;quot;m2&amp;quot;)
}

func main() {
    var i1 User1
    var i2 User2
    i1.m1()
    i2.m2()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：能，输出&lt;code&gt;m1 m2&lt;/code&gt;，第 2 行代码基于类型 User 创建了新类型 User1，第 3 行代码是创建了 User 的类型别名 User2，注意使用 = 定义类型别名。因为 User2 是别名，完全等价于 User，所以 User2 具有 User 所有的方法。但是 i1.m1() 是不能执行的，因为 User1 没有定义该方法。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-39-channel-go-interface&#34;&gt;Day 39. channel, go, interface&lt;/h2&gt;

&lt;p&gt;1.关于无缓冲和有冲突的channel，下面说法正确的是？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. 无缓冲的channel是默认的缓冲为1的channel；&lt;/li&gt;
&lt;li&gt;B. 无缓冲的channel和有缓冲的channel都是同步的；&lt;/li&gt;
&lt;li&gt;C. 无缓冲的channel和有缓冲的channel都是非同步的；&lt;/li&gt;
&lt;li&gt;D. 无缓冲的channel是同步的，而有缓冲的channel是非同步的；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：D。参考文章《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466711&amp;amp;idx=1&amp;amp;sn=32b636a8cf9d23a8ed6f0b7c3fbcfc72&amp;amp;chksm=f2474378c530ca6e03c60d793d58283ba3047c645ae55e47c9791e88d7deaac63e1976f4d710&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;Go 并发 &amp;ndash; 信道&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;2.下面代码是否能编译通过？如果通过，输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt; func Foo(x interface{}) {
     if x == nil {
         fmt.Println(&amp;quot;empty interface&amp;quot;)
         return
    }
     fmt.Println(&amp;quot;non-empty interface&amp;quot;)
 }
func main() {
    var x *int = nil
    Foo(x)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：&lt;code&gt;non-empty interface&lt;/code&gt; 考点：interface 的内部结构，我们知道接口除了有静态类型，还有动态类型和动态值，当且仅当动态值和动态类型都为 nil 时，接口类型值才为 nil。这里的 x 的动态类型是 &lt;code&gt;*int&lt;/code&gt;，所以 x 不为 nil。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;3.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    ch := make(chan int, 100)
    // A
    go func() {              
        for i := 0; i &amp;lt; 10; i++ {
            ch &amp;lt;- i
       }
    }()
    // B
    go func() {
        for {
            a, ok := &amp;lt;-ch
            if !ok {
               fmt.Println(&amp;quot;close&amp;quot;)
                return
            }
            fmt.Println(&amp;quot;a: &amp;quot;, a)
        }
    }()
    close(ch)
    fmt.Println(&amp;quot;ok&amp;quot;)
    time.Sleep(time.Second * 10)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：程序抛异常。先定义下，第一个协程为 A 协程，第二个协程为 B 协程；当 A 协程还没起时，主协程已经将 channel 关闭了，当 A 协程往关闭的 channel 发送数据时会 panic，&lt;code&gt;panic: send on closed channel&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-40-select-channel&#34;&gt;Day 40. select, channel&lt;/h2&gt;

&lt;p&gt;1.关于select机制，下面说法正确的是?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. select机制用来处理异步IO问题；&lt;/li&gt;
&lt;li&gt;B. select机制最大的一条限制就是每个case语句里必须是一个IO操作；&lt;/li&gt;
&lt;li&gt;C. golang在语言级别支持select关键字；&lt;/li&gt;
&lt;li&gt;D. select关键字的用法与switch语句非常类似，后面要带判断条件；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：ABC。参考文章《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466739&amp;amp;idx=1&amp;amp;sn=bfff10a9eed52a13fb2adb63569b0bca&amp;amp;chksm=f247435cc530ca4ac2eaad9c3879331ec5507f6452e901eb046f7ec46e703a678541e1fa1840&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;Go 并发 &amp;ndash; Select&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;2.下面的代码有什么问题？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Stop(stop &amp;lt;-chan bool) {
    close(stop)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：有方向的 channel 不可以被关闭。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;3.下面这段代码存在什么问题？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Param map[string]interface{}

type Show struct {
    *Param

}
func main() {
    s := new(Show)
    s.Param[&amp;quot;day&amp;quot;] = 2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：存在两个问题：1.map 需要初始化才能使用；2.指针不支持索引。修复代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    s := new(Show)
    // 修复代码
    p := make(Param)
    p[&amp;quot;day&amp;quot;] = 2
    s.Param = &amp;amp;p
    tmp := *s.Param
    fmt.Println(tmp[&amp;quot;day&amp;quot;])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-41-切片初始化-指针&#34;&gt;Day 41. 切片初始化，指针&lt;/h2&gt;

&lt;p&gt;1.下面代码编译能通过吗？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main()  
{ 
    fmt.Println(&amp;quot;hello world&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：编译错误。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;syntax error: unexpected semicolon or newline before {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go 语言中，大括号不能放在单独的一行。&lt;/p&gt;

&lt;p&gt;正确的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    fmt.Println(&amp;quot;works&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引自：&lt;a href=&#34;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/&#34; target=&#34;_blank&#34;&gt;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.下面这段代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var x = []int{2: 2, 3, 0: 1}

func main() {
    fmt.Println(x)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：输出&lt;code&gt;[1 0 2 3]&lt;/code&gt;，字面量初始化切片时候，可以指定索引，没有指定索引的元素会在前一个索引基础之上加一，所以输出&lt;code&gt;[1 0 2 3]&lt;/code&gt;，而不是&lt;code&gt;[1 3 2]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;3.下面这段代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func incr(p *int) int {
    *p++
    return *p
}
func main() {
    v := 1
    incr(&amp;amp;v)
    fmt.Println(v)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：2。知识点：指针。p 是指针变量，指向变量 v，&lt;code&gt;*p++&lt;/code&gt;操作的意思是取出变量 v 的值并执行加一操作，所以 v 的最终值是 2。&lt;/p&gt;

&lt;p&gt;关于指针的使用可以参考文章《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648467085&amp;amp;idx=2&amp;amp;sn=c37e20fb2823451498374b79e9630926&amp;amp;chksm=f24740e2c530c9f4afe41620b7b083040f0fb57de51166f32e0554a57077ba0218387a7b0d37&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;800 字彻底理解 Go 指针&lt;/a&gt;》。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-42-未使用变量-for-range-string&#34;&gt;Day 42. 未使用变量, for range ,string&lt;/h2&gt;

&lt;p&gt;1.请指出下面代码的错误？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

var gvar int 

func main() {  
    var one int   
    two := 2      
    var three int 
    three = 3

    func(unused string) {
        fmt.Println(&amp;quot;Unused arg. No compile error&amp;quot;)
    }(&amp;quot;what?&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：变量 one、two 和 three 声明未使用。知识点：未使用变量。如果有未使用的变量代码将编译失败。但也有例外，函数中声明的变量必须要使用，但可以有未使用的全局变量。函数的参数未使用也是可以的。&lt;/p&gt;

&lt;p&gt;如果你给未使用的变量分配了一个新值，代码也还是会编译失败。你需要在某个地方使用这个变量，才能让编译器愉快的编译。&lt;/p&gt;

&lt;p&gt;修复代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var one int
    _ = one

    two := 2
    fmt.Println(two)

    var three int
    three = 3
    one = three

    var four int
    four = four
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个选择是注释掉或者移除未使用的变量 。&lt;/p&gt;

&lt;p&gt;引自：&lt;a href=&#34;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/&#34; target=&#34;_blank&#34;&gt;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type ConfigOne struct {
    Daemon string
}

func (c *ConfigOne) String() string {
    return fmt.Sprintf(&amp;quot;print: %v&amp;quot;, c)
}

 func main() {
    c := &amp;amp;ConfigOne{}
    c.String()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：运行时错误。如果类型实现 String() 方法，当格式化输出时会自动使用 String() 方法。上面这段代码是在该类型的 String() 方法内使用格式化输出，导致递归调用，最后抛错。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;runtime: goroutine stack exceeds 1000000000-byte limit
fatal error: stack overflow
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt; func main() {
     var a = []int{1, 2, 3, 4, 5}
     var r = make([]int, 0)
 
     for i, v := range a {
         if i == 0 {
             a = append(a, 6, 7)
         }
 
        r = append(r, v)
    }

    fmt.Println(r)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：&lt;code&gt;[1 2 3 4 5]&lt;/code&gt;。a 在 for range 过程中增加了两个元素
，len 由 5 增加到 7，但 for range 时会使用 a 的副本 a&amp;rsquo; 参与循环，副本的 len 依旧是 5，因此 for range 只会循环 5 次，也就只获取 a 对应的底层数组的前 5 个元素。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-43-map-赋值-未使用包-类型断言&#34;&gt;Day 43. map 赋值, 未使用包, 类型断言&lt;/h2&gt;

&lt;p&gt;1.下面的代码有什么问题？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (  
    &amp;quot;fmt&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;time&amp;quot;
)
func main() {  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：导入的包没有被使用。如果引入一个包，但是未使用其中如何函数、接口、结构体或变量的话，代码将编译失败。&lt;/p&gt;

&lt;p&gt;如果你真的需要引入包，可以使用下划线操作符，&lt;code&gt;_&lt;/code&gt;，来作为这个包的名字，从而避免失败。下划线操作符用于引入，但不使用。&lt;/p&gt;

&lt;p&gt;我们还可以注释或者移除未使用的包。&lt;/p&gt;

&lt;p&gt;修复代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (  
    _ &amp;quot;fmt&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;time&amp;quot;
)
var _ = log.Println
func main() {  
    _ = time.Now
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引自：&lt;a href=&#34;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/&#34; target=&#34;_blank&#34;&gt;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    x := interface{}(nil)
    y := (*int)(nil)
    a := y == x
    b := y == nil
    _, c := x.(interface{})
    println(a, b, c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. true true true&lt;/li&gt;
&lt;li&gt;B. false true true&lt;/li&gt;
&lt;li&gt;C. true true true&lt;/li&gt;
&lt;li&gt;D. false true false&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：D。知识点：类型断言。类型断言语法：i.(Type)，其中 i 是接口，Type 是类型或接口。编译时会自动检测 i 的动态类型与 Type 是否一致。但是，如果动态类型不存在，则断言总是失败。参考文章《&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466700&amp;amp;idx=1&amp;amp;sn=25c48d78dcfad6c70330cd36dd749e53&amp;amp;chksm=f2474363c530ca75132454e4e10e40659310a073e2f9d30ad9697d4abf7c2b9e5aa9adee58bf&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;Go 语言接口详解（二）&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;3.下面代码有几处错误的地方？请说明原因。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {

    var s []int
    s = append(s,1)

    var m map[string]int
    m[&amp;quot;one&amp;quot;] = 1 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：有 1 出错误，不能对 nil 的 map 直接赋值，需要使用 make() 初始化。但可以使用 append() 函数对为 nil 的 slice 增加元素。&lt;/p&gt;

&lt;p&gt;修复代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var m map[string]int
    m = make(map[string]int)
    m[&amp;quot;one&amp;quot;] = 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-44-map-nil&#34;&gt;Day 44. map, nil, :=&lt;/h2&gt;

&lt;p&gt;1.下面代码有什么问题？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    m := make(map[string]int,2)
    cap(m) 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：问题：使用 cap() 获取 map 的容量。1.使用 make 创建 map 变量时可以指定第二个参数，不过会被忽略。2.cap() 函数适用于数组、数组指针、slice 和 channel，不适用于 map，可以使用 len() 返回 map 的元素个数。&lt;/p&gt;

&lt;p&gt;引自：&lt;a href=&#34;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html&#34; target=&#34;_blank&#34;&gt;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.下面的代码有什么问题？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {  
    var x = nil 
    _ = x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：nil 用于表示 interface、函数、maps、slices 和 channels 的“零值”。如果不指定变量的类型，编译器猜不出变量的具体类型，导致编译错误。&lt;/p&gt;

&lt;p&gt;修复代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var x interface{} = nil
    _ = x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.下面代码能编译通过吗？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt; type info struct {
   result int
}

func work() (int,error) {
    return 13,nil
}

func main() {
    var data info

    data.result, err := work() 
    fmt.Printf(&amp;quot;info: %+v\n&amp;quot;,data)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：编译失败。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;non-name data.result on left side of :=
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不能使用短变量声明设置结构体字段值，修复代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt; func main() {
     var data info
 
     var err error
     data.result, err = work() //ok
     if err != nil {
        fmt.Println(err)
         return
     }

    fmt.Println(data)   
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引自：&lt;a href=&#34;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html&#34; target=&#34;_blank&#34;&gt;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-45-类型别名&#34;&gt;Day 45. :=, 类型别名&lt;/h2&gt;

&lt;p&gt;1.下面代码有什么错误？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    one := 0
    one := 1 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：变量重复声明。不能在单独的声明中重复声明一个变量，但在多变量声明的时候是可以的，但必须保证至少有一个变量是新声明的。&lt;/p&gt;

&lt;p&gt;修复代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {  
    one := 0
    one, two := 1,2
    one,two = two,one
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引自：&lt;a href=&#34;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/&#34; target=&#34;_blank&#34;&gt;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.下面代码有什么问题？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    x := []int{
        1,
        2
    }
    _ = x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：编译错误，第四行代码没有逗号。用字面量初始化数组、slice 和 map 时，最好是在每个元素后面加上逗号，即使是声明在一行或者多行都不会出错。&lt;/p&gt;

&lt;p&gt;修复代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt; func main() {
     x := []int{    // 多行
         1,
         2,
     }
     x = x
 
     y := []int{3,4,} // 一行 no error
     y = y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引自：&lt;a href=&#34;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html&#34; target=&#34;_blank&#34;&gt;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt; func test(x byte)  {
     fmt.Println(x)
 }
 
 func main() {
     var a byte = 0x11 
     var b uint8 = a
     var c uint8 = a + b
     test(c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：34。与 rune 是 int32 的别名一样，byte 是 uint8 的别名，别名类型无序转换，可直接转换。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-46-常量&#34;&gt;Day 46. 常量&lt;/h2&gt;

&lt;p&gt;1.下面的代码有什么问题？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    const x = 123
    const y = 1.23
    fmt.Println(x)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：编译可以通过。知识点：常量。常量是一个简单值的标识符，在程序运行时，不会被修改的量。不像变量，常量未使用是能编译通过的。&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
     x uint16 = 120
     y
     s = &amp;quot;abc&amp;quot;
     z
)
 
func main() {
    fmt.Printf(&amp;quot;%T %v\n&amp;quot;, y, y)
    fmt.Printf(&amp;quot;%T %v\n&amp;quot;, z, z)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：知识点：常量。&lt;/p&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;uint16 120
string abc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常量组中如不指定类型和初始化值，则与上一行非空常量右值相同&lt;/p&gt;

&lt;p&gt;3.下面代码有什么问题？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {  
    var x string = nil 

    if x == nil { 
        x = &amp;quot;default&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：将 nil 分配给 string 类型的变量。这是个大多数新手会犯的错误。修复代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {  
    var x string //defaults to &amp;quot;&amp;quot; (zero value)

    if x == &amp;quot;&amp;quot; {
        x = &amp;quot;default&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引自：&lt;a href=&#34;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html&#34; target=&#34;_blank&#34;&gt;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-47-自增-自减&#34;&gt;Day 47. 自增、自减&lt;/h2&gt;

&lt;p&gt;1.下面的代码有什么问题？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    data := []int{1,2,3}
    i := 0
    ++i
    fmt.Println(data[i++])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：对于自增、自减，需要注意：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;自增、自减不在是运算符，只能作为独立语句，而不是表达式；&lt;/li&gt;
&lt;li&gt;不像其他语言，Go 语言中不支持 ++i 和 &amp;ndash;i 操作；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;表达式通常是求值代码，可作为右值或参数使用。而语句表示完成一个任务，比如 if、for 语句等。表达式可作为语句使用，但语句不能当做表达式。&lt;/p&gt;

&lt;p&gt;修复代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {  
    data := []int{1,2,3}
    i := 0
    i++
    fmt.Println(data[i])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.下面代码最后一行输出什么？请说明原因。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    x := 1
    fmt.Println(x)
    {
        fmt.Println(x)
        i,x := 2,2
        fmt.Println(i,x)
    }
   fmt.Println(x)  // print ?
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：输出&lt;code&gt;1&lt;/code&gt;。知识点：变量隐藏。使用变量简短声明符号 := 时，如果符号左边有多个变量，只需要保证至少有一个变量是新声明的，并对已定义的变量尽进行赋值操作。但如果出现作用域之后，就会导致变量隐藏的问题，就像这个例子一样。&lt;/p&gt;

&lt;p&gt;这个坑很容易挖，但又很难发现。即使对于经验丰富的 Go 开发者而言，这也是一个非常常见的陷阱。&lt;/p&gt;

&lt;p&gt;引自：&lt;a href=&#34;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/&#34; target=&#34;_blank&#34;&gt;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-48&#34;&gt;Day 48. ~ , ^,  &amp;amp;&lt;/h2&gt;

&lt;p&gt;1.下面代码有什么问题？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type foo struct {
    bar int
}

func main() {
    var f foo
    f.bar, tmp := 1, 2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：编译错误：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;non-name f.bar on left side of :=
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;:= 操作符不能用于结构体字段赋值。&lt;/p&gt;

&lt;p&gt;2.下面的代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {  
    fmt.Println(~2) 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：编译错误。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;invalid character U+007E &#39;~&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很多语言都是采用 ~ 作为按位取反运算符，Go 里面采用的是 ^ 。按位取反之后返回一个每个 bit 位都取反的数，对于有符号的整数来说，是按照补码进行取反操作的（快速计算方法：对数 a 取反，结果为 -(a+1) ），对于无符号整数来说就是按位取反。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var a int8 = 3
    var b uint8 = 3
    var c int8 = -3

    fmt.Printf(&amp;quot;^%b=%b %d\n&amp;quot;, a, ^a, ^a) // ^11=-100 -4
    fmt.Printf(&amp;quot;^%b=%b %d\n&amp;quot;, b, ^b, ^b) // ^11=11111100 252
    fmt.Printf(&amp;quot;^%b=%b %d\n&amp;quot;, c, ^c, ^c) // ^-11=10 2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外需要注意的是，如果作为二元运算符，^ 表示按位异或，即：对应位相同为 0，相异为 1。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var a int8 = 3
    var c int8 = 5

    fmt.Printf(&amp;quot;a: %08b\n&amp;quot;,a)
    fmt.Printf(&amp;quot;c: %08b\n&amp;quot;,c)
    fmt.Printf(&amp;quot;a^c: %08b\n&amp;quot;,a ^ c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给大家重点介绍下这个操作符 &amp;amp;^，按位置零，例如：z = x &amp;amp;^ y，表示如果 y 中的 bit 位为 1，则 z 对应 bit 位为 0，否则 z 对应 bit 位等于 x 中相应的 bit 位的值。&lt;/p&gt;

&lt;p&gt;不知道大家发现没有，我们还可以这样理解或操作符 | ，表达式 z = x | y，如果 y 中的 bit 位为 1，则 z 对应 bit 位为 1，否则 z 对应 bit 位等于 x 中相应的 bit 位的值，与 &amp;amp;^ 完全相反。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var x uint8 = 214
var y uint8 = 92
fmt.Printf(&amp;quot;x: %08b\n&amp;quot;,x)     
fmt.Printf(&amp;quot;y: %08b\n&amp;quot;,y)       
fmt.Printf(&amp;quot;x | y: %08b\n&amp;quot;,x | y)     
fmt.Printf(&amp;quot;x &amp;amp;^ y: %08b\n&amp;quot;,x &amp;amp;^ y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;x: 11010110
y: 01011100
x | y: 11011110
x &amp;amp;^ y: 10000010
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-49-结构体访问控制-channel&#34;&gt;Day 49. 结构体访问控制,channel&lt;/h2&gt;

&lt;p&gt;1.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var ch chan int
    select {
    case v, ok := &amp;lt;-ch:
        println(v, ok)
    default:
        println(&amp;quot;default&amp;quot;) 
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：default。ch 为 nil，读写都会阻塞。&lt;/p&gt;

&lt;p&gt;2.下面这段代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type People struct {
    name string `json:&amp;quot;name&amp;quot;`
}

func main() {
    js := `{
        &amp;quot;name&amp;quot;:&amp;quot;seekload&amp;quot;
    }`
    var p People
    err := json.Unmarshal([]byte(js), &amp;amp;p)
    if err != nil {
        fmt.Println(&amp;quot;err: &amp;quot;, err)
        return
    }
    fmt.Println(p)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：输出 {}。知识点：结构体访问控制，因为 name 首字母是小写，导致其他包不能访问，所以输出为空结构体。修复代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type People struct {
    Name string `json:&amp;quot;name&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-50-switch&#34;&gt;Day 50. switch&lt;/h2&gt;

&lt;p&gt;1.下面这段代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type T struct {
    ls []int
}

func foo(t T) {
    t.ls[0] = 100
}

func main() {
    var t = T{
        ls: []int{1, 2, 3},
    }

    foo(t)
    fmt.Println(t.ls[0])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 1&lt;/li&gt;
&lt;li&gt;B. 100&lt;/li&gt;
&lt;li&gt;C. compilation error&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：B。调用 foo() 函数时虽然是传值，但 foo() 函数中，字段 ls 依旧可以看成是指向底层数组的指针。&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    isMatch := func(i int) bool {
        switch(i) {
        case 1:
        case 2:
            return true
        }
        return false
    }

    fmt.Println(isMatch(1))
    fmt.Println(isMatch(2))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：false true。Go 语言的 switch 语句虽然没有&amp;rdquo;break&amp;rdquo;，但如果 case 完成程序会默认 break，可以在 case 语句后面加上关键字 fallthrough，这样就会接着走下一个 case 语句（不用匹配后续条件表达式）。或者，利用 case 可以匹配多个值的特性。&lt;/p&gt;

&lt;p&gt;修复代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    isMatch := func(i int) bool {
        switch(i) {
        case 1:
            fallthrough
        case 2:
            return true
        }
        return false
    }

    fmt.Println(isMatch(1))     // true
    fmt.Println(isMatch(2))     // true

    match := func(i int) bool {
        switch(i) {
        case 1,2:
            return true
        }
        return false
    }

    fmt.Println(match(1))       // true
    fmt.Println(match(2))       // true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-51-比较-struct&#34;&gt;Day 51. 比较，struct&lt;/h2&gt;

&lt;p&gt;1.下面的代码能否正确输出？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var fn1 = func() {}
    var fn2 = func() {}

    if fn1 != fn2 {
        println(&amp;quot;fn1 not equal fn2&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：编译错误&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;invalid operation: fn1 != fn2 (func can only be compared to nil)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数只能与 nil 比较。&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type T struct {
    n int
}

func main() {
    m := make(map[int]T)
    m[0].n = 1
    fmt.Println(m[0].n)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 1&lt;/li&gt;
&lt;li&gt;B. compilation error&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：B。编译错误：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;cannot assign to struct field m[0].n in map
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;map[key]struct 中 struct 是不可寻址的，所以无法直接赋值。&lt;/p&gt;

&lt;p&gt;修复代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type T struct {
     n int
}
 
func main() {
     m := make(map[int]T)
 
    t := T{1}
    m[0] = t
    fmt.Println(m[0].n)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-52-struct寻址-map&#34;&gt;Day 52. struct寻址, map&lt;/h2&gt;

&lt;p&gt;1.下面的代码有什么问题？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type X struct {}

func (x *X) test()  {
    println(x)
}

func main() {

    var a *X
    a.test()

    X{}.test()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：X{} 是不可寻址的，不能直接调用方法。知识点：在方法中，指针类型的接收者必须是合法指针（包括 nil）,或能获取实例地址。&lt;/p&gt;

&lt;p&gt;修复代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {

    var a *X
    a.test()    // 相当于 test(nil)

    var x = X{}
    x.test()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引自：《Go语言学习笔记》· 方法&lt;/p&gt;

&lt;p&gt;2.下面代码有什么不规范的地方吗？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    x := map[string]string{&amp;quot;one&amp;quot;:&amp;quot;a&amp;quot;,&amp;quot;two&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;three&amp;quot;:&amp;quot;c&amp;quot;}

   if v := x[&amp;quot;two&amp;quot;]; v == &amp;quot;&amp;quot; { 
        fmt.Println(&amp;quot;no entry&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：检查 map 是否含有某一元素，直接判断元素的值并不是一种合适的方式。最可靠的操作是使用访问 map 时返回的第二个值。&lt;/p&gt;

&lt;p&gt;修复代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {  
    x := map[string]string{&amp;quot;one&amp;quot;:&amp;quot;a&amp;quot;,&amp;quot;two&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;three&amp;quot;:&amp;quot;c&amp;quot;}

    if _,ok := x[&amp;quot;two&amp;quot;]; !ok {
        fmt.Println(&amp;quot;no entry&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引自：&lt;a href=&#34;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html&#34; target=&#34;_blank&#34;&gt;http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-53-channel-struct-寻址&#34;&gt;Day 53. channel, struct 寻址，&lt;/h2&gt;

&lt;p&gt;1.关于 channel 下面描述正确的是？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. 向已关闭的通道发送数据会引发 panic；&lt;/li&gt;
&lt;li&gt;B. 从已关闭的缓冲通道接收数据，返回已缓冲数据或者零值；&lt;/li&gt;
&lt;li&gt;C. 无论接收还是接收，nil 通道都会阻塞；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：ABC。&lt;/p&gt;

&lt;p&gt;2.下面的代码有几处问题？请详细说明。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type T struct {
    n int
}

func (t *T) Set(n int) {
    t.n = n
}

func getT() T {
    return T{}
}

func main() {
    getT().Set(1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：有两处问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.直接返回的 T{} 不可寻址；&lt;/li&gt;
&lt;li&gt;2.不可寻址的结构体不能调用带结构体指针接收者的方法；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;修复代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type T struct {
    n int
}

func (t *T) Set(n int) {
    t.n = n
}

func getT() T {
    return T{}
}

func main() {
    t := getT()
    t.Set(2)
    fmt.Println(t.n)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-54-指针-方法表达式&#34;&gt;Day 54. 指针，方法表达式&lt;/h2&gt;

&lt;p&gt;1.下面的代码有什么问题？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (n N) value(){
    n++
   fmt.Printf(&amp;quot;v:%p,%v\n&amp;quot;,&amp;amp;n,n)
}

func (n *N) pointer(){
    *n++
    fmt.Printf(&amp;quot;v:%p,%v\n&amp;quot;,n,*n)
}


func main() {

    var a N = 25

    p := &amp;amp;a
    p1 := &amp;amp;p

   p1.value()
   p1.pointer()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：编译错误：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;calling method value with receiver p1 (type **N) requires explicit dereference
calling method pointer with receiver p1 (type **N) requires explicit dereference
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不能使用多级指针调用方法。&lt;/p&gt;

&lt;p&gt;2.下面的代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type N int

func (n N) test(){
    fmt.Println(n)
}

func main()  {
    var n N = 10
    fmt.Println(n)

    n++
    f1 := N.test
    f1(n)

    n++
    f2 := (*N).test
    f2(&amp;amp;n)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：10 11 12。知识点：方法表达式。通过类型引用的方法表达式会被还原成普通函数样式，接收者是第一个参数，调用时显示传参。类型可以是 T 或 *T，只要目标方法存在于该类型的方法集中就可以。&lt;/p&gt;

&lt;p&gt;还可以直接使用方法表达式调用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main()  {
    var n N = 10

    fmt.Println(n)

    n++
    N.test(n)

    n++
    (*N).test(&amp;amp;n)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-55-channel-struct&#34;&gt;Day 55. channel, struct&lt;/h2&gt;

&lt;p&gt;1.关于 channel 下面描述正确的是？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. close() 可以用于只接收通道；&lt;/li&gt;
&lt;li&gt;B. 单向通道可以转换为双向通道；&lt;/li&gt;
&lt;li&gt;C. 不能在单向通道上做逆向操作（例如：只发送通道用于接收）；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：C。&lt;/p&gt;

&lt;p&gt;2.下面的代码有什么问题？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type T struct {
    n int
}

func getT() T {
    return T{}
}

func main() {
    getT().n = 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：编译错误：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;cannot assign to getT().n
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直接返回的 T{} 无法寻址，不可直接赋值。&lt;/p&gt;

&lt;p&gt;修复代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type T struct {
    n int
}

func getT() T {
    return T{}
}

func main() {
    t := getT()
    p := &amp;amp;t.n    // &amp;lt;=&amp;gt; p = &amp;amp;(t.n)
    *p = 1
    fmt.Println(t.n)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-56-切片-方法值&#34;&gt;Day 56. 切片，方法值&lt;/h2&gt;

&lt;p&gt;1.下面的代码有什么问题？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
    s := make([]int, 3, 9)
    fmt.Println(len(s)) 
    s2 := s[4:8]
    fmt.Println(len(s2)) 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：代码没问题，输出 3 4。&lt;strong&gt;从一个基础切片派生出的子切片的长度可能大于基础切片的长度&lt;/strong&gt;。假设基础切片是 baseSlice，使用操作符 [low,high]，有如下规则：0 &amp;lt;= low &amp;lt;= high &amp;lt;= cap(baseSlice)，只要上述满足这个关系，下标 low 和 high 都可以大于 len(baseSlice)。&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type N int

func (n N) test(){
    fmt.Println(n)
}

func main()  {
    var n N = 10
    p := &amp;amp;n

    n++
    f1 := n.test

    n++
    f2 := p.test

    n++
    fmt.Println(n)

    f1()
    f2()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：13 11 12。知识点：方法值。当指针值赋值给变量或者作为函数参数传递时，会立即计算并复制该方法执行所需的接收者对象，与其绑定，以便在稍后执行时，能隐式第传入接收者参数。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-57-panic-select&#34;&gt;Day 57. panic,select&lt;/h2&gt;

&lt;p&gt;1.下面哪一行代码会 panic，请说明原因？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

func main() {
  var x interface{}
  var y interface{} = []int{3, 5}
  _ = x == x
  _ = x == y
  _ = y == y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：第 8 行。因为两个比较值的动态类型为同一个不可比较类型。&lt;/p&gt;

&lt;p&gt;2.下面的代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var o = fmt.Print

func main() {
    c := make(chan int, 1)
    for range [3]struct{}{} {
        select {
        default:
            o(1)
        case &amp;lt;-c:
            o(2)
            c = nil
        case c &amp;lt;- 1:
            o(3)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：321。第一次循环，写操作已经准备好，执行 o(3)，输出 3；第二次，读操作准备好，执行 o(2)，输出 2 并将 c 赋值为 nil；第三次，由于 c 为 nil，走的是 default 分支，输出 1。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-58-运算符优先级-panic&#34;&gt;Day 58. 运算符优先级, panic&lt;/h2&gt;

&lt;p&gt;1.下面的代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type T struct {
    x int
    y *int
}

func main() {

    i := 20
    t := T{10,&amp;amp;i}

    p := &amp;amp;t.x

    *p++
    *p--

    t.y = p

    fmt.Println(*t.y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：10。知识点：运算符优先级。如下规则：递增运算符 ++ 和递减运算符 &amp;ndash; 的优先级低于解引用运算符 * 和取址运算符 &amp;amp;，解引用运算符和取址运算符的优先级低于选择器 . 中的属性选择操作符。&lt;/p&gt;

&lt;p&gt;2.下面哪一行代码会 panic，请说明原因？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

func main() {
    x := make([]int, 2, 10)
    _ = x[6:10]
    _ = x[6:]
    _ = x[2:]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案：第 6 行，截取符号 [i:j]，如果 j 省略，默认是原切片或者数组的长度，x 的长度是 2，小于起始下标 6 ，所以 panic。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-59-panic-方法值&#34;&gt;Day 59. panic, 方法值&lt;/h2&gt;

&lt;p&gt;1.下面的代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type N int
 
func (n *N) test(){
     fmt.Println(*n)
}
 
func main()  {
     var n N = 10
     p := &amp;amp;n

    n++
    f1 := n.test

    n++
    f2 := p.test

    n++
    fmt.Println(n)

   f1()
    f2()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：13 13 13。知识点：方法值。当目标方法的接收者是指针类型时，那么被复制的就是指针。&lt;/p&gt;

&lt;p&gt;引自：《Go语言学习笔记》· 方法&lt;/p&gt;

&lt;p&gt;2.下面哪一行代码会 panic，请说明原因？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

func main() {
  var m map[int]bool // nil
  _ = m[123]
  var p *[5]string // nil
for range p {
    _ = len(p)
  }
  var s []int // nil
  _ = s[:]
  s, s[0] = []int{1, 2}, 9
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：第 12 行。因为左侧的 s[0] 中的 s 为 nil。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-60-panic-mutex&#34;&gt;Day 60. panic,mutex&lt;/h2&gt;

&lt;p&gt;1.下面哪一行代码会 panic，请说明原因？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

type T struct{}

func (*T) foo() {
}

func (T) bar() {
}

type S struct {
  *T
}

func main() {
  s := S{}
  _ = s.foo
  s.foo()
  _ = s.bar
20}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：第 19 行，因为 s.bar 将被展开为 (*s.T).bar，而 s.T 是个空指针，解引用会 panic。&lt;/p&gt;

&lt;p&gt;可以使用下面代码输出 s：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    s := S{}
    fmt.Printf(&amp;quot;%#v&amp;quot;,s)   // 输出：main.S{T:(*main.T)(nil)}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引自：《Go语言101》&lt;/p&gt;

&lt;p&gt;2.下面的代码有什么问题？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type data struct {
    sync.Mutex
}

func (d data) test(s string)  {
   d.Lock()
    defer d.Unlock()

    for i:=0;i&amp;lt;5 ;i++  {
        fmt.Println(s,i)
        time.Sleep(time.Second)
    }
}


func main() {

    var wg sync.WaitGroup
    wg.Add(2)
    var d data

    go func() {
        defer wg.Done()
        d.test(&amp;quot;read&amp;quot;)
    }()

    go func() {
        defer wg.Done()
        d.test(&amp;quot;write&amp;quot;)
    }()

    wg.Wait()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：锁失效。将 Mutex 作为匿名字段时，相关的方法必须使用指针接收者，否则会导致锁机制失效。&lt;/p&gt;

&lt;p&gt;修复代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (d *data) test(s string)  {     // 指针接收者
    d.Lock()
    defer d.Unlock()

    for i:=0;i&amp;lt;5 ;i++  {
        fmt.Println(s,i)
        time.Sleep(time.Second)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者可以通过嵌入 *Mutex 来避免复制的问题，但需要初始化。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type data struct {
    *sync.Mutex     // *Mutex
}

func (d data) test(s string) {    // 值方法
    d.Lock()
    defer d.Unlock()

    for i := 0; i &amp;lt; 5; i++ {
        fmt.Println(s, i)
        time.Sleep(time.Second)
    }
}

func main() {

    var wg sync.WaitGroup
    wg.Add(2)

    d := data{new(sync.Mutex)}   // 初始化

    go func() {
        defer wg.Done()
        d.test(&amp;quot;read&amp;quot;)
    }()

   go func() {
        defer wg.Done()
        d.test(&amp;quot;write&amp;quot;)
    }()

    wg.Wait()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引自：《Go 语言学习笔记》· 同步&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go语言中文网面试题 1-30</title>
      <link>/go/interview/1-30/</link>
      <pubDate>Sun, 01 Dec 2019 19:15:17 +0800</pubDate>
      <guid>/go/interview/1-30/</guid>
      <description>

&lt;h2 id=&#34;day-1-panic-和-defer-顺序&#34;&gt;Day 1. panic 和 defer 顺序&lt;/h2&gt;

&lt;p&gt;问：下面这段代码的打印顺序&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
)

func main() {
    defer_call()
}

func defer_call() {
    defer func() { fmt.Println(&amp;quot;打印前&amp;quot;) }()
    defer func() { fmt.Println(&amp;quot;打印中&amp;quot;) }()
    defer func() { fmt.Println(&amp;quot;打印后&amp;quot;) }()

    panic(&amp;quot;触发异常&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;打印后
打印中
打印前
panic:触发异常
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;defer&lt;/code&gt; 的执行顺序是先进后出，当初&lt;code&gt;panic&lt;/code&gt;语句时，会先按照&lt;code&gt;defer&lt;/code&gt;的后进先出的顺序执行，最后才执行&lt;code&gt;panic&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;若把panic 移动到defer 上 ，则只有 panic(&amp;ldquo;触发异常&amp;rdquo;) 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;day-2-for-range-创建元素副本-非引用&#34;&gt;Day 2. for range 创建元素副本，非引用&lt;/h2&gt;

&lt;p&gt;问：代码的输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	slice := []int{0, 1, 2, 3}
	m := make(map[int]*int)

	for key, val := range slice {
		m[key] = &amp;amp;val
	}

	for k, v := range m {
		fmt.Println(k, &amp;quot;-&amp;gt;&amp;quot;, *v)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;0 -&amp;gt; 3
1 -&amp;gt; 3
2 -&amp;gt; 3
3 -&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;for range 循环的时候会&lt;strong&gt;创建每个元素的副本，而不是元素的引用&lt;/strong&gt;，所以 m[key] = &amp;amp;val 取的都是变量 val 的地址，所以最后 map 中的所有元素的值都是变量 val 的地址，因为最后 val 被赋值为3，所有输出都是3.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	slice := []int{0, 1, 2, 3}

	m := make(map[int]*int)

	for key, val := range slice {
		value := val
		m[key] = &amp;amp;value
		
	}

	for k, v := range m {
		fmt.Println(k, &amp;quot;-&amp;gt;&amp;quot;, *v)
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;2 -&amp;gt; 2
3 -&amp;gt; 3
0 -&amp;gt; 0
1 -&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;day-3-append-命名返回值-new和make区别&#34;&gt;Day 3. append, 命名返回值, new和make区别&lt;/h2&gt;

&lt;p&gt;问1：代码输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	s1 := make([]int, 5)
	s1 = append(s1, 1, 2, 3, 4)

	s2 := make([]int, 0)
	s2 = append(s2, 1, 2, 3, 4)

	s3 := make([]int, 2)
	s3 = append(s3, 1, 2, 3, 4)

	fmt.Println(&amp;quot;s1: &amp;quot;, s1)
	fmt.Println(&amp;quot;s2: &amp;quot;, s2)
	fmt.Println(&amp;quot;s3: &amp;quot;, s3)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;s1:  [0 0 0 0 0 1 2 3 4]
s2:  [1 2 3 4]
s3:  [0 0 1 2 3 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;问2：代码缺陷错误&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add(x,y int)(sum int, error){
	return x+y,nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;在函数有多个返回值时，只要有一个返回值有命名，其他的也必须命名。&lt;/p&gt;

&lt;p&gt;如果有多个返回值必须加上括号()；&lt;/p&gt;

&lt;p&gt;如果只有一个返回值且命名也必须加上括号()。&lt;/p&gt;

&lt;p&gt;这里的第一个返回值有命名 sum，第二个没有命名，所以错误。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//对
func add(x,y int)(sum int, err error){
	return x+y,nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;问3: make 和 new 的区别&lt;/p&gt;

&lt;p&gt;new(T) 和 make(T, args ) 是 Go 语言内建函数，用来分配内存，但适用的类型不同。&lt;/p&gt;

&lt;p&gt;new(T) 会为 T 类型的新值分配已置零的内存空间，并返回地址（指针），即类型为 *T 的值。换句话说就是，返回一个指针，该指针指向新分配的、类型为 T 的零值。适用于值类型，如数组、结构体等。&lt;/p&gt;

&lt;p&gt;make(T,args) 返回初始化之后的 T 类型的值，这个值并不是 T 类型的零值，也不是指针 *T，是经过初始化之后的 T 的引用。make() 只适用于 slice、map 和 channel.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;day-4-append&#34;&gt;Day 4. append, :=&lt;/h2&gt;

&lt;p&gt;问1：能否通过编译&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import &amp;quot;fmt&amp;quot;
//否
func main() {
	s1 := new([]int)
	s1 := append(s1, 2)
	fmt.Println(s1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不能对指针执行 append 操作,可以使用 make() 初始化之后再用。同样的，map 和 channel建议使用 make() 或字面量的方式初始化，不要用 new()&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;问2：能否通过编译&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;
//否
func main() {
	s1 := []int{1, 3, 2}
	s2 := []int{4, 5}
	s1 = append(s1, s2)
	fmt.Println(s1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不能，append() 的第二个参数不能直接使用 slice，需使用 … 操作符，将一个切片追加到另一个切片上：append(s1,s2…)。或者直接跟上元素，形如：append(s1,1,2,3)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import &amp;quot;fmt&amp;quot;

func main() {
	
	s1 := []int{1, 3, 2}
	s2 := []int{4, 5}
	s1 = append(s1, s2...)
	fmt.Println(s1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;[1 3 2 4 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;问3：能否通过编译&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var (
	size := 1024
	max_size := size*2
)

func main() 
	fmt.Println(size,max_size)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;否，变量声明的简短模式，x := 100。但这种声明方式有限制：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;必须使用显示初始化；&lt;/li&gt;
&lt;li&gt;不能提供数据类型，编译器会自动推导；&lt;/li&gt;
&lt;li&gt;只能在函数内部使用简短模式；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;day-5-结构体比较&#34;&gt;Day 5. 结构体比较&lt;/h2&gt;

&lt;p&gt;能否通过编译&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	st1 := struct {
		age  int
		name string
	}{age: 3, name: &amp;quot;qq&amp;quot;}
	st2 := struct {
		age  int
		name string
	}{age: 3, name: &amp;quot;qq&amp;quot;}

    //成员属性顺序不一样，也不能比较
	st3 := struct {
		name string
		age  int
	}{age: 3, name: &amp;quot;qq&amp;quot;}

	fmt.Println(st1 == st2)
    
	//fmt.Println(st3 == st1)编译错误

	sm1 := struct {
		age int
		n   map[string]string
	}{age: 5, n: map[string]string{&amp;quot;sd&amp;quot;: &amp;quot;sf&amp;quot;}}
	sm2 := struct {
		age int
		n   map[string]string
	}{age: 5, n: map[string]string{&amp;quot;sd&amp;quot;: &amp;quot;sf&amp;quot;}}

	//fmt.Println(sm2 == sm1) 编译错误
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;结构体只能比较是否相等，但是不能比较大小。&lt;/li&gt;
&lt;li&gt;相同类型的结构体才能够进行比较，结构体是否相同不但与属性类型有关，还与属性顺序相关，sn3 与 &lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466814&amp;amp;idx=1&amp;amp;sn=611ad5be36e7c886126f67da3f11af0e&amp;amp;chksm=f2474311c530ca070cdaa791fbe488b9ecd66667f7d08ee78068c5fbb33db1114c7bdd4a625c&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;sn1&lt;/a&gt; 就是不同的结构体；&lt;/li&gt;
&lt;li&gt;如果 struct 的所有成员都可以比较，则该 struct 就可以&lt;strong&gt;通过 == 或 != 进行比较&lt;/strong&gt;是否相等，比较时逐个项进行比较，如果每一项都相等，则两个结构体才相等，否则不相等；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;可比较&lt;/strong&gt;： bool、数值型、字符、指针、数组等&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不可比较&lt;/strong&gt;：切片、map、函数等。&lt;/p&gt;

&lt;h2 id=&#34;day-6-指针-类型别名与定义-值传递&#34;&gt;Day 6. 指针，类型别名与定义，值传递&lt;/h2&gt;

&lt;p&gt;问1.通过指针变量 p 访问其成员变量 name，有哪几种方式？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A.p.name&lt;/li&gt;
&lt;li&gt;B.(&amp;amp;p).name&lt;/li&gt;
&lt;li&gt;C.(*p).name&lt;/li&gt;
&lt;li&gt;D.p-&amp;gt;name&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;答：AC&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;问2：能否通过编译&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type myInt1 int
type myInt2 = int

func main() {
	var i int = 0
	var i1 myInt1 = i
	var i2 myInt2 = i
	fmt.Println(i1, i2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;.\day-6.go:10:6: cannot use i (type int) as type myInt1 in assignment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类型别名与类型定义的区别。&lt;/p&gt;

&lt;p&gt;第 5 行代码是基于类型 int 创建了新类型 MyInt1&lt;/p&gt;

&lt;p&gt;第 6 行代码是创建了 int 的类型别名 MyInt2，注意类型别名的定义时 = 。&lt;/p&gt;

&lt;p&gt;所以，第 10 行代码相当于是将 int 类型的变量赋值给 MyInt1 类型的变量，Go 是强类型语言，编译当然不通过；而 MyInt2 只是 int 的别名，本质上还是 int，可以赋值。&lt;/p&gt;

&lt;p&gt;第 10 行代码的赋值可以使用强制类型转化 var i1 MyInt1 = MyInt1(i).&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;问3：输出是什么&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
	a := []int{7, 8, 9}
	fmt.Printf(&amp;quot;%+v\n&amp;quot;, a)
	ap(a)
	fmt.Printf(&amp;quot;%+v\n&amp;quot;, a)
	app(a)
	fmt.Printf(&amp;quot;%+v\n&amp;quot;, a)

}

func ap(a []int) {
	a = append(a, 10)
}

func app(a []int) {
	a[0] = 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;[7 8 9]
[7 8 9]
[1 8 9]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;append 导致底层数组重新分配内存了,创建了新切片，ap 中的 a 这个slice 的底层数组和外面的不是一个，并没有改变外面的。app会修改底层数组内容，会改变&lt;/p&gt;

&lt;h2 id=&#34;day-7-字符串拼接-iota&#34;&gt;Day 7. 字符串拼接，iota&lt;/h2&gt;

&lt;p&gt;问1： 关于字符串连接，下面语法正确的是？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. str := &amp;lsquo;abc&amp;rsquo; + &amp;lsquo;123&amp;rsquo;&lt;/li&gt;
&lt;li&gt;B. str := &amp;ldquo;abc&amp;rdquo; + &amp;ldquo;123&amp;rdquo;&lt;/li&gt;
&lt;li&gt;C. str := &amp;lsquo;123&amp;rsquo; + &amp;ldquo;abc&amp;rdquo;&lt;/li&gt;
&lt;li&gt;D. fmt.Sprintf(&amp;ldquo;abc%d&amp;rdquo;, 123)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;答：BD。知识点：字符串连接。除了以上两种连接方式，还有 strings.Join()，buffer.WriteString()等。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;问2：输出什么&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import &amp;quot;fmt&amp;quot;

const (
	x = iota
	_
	y
	z = &amp;quot;zz&amp;quot;
	k
	p = iota
)

func main() {
	fmt.Println(x, y, z, k, p)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;0 2 zz zz 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/zsy/p/5370052.html&#34; target=&#34;_blank&#34;&gt;iota详细&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1iota是golang语言的常量计数器,只能在常量的表达式中使用。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;每次 const 出现时，都会让 iota 初始化为0.【自增长】&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const a = iota // a=0
const (
 	b = iota     //b=0
 	c           / /c=1
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;可以使用下划线跳过不想要的值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;中间插队&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
  i = iota
  j = 3.14
  k = iota
  l
)
//那么打印出来的结果是 i=0,j=3.14,k=2,l=3
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;问3：下面赋值正确的是()&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. var x = nil&lt;/li&gt;
&lt;li&gt;B. var x interface{} = nil&lt;/li&gt;
&lt;li&gt;C. var x string = nil&lt;/li&gt;
&lt;li&gt;D. var x error = nil&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：BD。知识点：nil 值。nil 只能赋值给指针、chan、func、interface、map 或 slice 类型的变量。强调下 D 选项的 error 类型，它是一种内置接口类型，看下方贴出的源码就知道，所以 D 是对的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type error interface {
    Error() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;day-8-init-函数-类型选择-interface-type&#34;&gt;Day 8. init 函数, 类型选择 interface.(type)&lt;/h2&gt;

&lt;p&gt;问1：关于init函数，下面说法正确的是()&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A. 一个包中，可以包含多个 init 函数；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;B. 程序编译时，先执行依赖包的 init 函数，再执行 main 包内的 init 函数；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C. main 包中，不能有 init 函数；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;D. init 函数可以被其他函数调用；&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;答：参考答案及解析：AB。关于 init() 函数有几个需要注意的地方：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;init() 函数是用于程序执行前做包的初始化的函数，比如初始化包里的变量等;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;一个包可以出线多个 init() 函数,一个源文件也可以包含多个 init() 函数；&lt;/li&gt;
&lt;li&gt;同一个包中多个 init() 函数的执行顺序没有明确定义，&lt;strong&gt;但是不同包的init函数是根据包导入的依赖关系决定的&lt;/strong&gt;（看下图）;&lt;/li&gt;
&lt;li&gt;init() 函数在代码中不能被显示调用、不能被引用（赋值给函数变量），否则出现编译错误;&lt;/li&gt;
&lt;li&gt;一个包被引用多次，如 A import B,C import B,A import C，B 被引用多次，但 B 包只会初始化一次；&lt;/li&gt;
&lt;li&gt;引入包，不可出现死循坏。即 A import B,B import A，这种情况编译失败；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&#34;./8-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;问2：代码输出什么&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func hello() []string {
	return nil
}
func main() {
	h := hello
	if h == nil {
		fmt.Println(nil)
	} else {
		fmt.Println(&amp;quot;not nil&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. nil&lt;/li&gt;
&lt;li&gt;B. not nil&lt;/li&gt;
&lt;li&gt;C. compilation error&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;答案及解析：B。这道题目里面，是将 hello() 赋值给变量 h，而不是函数的返回值，所以输出 not nil。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;问3：能否编译通过&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func getValue() int {
	return 1
}

func main() {
	i := getValue()
	switch i.(type) {
	case int:
		fmt.Println(&amp;quot;int&amp;quot;)
	case string:
		fmt.Println(&amp;quot;string&amp;quot;)
	case interface{}:
		fmt.Println(&amp;quot;interface&amp;quot;)
	default:
		print(&amp;quot;default&amp;quot;)

	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;.\day-8.go:23:2: cannot type switch on non-interface value i (type int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类型选择的语法形如：i.(type)，其中 i 是接口，type 是固定关键字，需要注意的是，只有接口类型才可以使用类型选择。看下关于&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466668&amp;amp;idx=1&amp;amp;sn=adcc1d23efff1047bbe7f6450065081a&amp;amp;chksm=f2474283c530cb9554aa9ee92b4332f3cc374c32bb0b51f0e031880c74641e190b50338fd9bc&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;接口&lt;/a&gt;的文章。&lt;/p&gt;

&lt;h2 id=&#34;day-9-channel-可变函数&#34;&gt;Day 9. channel, 可变函数&lt;/h2&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;p&gt;问1：关于channel，下面语法正确的是()&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. var ch chan int&lt;/li&gt;
&lt;li&gt;B. ch := make(chan int)&lt;/li&gt;
&lt;li&gt;C. &amp;lt;- ch&lt;/li&gt;
&lt;li&gt;D. ch &amp;lt;-&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：ABC。A、B都是声明 channel；C 读取 channel；写 channel 是必须带上值，所以 D 错误。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;问2：代码输出？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type person struct {
	name string
}

func main() {
	var m map[person]int
	p := person{
		name: &amp;quot;lili&amp;quot;,
	}

	fmt.Println(m[p])
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 0&lt;/li&gt;
&lt;li&gt;B. 1&lt;/li&gt;
&lt;li&gt;C. Compilation error&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：A。打印一个 map 中不存在的值时，返回元素类型的零值。这个例子中，m 的类型是 map[person]int，因为 m 中不存在 p，所以打印 int 类型的零值，即 0。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;问3：代码输出？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func hello(num ...int) {
	num[0] = 18
}
func main() {
	i := []int{5, 6, 7}
	hello(i...)
	fmt.Println(i[0])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;18。知识点：可变函数。&lt;/p&gt;

&lt;h2 id=&#34;day-10-比较-s-i-j-k-切片&#34;&gt;day 10. 比较，s[i: j: k]切片&lt;/h2&gt;

&lt;p&gt;问1：代码输出？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {  
    a := 5
    b := 8.1
    fmt.Println(a + b)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 13.1&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;B. 13&lt;/li&gt;
&lt;li&gt;C. compilation error&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;C。a 的类型是 int，b 的类型是 float，两个不同类型的数值不能相加，编译报错。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;问2：代码输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (  
    &amp;quot;fmt&amp;quot;
)

func main() {  
    a := [5]int{1, 2, 3, 4, 5}
    t := a[3:4:4]
    //t := a[3:4:6]编译错误
    fmt.Println(t[0])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 3&lt;/li&gt;
&lt;li&gt;B. 4&lt;/li&gt;
&lt;li&gt;C. compilation error&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;B。知识点：操作符 [i,j]。基于数组（切片）可以使用操作符 [i,j] 创建新的切片，从索引 i，到索引 j 结束，截取已有数组（切片）的任意部分，返回新的切片，新切片的值包含原数组（切片）的 i 索引的值，但是不包含 j 索引的值。i、j 都是可选的，i 如果省略，默认是 0，j 如果省略，默认是原数组（切片）的长度。i、j 都不能超过这个长度值。&lt;/p&gt;

&lt;p&gt;假如底层数组的大小为 k，截取之后获得的切片的长度和容量的计算方法：&lt;strong&gt;长度：j-i，容量：k-i&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;截取操作符还可以有第三个参数，形如 [i,j,k]，第三个参数 k 用来限制新切片的容量，&lt;strong&gt;但不能超过原数组（切片）的底层数组大小&lt;/strong&gt;。截取获得的切片的长度和容量分别是：&lt;strong&gt;j-i、k-i。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所以例子中，切片 t 为 [4]，长度和容量都是 1。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;问3：代码输出？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    a := [2]int{5, 6}
    b := [3]int{5, 6}
    if a == b {
        fmt.Println(&amp;quot;equal&amp;quot;)
    } else {
        fmt.Println(&amp;quot;not equal&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. compilation error&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;B. equal&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;C. not equal&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A。Go 中的数组是值类型，可比较，另外一方面，数组的长度也是数组类型的组成部分，所以 a 和 b 是不同的类型，是不能比较的，所以编译错误。&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;h2 id=&#34;day-11-cap-interface-map删除&#34;&gt;Day 11.  cap(), interface, map删除&lt;/h2&gt;

&lt;p&gt;问1.关于 cap() 函数的适用类型，下面说法正确的是()&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. array&lt;/li&gt;
&lt;li&gt;B. slice&lt;/li&gt;
&lt;li&gt;C. map&lt;/li&gt;
&lt;li&gt;D. channel&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ABD。知识点：cap()，cap() 函数不适用 map。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;问2：代码输出？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {  
    var i interface{}
    if i == nil {
        fmt.Println(&amp;quot;nil&amp;quot;)
        return
    }
    fmt.Println(&amp;quot;not nil&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. nil&lt;/li&gt;
&lt;li&gt;B. not nil&lt;/li&gt;
&lt;li&gt;C. compilation error&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A。当且仅当接口的动态值和动态类型都为 nil 时，接口类型值才为 nil。&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466668&amp;amp;idx=1&amp;amp;sn=adcc1d23efff1047bbe7f6450065081a&amp;amp;chksm=f2474283c530cb9554aa9ee92b4332f3cc374c32bb0b51f0e031880c74641e190b50338fd9bc&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;文章&lt;/a&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;问3：代码输出？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {  
    s := make(map[string]int)
    delete(s, &amp;quot;h&amp;quot;)
    fmt.Println(s[&amp;quot;h&amp;quot;])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. runtime panic&lt;/li&gt;
&lt;li&gt;B. 0&lt;/li&gt;
&lt;li&gt;C. compilation error&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;B。删除 map 不存在的键值对时，不会报错，相当于没有任何作用；获取不存在的减值对时，返回值类型对应的零值，所以返回 0。&lt;/p&gt;

&lt;h2 id=&#34;day-12-关键字-结构体嵌套&#34;&gt;day 12. 关键字，结构体嵌套&lt;/h2&gt;

&lt;p&gt;问1：下面属于关键字的是（）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. func&lt;/li&gt;
&lt;li&gt;B. struct&lt;/li&gt;
&lt;li&gt;C. class&lt;/li&gt;
&lt;li&gt;D. defer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ABD。知识点：Go 语言的关键字。Go 语言有 25 个关键字，看下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./12-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;问2：代码输出？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {  
    i := -5
    j := +5
    fmt.Printf(&amp;quot;%+d %+d&amp;quot;, i, j)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. -5 +5&lt;/li&gt;
&lt;li&gt;B. +5 +5&lt;/li&gt;
&lt;li&gt;C. 0  0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A。&lt;code&gt;%d&lt;/code&gt;表示输出十进制数字，&lt;code&gt;+&lt;/code&gt;表示输出数值的符号。这里不表示取反。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;问3： 代码输出？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type People struct{}

func (p *People) ShowA() {
    fmt.Println(&amp;quot;showA&amp;quot;)
    p.ShowB()
}
func (p *People) ShowB() {
    fmt.Println(&amp;quot;showB&amp;quot;)
}

type Teacher struct {
    People
}

func (t *Teacher) ShowB() {
    fmt.Println(&amp;quot;teacher showB&amp;quot;)
}

func main() {
    t := Teacher{}
    t.ShowB()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;teacher showB。&lt;/p&gt;

&lt;p&gt;知识点：结构体嵌套。在嵌套结构体中，People 称为内部类型，Teacher 称为外部类型；通过嵌套，内部类型的属性、方法，可以为外部类型所有，就好像是外部类型自己的一样。此外，外部类型还可以定义自己的属性和方法，甚至可以定义与内部相同的方法，这样内部类型的方法就会被“屏蔽”。这个例子中的 ShowB() 就是同名方法。&lt;/p&gt;

&lt;p&gt;关于结构体嵌套可以看下&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466766&amp;amp;idx=1&amp;amp;sn=02a0221869095c201053957c40395460&amp;amp;chksm=f2474321c530ca377999562f07acf5407e83e574568e71b9ab001c927ed2d715f653192f19da&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;day-13-全局声明-defer-结构体嵌套&#34;&gt;Day 13. 全局声明, defer, 结构体嵌套&lt;/h2&gt;

&lt;p&gt;问1：定义一个包内全局字符串变量，下面语法正确的是（）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A. var str string&lt;/li&gt;
&lt;li&gt;B. str := &amp;ldquo;&amp;rdquo;&lt;/li&gt;
&lt;li&gt;C. str = &amp;ldquo;&amp;rdquo;&lt;/li&gt;
&lt;li&gt;D. var str = &amp;ldquo;&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;：AD。B 只支持局部变量声明；C 是赋值，str 必须在这之前已经声明；&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;问2：下面这段代码输出什么?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func hello(i int) {  
    fmt.Println(i)
}
func main() {  
    i := 5
    defer hello(i)
    i = i + 10
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5。这个例子中，hello() 函数的参数在执行 defer 语句的时候会保存一份副本，在实际调用 hello() 函数时用，所以是 5.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;问3：下面这段代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type People struct{}

func (p *People) ShowA() {
    fmt.Println(&amp;quot;showA&amp;quot;)
    p.ShowB()
}
func (p *People) ShowB() {
    fmt.Println(&amp;quot;showB&amp;quot;)
}

type Teacher struct {
    People
}

func (t *Teacher) ShowB() {
    fmt.Println(&amp;quot;teacher showB&amp;quot;)
}

func main() {
    t := Teacher{}
    t.ShowA()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;showA
showB&lt;/p&gt;

&lt;p&gt;结构体嵌套。这道题可以结合第 12 天的第三题一起看，Teacher 没有自己 ShowA()，所以调用内部类型 People 的同名方法，需要注意的是第 5 行代码调用的是 People 自己的 ShowB 方法。&lt;/p&gt;

&lt;h2 id=&#34;day-14-字符串常量-可变函数&#34;&gt;Day 14. 字符串常量, 可变函数&lt;/h2&gt;

&lt;p&gt;问1：代码输出？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    str := &amp;quot;hello&amp;quot;
    str[0] = &#39;x&#39;
    fmt.Println(str)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. hello&lt;/li&gt;
&lt;li&gt;B. xello&lt;/li&gt;
&lt;li&gt;C. compilation error&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;C。知识点：常量，Go 语言中的字符串是只读的&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;问2： 代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func incr(p *int) int {
    *p++
    return *p
}

func main() {
    p :=1
    incr(&amp;amp;p)
    fmt.Println(p)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 1&lt;/li&gt;
&lt;li&gt;B. 2&lt;/li&gt;
&lt;li&gt;C. 3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;B。知识点：指针，incr() 函数里的 p 是 &lt;code&gt;*int&lt;/code&gt; 类型的指针，指向的是 main() 函数的变量 p 的地址。第 2 行代码是将该地址的值执行一个自增操作，incr() 返回自增后的结果。&lt;/p&gt;

&lt;p&gt;参考下&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466791&amp;amp;idx=2&amp;amp;sn=1834521de50c6af6624d11e34e59a8b2&amp;amp;chksm=f2474308c530ca1e78ce4e6f6e029ffa6f83279333e39aff354799ab6882c1e3813c159388f5&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;指针&lt;/a&gt;的文章&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;问3：对 add() 函数调用正确的是（）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add(args ...int) int {

    sum := 0
    for _, arg := range args {
        sum += arg
    }
    return sum
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. add(1, 2)&lt;/li&gt;
&lt;li&gt;B. add(1, 3, 7)&lt;/li&gt;
&lt;li&gt;C. add([]int{1, 2})&lt;/li&gt;
&lt;li&gt;D. add([]int{1, 3, 7}…}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ABD。知识点：&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466706&amp;amp;idx=3&amp;amp;sn=003c213739e51088ad4947e473429775&amp;amp;chksm=f247437dc530ca6bafebe0a5a4090343cbf1eb992e36b6199cf213be6156273179465ed41348&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;可变函数&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;day-15-nil-切片和空切片-实现接口&#34;&gt;Day 15. nil 切片和空切片，实现接口&lt;/h2&gt;

&lt;p&gt;1.下面代码下划线处可以填入哪个选项？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var s1 []int
    var s2 = []int{}
    if __ == nil {
        fmt.Println(&amp;quot;yes nil&amp;quot;)
    }else{
        fmt.Println(&amp;quot;no nil&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. s1&lt;/li&gt;
&lt;li&gt;B. s2&lt;/li&gt;
&lt;li&gt;C. s1、s2 都可以&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A。知识点：nil 切片和空切片。nil 切片和 nil 相等，一般用来表示一个不存在的切片；空切片和 nil 不相等，表示一个空的集合。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;2.下面这段代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {  
    i := 65
    fmt.Println(string(i))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. A&lt;/li&gt;
&lt;li&gt;B. 65&lt;/li&gt;
&lt;li&gt;C. compilation error&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A。UTF-8 编码中，十进制数字 65 对应的符号是 A。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;3.下面这段代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type A interface {
    ShowA() int
}

type B interface {
    ShowB() int
}

type Work struct {
    i int
}

func (w Work) ShowA() int {
    return w.i + 10
}

func (w Work) ShowB() int {
    return w.i + 20
}

func main() {
    c := Work{3}
    var a A = c
    var b B = c
    fmt.Println(a.ShowA())
    fmt.Println(b.ShowB())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;13 23。&lt;/p&gt;

&lt;p&gt;接口。一种类型实现多个接口，结构体 Work 分别实现了接口 A、B，所以接口变量 a、b 调用各自的方法 ShowA() 和 ShowB()，输出 13、23&lt;/p&gt;

&lt;h2 id=&#34;day-16-cap-len-接口的静态类型-map初始化&#34;&gt;Day 16. cap(),len(), 接口的静态类型, map初始化&lt;/h2&gt;

&lt;p&gt;1.切片 a、b、c 的长度和容量分别是多少？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {

    s := [3]int{1, 2, 3}
    a := s[:0]
    b := s[:2]
    c := s[1:2:cap(s)]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.下面代码中 A B 两处应该怎么修改才能顺利编译？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var m map[string]int        //A
    m[&amp;quot;a&amp;quot;] = 1
    if v := m[&amp;quot;b&amp;quot;]; v != nil {  //B
        fmt.Println(v)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type A interface {
    ShowA() int
}

type B interface {
    ShowB() int
}

type Work struct {
    i int
}

func (w Work) ShowA() int {
    return w.i + 10
}

func (w Work) ShowB() int {
    return w.i + 20
}

func main() {
    c := Work{3}
    var a A = c
    var b B = c
    fmt.Println(a.ShowB())
    fmt.Println(b.ShowA())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 23 13&lt;/li&gt;
&lt;li&gt;B. compilation error&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;解析：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.参考答案及解析：a、b、c 的长度和容量分别是 0 3、2 3、1 2。&lt;/p&gt;

&lt;p&gt;知识点：数组或切片的截取操作。截取操作有带 2 个或者 3 个参数，形如：[i:j] 和 [i:j:k]，假设截取对象的底层数组长度为 l。&lt;/p&gt;

&lt;p&gt;在操作符 [i:j] 中，如果 i 省略，默认 0，如果 j 省略，默认底层数组的长度，截取得到的&lt;strong&gt;切片长度和容量计算方法是 j-i、l-i&lt;/strong&gt;。操作符 [i:j:k]，&lt;/p&gt;

&lt;p&gt;k 主要是用来限制切片的容量，但是不能大于数组的长度 l，截取得到的&lt;strong&gt;切片长度和容量计算方法是 j-i、k-i&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;2.参考答案及解析：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    m := make(map[string]int)
    m[&amp;quot;a&amp;quot;] = 1
    if v,ok := m[&amp;quot;b&amp;quot;]; ok {
        fmt.Println(v)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 A 处只声明了map m ,并没有分配内存空间，不能直接赋值，需要使用 make()，都提倡使用 make() 或者字面量的方式直接初始化 map。&lt;/p&gt;

&lt;p&gt;B 处，&lt;code&gt;v,k := m[&amp;quot;b&amp;quot;]&lt;/code&gt; 当 key 为 b 的元素不存在的时候，v 会返回值类型对应的零值，k 返回 false。&lt;/p&gt;

&lt;p&gt;3.参考答案及解析：B。知识点：接口的静态类型。a、b 具有相同的动态类型和动态值，分别是结构体 work 和 {3}；a 的静态类型是 A，b 的静态类型是 B，接口 A 不包括方法 ShowB()，接口 B 也不包括方法 ShowA()，编译报错。看下编译错误：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a.ShowB undefined (type A has no field or method ShowB)
b.ShowA undefined (type B has no field or method ShowA)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多知识点看下&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466700&amp;amp;idx=1&amp;amp;sn=25c48d78dcfad6c70330cd36dd749e53&amp;amp;chksm=f2474363c530ca75132454e4e10e40659310a073e2f9d30ad9697d4abf7c2b9e5aa9adee58bf&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;接口的文章&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;day-18-变量声明-defer-接口&#34;&gt;Day 18. 变量声明，defer，接口&lt;/h2&gt;

&lt;p&gt;1.下面代码中，x 已声明，y 没有声明，判断每条语句的对错。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;1. x, _ := f()
2. x, _ = f()
3. x, y := f()
4. x, y = f()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func increaseA() int {
    var i int
    defer func() {
        i++
    }()
    return i
}

func increaseB() (r int) {
    defer func() {
        r++
    }()
    return r
}

func main() {
    fmt.Println(increaseA())
    fmt.Println(increaseB())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 1 1&lt;/li&gt;
&lt;li&gt;B. 0 1&lt;/li&gt;
&lt;li&gt;C. 1 0&lt;/li&gt;
&lt;li&gt;D. 0 0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type A interface {
    ShowA() int
}

type B interface {
    ShowB() int
}

type Work struct {
    i int
}

func (w Work) ShowA() int {
    return w.i + 10
}

func (w Work) ShowB() int {
    return w.i + 20
}

func main() {
    var a A = Work{3}
    s := a.(Work)
    fmt.Println(s.ShowA())
    fmt.Println(s.ShowB())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 13 23&lt;/li&gt;
&lt;li&gt;B. compilation error&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;解析：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.参考答案及解析：错、对、对、错。知识点：变量的声明。1.错，x 已经声明，不能使用 :=；2.对；3.对，当多值赋值时，:= 左边的变量无论声明与否都可以；4.错，y 没有声明。&lt;/p&gt;

&lt;p&gt;2.参考答案及解析：B。知识点：defer、返回值。注意一下，increaseA() 的返回参数是匿名，increaseB() 是具名。&lt;/p&gt;

&lt;p&gt;3.参考答案及解析：A。知识点：类型断言。这道题可以和第 15 天的第三题 和第 16 天的第三题结合起来看，具体的解析看&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466700&amp;amp;idx=1&amp;amp;sn=25c48d78dcfad6c70330cd36dd749e53&amp;amp;chksm=f2474363c530ca75132454e4e10e40659310a073e2f9d30ad9697d4abf7c2b9e5aa9adee58bf&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;《Go 语言接口详解（二）》&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;day-19-defer&#34;&gt;Day 19. defer&lt;/h2&gt;

&lt;p&gt;1.下面代码段输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Person struct {
    age int
}

func main() {
    person := &amp;amp;Person{28}

    // 1. 
    defer fmt.Println(person.age)

    // 2.
    defer func(p *Person) {
        fmt.Println(p.age)
    }(person)  

    // 3.
    defer func() {
        fmt.Println(person.age)
    }()

    person.age = 29
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;29 29 28。变量 person 是一个指针变量 。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;person.age 此时是将 28 当做 defer 函数的参数，会把 28 缓存在栈中，等到最后执行该 defer 语句的时候取出，即输出 28；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;defer 缓存的是结构体 Person{28} 的地址，最终 Person{28} 的 age 被重新赋值为 29，所以 defer 语句最后执行的时候，依靠缓存的地址取出的 age 便是 29，即输出 29；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;闭包引用，输出 29；&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;又由于 defer 的执行顺序为先进后出，即 3 2 1，所以输出 29 29 28。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;amp;mid=2651435212&amp;amp;idx=1&amp;amp;sn=16da319f0b15b65b6a0f29eca2bc3d9d&amp;amp;chksm=80bb6e3eb7cce7289734ba2ed7d903742b7bf7c4b0baa4bcc59cc196bace183e679d0e69b5b5&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;『GCTT 出品』Go 中 defer 的 5 个坑 - 第一部分&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;amp;mid=2651435220&amp;amp;idx=1&amp;amp;sn=ed8f057bbd483590cbe052c1f6395f20&amp;amp;chksm=80bb6e26b7cce730687b22187d2c836d79e2742e6615a61b0201c79909ce4187a70735fbd15b&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;『GCTT 出品』Golang 中 defer 的五个坑 - 第二部分&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;amp;mid=2651435392&amp;amp;idx=1&amp;amp;sn=bdc2c43ef6273f2b1e5a2a7f7e666db1&amp;amp;chksm=80bb6f72b7cce6643e84ee9e31d14161a7ba07106495bb0915a15d0bb76e151951d38fafced4&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;Golang 中 defer 的五个坑 - 第三部分&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466918&amp;amp;idx=2&amp;amp;sn=151a8135f22563b7b97bf01ff480497b&amp;amp;chksm=f2474389c530ca9f3dc2ae1124e4e5ed3db4c45096924265bccfcb8908a829b9207b0dd26047&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;5 年 Gopher 都不知道的 defer 细节，你别再掉进坑里！&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;day-20-defer&#34;&gt;Day 20. defer&lt;/h2&gt;

&lt;p&gt;1.下面这段代码正确的输出是什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func f() {
    defer fmt.Println(&amp;quot;D&amp;quot;)
    fmt.Println(&amp;quot;F&amp;quot;)
}

func main() {
    f()
    fmt.Println(&amp;quot;M&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. F M D&lt;/li&gt;
&lt;li&gt;B. D F M&lt;/li&gt;
&lt;li&gt;C. F D M&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;2.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Person struct {
    age int
}

func main() {
    person := &amp;amp;Person{28}

    // 1.
    defer fmt.Println(person.age)

    // 2.
    defer func(p *Person) {
        fmt.Println(p.age)
    }(person)

    // 3.
    defer func() {
        fmt.Println(person.age)
    }()

    person = &amp;amp;Person{29}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;解析：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.参考答案及解析：C。被调用函数里的 defer 语句在返回之前就会被执行，所以输出顺序是 F D M。&lt;/p&gt;

&lt;p&gt;2.参考答案及解析：29 28 28。&lt;/p&gt;

&lt;p&gt;这道题在第 19 天题目的基础上做了一点点小改动，前一题最后一行代码 &lt;code&gt;person.age = 29&lt;/code&gt; 是修改引用对象的成员 age，这题最后一行代码 &lt;code&gt;person = &amp;amp;Person{29}&lt;/code&gt; 是修改引用对象本身，来看看有什么区别。&lt;/p&gt;

&lt;p&gt;1处. person.age 这一行代码跟之前含义是一样的，此时是将 28 当做 defer 函数的参数，会把 28 缓存在栈中，等到最后执行该 defer 语句的时候取出，即输出 28；&lt;/p&gt;

&lt;p&gt;2处. defer 缓存的是结构体 Person{28} 的地址，这个地址指向的结构体没有被改变，最后 defer 语句后面的函数执行的时候取出仍是 28；&lt;/p&gt;

&lt;p&gt;3处. 闭包引用，person 的值已经被改变，指向结构体 &lt;code&gt;Person{29}&lt;/code&gt;，所以输出 29.&lt;/p&gt;

&lt;p&gt;由于 defer 的执行顺序为先进后出，即 3 2 1，所以输出 29 28 28。&lt;/p&gt;

&lt;h2 id=&#34;day-21-切片声明-接口&#34;&gt;Day 21. 切片声明，接口&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下面的两个切片声明中有什么区别？哪个更可取？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;A. var a []int
B. a := []int{}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A、B、C、D 哪些选项有语法错误？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type S struct {
}

func f(x interface{}) {
}

func g(x *interface{}) {
}

func main() {
s := S{}
p := &amp;amp;s
f(s) //A
g(s) //B
f(p) //C
g(p) //D
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下面 A、B 两处应该填入什么代码，才能确保顺利打印出结果？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type S struct {
m string
}

func f() *S {
return __  //A
}

func main() {
p := __    //B
fmt.Println(p.m) //print &amp;quot;foo&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;解析：&lt;/p&gt;

&lt;p&gt;1、参考答案及解析：A 声明的是 nil 切片；B 声明的是长度和容量都为 0 的空切片。第一种切片声明不会分配内存，优先选择。&lt;/p&gt;

&lt;p&gt;2、参考答案及解析：BD。函数参数为 interface{} 时可以接收任何类型的参数，包括用户自定义类型等，即使是接收指针类型也用 interface{}，而不是使用 *interface{}。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;永远不要使用一个指针指向一个接口类型，因为它已经是一个指针。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3.参考答案及解析：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A. &amp;amp;S{&amp;quot;foo&amp;quot;} 
B. *f() 或者 f()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;f() 函数返回参数是指针类型，所以可以用 &amp;amp; 取结构体的指针；B 处，如果填 &lt;code&gt;*f()&lt;/code&gt;，则 p 是 S 类型；如果填 &lt;code&gt;f()&lt;/code&gt;，则 p 是 *S 类型，不过都可以使用 &lt;code&gt;p.m&lt;/code&gt; 取得结构体的成员。&lt;/p&gt;

&lt;h2 id=&#34;day-22-字符串与nil-defer&#34;&gt;Day 22. 字符串与nil，defer&lt;/h2&gt;

&lt;p&gt;1.下面的代码有几处语法问题，各是什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main
import (
    &amp;quot;fmt&amp;quot;
)
func main() {
    var x string = nil
    if x == nil {
        x = &amp;quot;default&amp;quot;
    }
    fmt.Println(x)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.return 之后的 defer 语句会执行吗，下面这段代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var a bool = true
func main() {
    defer func(){
        fmt.Println(&amp;quot;1&amp;quot;)
    }()
    if a == true {
        fmt.Println(&amp;quot;2&amp;quot;)
        return
    }
    defer func(){
        fmt.Println(&amp;quot;3&amp;quot;)
    }()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析：**&lt;/p&gt;

&lt;p&gt;1.参考答案及解析：两个地方有语法问题。golang 的字符串类型是不能赋值 nil 的，也不能跟 nil 比较。&lt;/p&gt;

&lt;p&gt;2.参考答案及解析：2 1。defer 关键字后面的函数或者方法想要执行必须先注册，return 之后的 defer 是不能注册的， 也就不能执行后面的函数或方法。&lt;/p&gt;

&lt;h2 id=&#34;day-23-切片-代码块和变量作用域&#34;&gt;Day 23. 切片，代码块和变量作用域&lt;/h2&gt;

&lt;p&gt;1.下面这段代码输出什么？为什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {

    s1 := []int{1, 2, 3}
    s2 := s1[1:]
    s2[1] = 4
    fmt.Println(s1)
    s2 = append(s2, 5, 6, 7)
    fmt.Println(s1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.下面选项正确的是？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    if a := 1; false {
    } else if b := 2; false {
    } else {
        println(a, b)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 1 2&lt;/li&gt;
&lt;li&gt;B. compilation error&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1.参考答案及解析：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1 2 4]
[1 2 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们知道，golang 中切片底层的数据结构是数组。当使用 s1[1:] 获得切片 s2，和 s1 共享同一个底层数组，这会导致 s2[1] = 4 语句影响 s1。&lt;/p&gt;

&lt;p&gt;而 append 操作会导致底层数组扩容，生成新的数组，因此追加数据后的 s2 不会影响 s1。&lt;/p&gt;

&lt;p&gt;但是为什么对 s2 赋值后影响的却是 s1 的第三个元素呢？这是因为切片 s2 是从数组的第二个元素开始，s2 索引为 1 的元素对应的是 s1 索引为 2 的元素。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;./23-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;2.参考答案及解析：A。知识点：代码块和变量作用域。推荐 TonyBai 老师的一篇&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzIyNzM0MDk0Mg==&amp;amp;mid=2247484052&amp;amp;idx=1&amp;amp;sn=eab928ea5b67046f4cdc933634db17cc&amp;amp;chksm=e863e575df146c63710dd1ea180c58b3eff451d0247b3e11cad71b1369e03726fecfca6eeb8f&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;文章&lt;/a&gt;，讲的很详细！&lt;/p&gt;

&lt;h2 id=&#34;day-24-map-defer&#34;&gt;Day 24. map ，defer&lt;/h2&gt;

&lt;p&gt;1.下面这段代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    m := map[int]string{0:&amp;quot;zero&amp;quot;,1:&amp;quot;one&amp;quot;}
    for k,v := range m {
        fmt.Println(k,v)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;0 zero
1 one
// 或者
1 one
0 zero
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;map 的输出是无序的。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;2.下面这段代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    a := 1
    b := 2
    defer calc(&amp;quot;1&amp;quot;, a, calc(&amp;quot;10&amp;quot;, a, b))
    a = 0
    defer calc(&amp;quot;2&amp;quot;, a, calc(&amp;quot;20&amp;quot;, a, b))
    b = 1
}

func calc(index string, a, b int) int {
    ret := a + b
    fmt.Println(index, a, b, ret)
    return ret
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;10 1 2 3
20 0 2 2
2 0 2 2
1 1 3 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序执行到 main() 函数三行代码的时候，会先执行 calc() 函数的 b 参数&lt;code&gt;calc(&amp;quot;10&amp;quot;,a,b)&lt;/code&gt;，输出：10 1 2 3，得到值 3，&lt;/p&gt;

&lt;p&gt;因为defer 定义的函数是延迟函数，故 calc(&amp;ldquo;1&amp;rdquo;,1,3) 会被延迟执行；&lt;/p&gt;

&lt;p&gt;程序执行到第五行的时候，同样先执行 calc(&amp;ldquo;20&amp;rdquo;,a,b) 输出：20 0 2 2 得到值 2，同样将 calc(&amp;ldquo;2&amp;rdquo;,0,2) 延迟执行；&lt;/p&gt;

&lt;p&gt;程序执行到末尾的时候，按照栈先进后出的方式依次执行：calc(&amp;ldquo;2&amp;rdquo;,0,2)，calc(&amp;ldquo;1&amp;rdquo;,1,3)，则就依次输出：2 0 2 2，1 1 3 4。&lt;/p&gt;

&lt;h2 id=&#34;day-25-类的方法-接口&#34;&gt;Day 25. 类的方法，接口&lt;/h2&gt;

&lt;p&gt;1.下面这段代码输出什么？为什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (i int) PrintInt ()  {
    fmt.Println(i)
}

func main() {
    var i int = 1
    i.PrintInt()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 1&lt;/li&gt;
&lt;li&gt;B. compilation error&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：B。&lt;strong&gt;基于类型创建的方法必须定义在同一个包内&lt;/strong&gt;，上面的代码基于 int 类型创建了 PrintInt() 方法，由于 int 类型和方法 PrintInt() 定义在不同的包内，所以编译出错。&lt;/p&gt;

&lt;p&gt;解决的办法可以定义一种新的类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Myint int

func (i Myint) PrintInt ()  {
    fmt.Println(i)
}

func main() {
    var i Myint = 1
    i.PrintInt()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;2.下面这段代码输出什么？为什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type People interface {
    Speak(string) string
}

type Student struct{}

func (stu *Student) Speak(think string) (talk string) {
    if think == &amp;quot;speak&amp;quot; {
        talk = &amp;quot;speak&amp;quot;
    } else {
        talk = &amp;quot;hi&amp;quot;
    }
    return
}

func main() {
    var peo People = Student{}
    think := &amp;quot;speak&amp;quot;
    fmt.Println(peo.Speak(think))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. speak&lt;/li&gt;
&lt;li&gt;B. compilation error&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：B。编译错误 &lt;code&gt;Student does not implement People (Speak method has pointer receiver)&lt;/code&gt;，值类型 &lt;code&gt;Student&lt;/code&gt; 没有实现接口的 &lt;code&gt;Speak()&lt;/code&gt; 方法，而是指针类型 &lt;code&gt;*Student&lt;/code&gt; 实现该方法。&lt;/p&gt;

&lt;h2 id=&#34;day-26-iota-接口&#34;&gt;Day 26. iota，接口&lt;/h2&gt;

&lt;p&gt;1.下面这段代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (
    a = iota
    b = iota
)
const (
    name = &amp;quot;name&amp;quot;
    c    = iota
    d    = iota
)
func main() {
    fmt.Println(a)
    fmt.Println(b)
    fmt.Println(c)
    fmt.Println(d)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：0 1 1 2。知识点：iota 的用法。&lt;/p&gt;

&lt;p&gt;iota 是 golang 语言的常量计数器，只能在常量的表达式中使用。&lt;/p&gt;

&lt;p&gt;iota 在 const 关键字出现时将被重置为0，const中每新增一行常量声明将使 iota 计数一次。&lt;/p&gt;

&lt;p&gt;推荐阅读：
golang 使用 iota：&lt;a href=&#34;https://studygolang.com/articles/2192&#34; target=&#34;_blank&#34;&gt;https://studygolang.com/articles/2192&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;2.下面这段代码输出什么？为什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type People interface {
    Show()
}

type Student struct{}

func (stu *Student) Show() {

}

func main() {

    var s *Student
    if s == nil {
        fmt.Println(&amp;quot;s is nil&amp;quot;)
    } else {
        fmt.Println(&amp;quot;s is not nil&amp;quot;)
    }
    var p People = s
    if p == nil {
        fmt.Println(&amp;quot;p is nil&amp;quot;)
    } else {
        fmt.Println(&amp;quot;p is not nil&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：&lt;code&gt;s is nil&lt;/code&gt; 和 &lt;code&gt;p is not nil&lt;/code&gt;。这道题会不会有点诧异，我们分配给变量 p 的值明明是 nil，然而 p 却不是 nil。记住一点，&lt;strong&gt;当且仅当动态值和动态类型都为 nil 时，接口类型值才为 nil&lt;/strong&gt;。上面的代码，给变量 p 赋值之后，p 的动态值是 nil，但是动态类型却是 *Student，是一个 nil 指针，所以相等条件不成立。&lt;/p&gt;

&lt;p&gt;更多细节可以参考&lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466668&amp;amp;idx=1&amp;amp;sn=adcc1d23efff1047bbe7f6450065081a&amp;amp;chksm=f2474283c530cb9554aa9ee92b4332f3cc374c32bb0b51f0e031880c74641e190b50338fd9bc&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;Go 语言接口详解（一）&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-27-iota-map&#34;&gt;Day 27.  iota，map&lt;/h2&gt;

&lt;p&gt;1.下面这段代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Direction int

const (
    North Direction = iota
    East
    South
    West
)

func (d Direction) String() string {
    return [...]string{&amp;quot;North&amp;quot;, &amp;quot;East&amp;quot;, &amp;quot;South&amp;quot;, &amp;quot;West&amp;quot;}[d]
}

func main() {
    fmt.Println(South)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：South。知识点：iota 的用法、类型的 String() 方法。&lt;/p&gt;

&lt;p&gt;根据 iota 的用法推断出 South 的值是 3；另外，如果类型定义了 String() 方法，当使用 &lt;code&gt;fmt.Printf()&lt;/code&gt;、&lt;code&gt;fmt.Print()&lt;/code&gt; 和 &lt;code&gt;fmt.Println()&lt;/code&gt; 会自动使用 String() 方法，实现字符串的打印。&lt;/p&gt;

&lt;p&gt;2.下面代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Math struct {
    x, y int
}

var m = map[string]Math{
    &amp;quot;foo&amp;quot;: Math{2, 3},
}

func main() {
    m[&amp;quot;foo&amp;quot;].x = 4
    fmt.Println(m[&amp;quot;foo&amp;quot;].x)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 4&lt;/li&gt;
&lt;li&gt;B. compilation error&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：B，编译报错 &lt;code&gt;cannot assign to struct field m[&amp;quot;foo&amp;quot;].x in map&lt;/code&gt;。错误原因：对于类似 &lt;code&gt;X = Y&lt;/code&gt;的赋值操作，必须知道 &lt;code&gt;X&lt;/code&gt; 的地址，才能够将 &lt;code&gt;Y&lt;/code&gt; 的值赋给 &lt;code&gt;X&lt;/code&gt;，但 go 中的 map 的 value 本身是不可寻址的。&lt;/p&gt;

&lt;p&gt;有两个解决办法：&lt;/p&gt;

&lt;p&gt;1.&lt;strong&gt;使用临时变量&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Math struct {
    x, y int
}

var m = map[string]Math{
    &amp;quot;foo&amp;quot;: Math{2, 3},
}

func main() {
    tmp := m[&amp;quot;foo&amp;quot;]
    tmp.x = 4
    m[&amp;quot;foo&amp;quot;] = tmp
    fmt.Println(m[&amp;quot;foo&amp;quot;].x)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.&lt;strong&gt;修改数据结构&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Math struct {
    x, y int
}

var m = map[string]*Math{
    &amp;quot;foo&amp;quot;: &amp;amp;Math{2, 3},
}

func main() {
    m[&amp;quot;foo&amp;quot;].x = 4
    fmt.Println(m[&amp;quot;foo&amp;quot;].x)
    fmt.Printf(&amp;quot;%#v&amp;quot;, m[&amp;quot;foo&amp;quot;])   // %#v 格式化输出详细信息
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;day-28-比较-变量作用域&#34;&gt;Day 28. 比较，变量作用域&lt;/h2&gt;

&lt;p&gt;1.下面的代码有什么问题？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    fmt.Println([...]int{1} == [2]int{1})
    fmt.Println([]int{1} == []int{1})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：有两处错误&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;go 中不同类型是不能比较的，而数组长度是数组类型的一部分，所以 &lt;code&gt;[…]int{1}&lt;/code&gt; 和 &lt;code&gt;[2]int{1}&lt;/code&gt; 是两种不同的类型，不能比较；&lt;/li&gt;
&lt;li&gt;切片是不能比较的&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;2.下面这段代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var p *int

func foo() (*int, error) {
    var i int = 5
    return &amp;amp;i, nil
}

func bar() {
    //use p
    fmt.Println(*p)
}

func main() {
    p, err := foo()
    if err != nil {
        fmt.Println(err)
        return
    }
    bar()
    fmt.Println(*p)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A. 5 5&lt;/li&gt;
&lt;li&gt;B. runtime error&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考答案及解析：B。知识点：变量作用域。问题出在操作符&lt;code&gt;:=&lt;/code&gt;，对于使用&lt;code&gt;:=&lt;/code&gt;定义的变量，如果新变量与同名已定义的变量不在同一个作用域中，那么 Go 会新定义这个变量。对于本例来说，main() 函数里的 p 是新定义的变量，会遮住全局变量 p，导致执行到&lt;code&gt;bar()&lt;/code&gt;时程序，全局变量 p 依然还是 nil，程序随即 Crash。&lt;/p&gt;

&lt;p&gt;正确的做法是将 main() 函数修改为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var err error
    p, err = foo()
    if err != nil {
        fmt.Println(err)
        return
    }
    bar()
    fmt.Println(*p)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这道题目引自 Tony Bai 老师的一篇文章，原文讲的很详细，推荐。
&lt;a href=&#34;https://tonybai.com/2015/01/13/a-hole-about-variable-scope-in-golang/&#34; target=&#34;_blank&#34;&gt;https://tonybai.com/2015/01/13/a-hole-about-variable-scope-in-golang/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-29-for-range&#34;&gt;Day 29. for range&lt;/h2&gt;

&lt;p&gt;1.下面这段代码能否正常结束？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    v := []int{1, 2, 3}
    for i := range v {
        v = append(v, i)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：不会出现死循环，能正常结束。
循环次数在循环开始前就已经确定，循环内改变切片的长度，不影响循环次数。&lt;/p&gt;

&lt;p&gt;2.下面这段代码输出什么？为什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {

    var m = [...]int{1, 2, 3}

    for i, v := range m {
        go func() {
            fmt.Println(i, v)
        }()
    }

    time.Sleep(time.Second * 3)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;2 3
2 3
2 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;for range 使用短变量声明(:=)的形式迭代变量，需要注意的是，变量 i、v 在每次循环体中都会被重用，而不是重新声明。&lt;/p&gt;

&lt;p&gt;各个 goroutine 中输出的 i、v 值都是 for range 循环结束后的 i、v 最终值，而不是各个goroutine启动时的i, v值。可以理解为闭包引用，使用的是上下文环境的值。&lt;/p&gt;

&lt;p&gt;两种可行的 fix 方法:&lt;/p&gt;

&lt;p&gt;1.&lt;strong&gt;使用函数传递&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for i, v := range m {
    go func(i,v int) {
        fmt.Println(i, v)
    }(i,v)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.&lt;strong&gt;使用临时变量保留当前值&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for i, v := range m {
    i := i           // 这里的 := 会重新声明变量，而不是重用
    v := v
    go func() {
        fmt.Println(i, v)
    }()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引自：&lt;a href=&#34;https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/&#34; target=&#34;_blank&#34;&gt;https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;day-30-defer-for-range&#34;&gt;Day 30. defer ，for range&lt;/h2&gt;

&lt;p&gt;1.下面这段代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func f(n int) (r int) {
    defer func() {
        r += n
        recover()
    }()

    var f func()

    defer f()
    f = func() {
        r += 2
    }
    return n + 1
}

func main() {
    fmt.Println(f(3))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：7。&lt;/p&gt;

&lt;p&gt;根据 &lt;a href=&#34;http://mp.weixin.qq.com/s?__biz=MzI2MDA1MTcxMg==&amp;amp;mid=2648466918&amp;amp;idx=2&amp;amp;sn=151a8135f22563b7b97bf01ff480497b&amp;amp;chksm=f2474389c530ca9f3dc2ae1124e4e5ed3db4c45096924265bccfcb8908a829b9207b0dd26047&amp;amp;scene=21#wechat_redirect&#34; target=&#34;_blank&#34;&gt;5 年 Gopher 都不知道的 defer 细节，你别再掉进坑里！&lt;/a&gt; 提到的“三步拆解法”，第一步执行&lt;code&gt;r = n +1&lt;/code&gt;，接着执行第二个 defer，由于此时 f() 未定义，引发异常，随即执行第一个 defer，异常被 recover()，程序正常执行，最后 return。&lt;/p&gt;

&lt;p&gt;2.下面这段代码输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var a = [5]int{1, 2, 3, 4, 5}
    var r [5]int

    for i, v := range a {
        if i == 0 {
            a[1] = 12
            a[2] = 13
        }
        r[i] = v
    }
    fmt.Println(&amp;quot;r = &amp;quot;, r)
    fmt.Println(&amp;quot;a = &amp;quot;, a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考答案及解析：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;r =  [1 2 3 4 5]
a =  [1 12 13 4 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;range 表达式是副本参与循环，就是说例子中参与循环的是 a 的副本，而不是真正的 a。就这个例子来说，假设 b 是 a 的副本，则 range 循环代码是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for i, v := range b {
    if i == 0 {
        a[1] = 12
        a[2] = 13
    }
    r[i] = v
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此无论 a 被如何修改，其副本 b 依旧保持原值，并且参与循环的是 b，因此 v 从 b 中取出的仍旧是 a 的原值，而非修改后的值。&lt;/p&gt;

&lt;p&gt;如果想要 r 和 a 一样输出，修复办法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    var a = [5]int{1, 2, 3, 4, 5}
    var r [5]int

    for i, v := range &amp;amp;a {
        if i == 0 {
            a[1] = 12
            a[2] = 13
        }
        r[i] = v
    }
    fmt.Println(&amp;quot;r = &amp;quot;, r)
    fmt.Println(&amp;quot;a = &amp;quot;, a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;r =  [1 12 13 4 5]
a =  [1 12 13 4 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修复代码中，使用 *[5]int 作为 range 表达式，其副本依旧是一个指向原数组 a 的指针，因此后续所有循环中均是 &amp;amp;a 指向的原数组亲自参与的，因此 v 能从 &amp;amp;a 指向的原数组中取出 a 修改后的值。&lt;/p&gt;

&lt;p&gt;引自：&lt;a href=&#34;https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/&#34; target=&#34;_blank&#34;&gt;https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
